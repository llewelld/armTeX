#define EXTERN extern
#include "texd.h"

void zshipout ( p ) 
halfword p ; 
{/* 30 */ shipout_regmem 
  integer pageloc  ; 
  char j, k  ; 
  poolpointer s  ; 
  char oldsetting  ; 
  if ( eqtb [ 9197 ] .cint > 0 ) 
  {
    printnl ( 335 ) ; 
    println () ; 
    print ( 823 ) ; 
  } 
  if ( termoffset > maxprintline - 9 ) 
  println () ; 
  else if ( ( termoffset > 0 ) || ( fileoffset > 0 ) ) 
  printchar ( 32 ) ; 
  printchar ( 91 ) ; 
  j = 9 ; 
  while ( ( eqtb [ 9218 + j ] .cint == 0 ) && ( j > 0 ) ) decr ( j ) ; 
  {register integer for_end; k = 0 ; for_end = j ; if ( k <= for_end) do 
    {
      printint ( eqtb [ 9218 + k ] .cint ) ; 
      if ( k < j ) 
      printchar ( 46 ) ; 
    } 
  while ( k++ < for_end ) ; } 
  flush ( stdout ) ; 
  if ( eqtb [ 9197 ] .cint > 0 ) 
  {
    printchar ( 93 ) ; 
    begindiagnostic () ; 
    showbox ( p ) ; 
    enddiagnostic ( true ) ; 
  } 
  if ( ( mem [ p + 3 ] .cint > 1073741823L ) || ( mem [ p + 2 ] .cint > 
  1073741823L ) || ( mem [ p + 3 ] .cint + mem [ p + 2 ] .cint + eqtb [ 9749 ] 
  .cint > 1073741823L ) || ( mem [ p + 1 ] .cint + eqtb [ 9748 ] .cint > 
  1073741823L ) ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 827 ) ; 
    } 
    {
      helpptr = 2 ; 
      helpline [ 1 ] = 828 ; 
      helpline [ 0 ] = 829 ; 
    } 
    error () ; 
    if ( eqtb [ 9197 ] .cint <= 0 ) 
    {
      begindiagnostic () ; 
      printnl ( 830 ) ; 
      showbox ( p ) ; 
      enddiagnostic ( true ) ; 
    } 
    goto lab30 ; 
  } 
  if ( mem [ p + 3 ] .cint + mem [ p + 2 ] .cint + eqtb [ 9749 ] .cint > maxv 
  ) 
  maxv = mem [ p + 3 ] .cint + mem [ p + 2 ] .cint + eqtb [ 9749 ] .cint ; 
  if ( mem [ p + 1 ] .cint + eqtb [ 9748 ] .cint > maxh ) 
  maxh = mem [ p + 1 ] .cint + eqtb [ 9748 ] .cint ; 
  dvih = 0 ; 
  dviv = 0 ; 
  curh = eqtb [ 9748 ] .cint ; 
  dvif = 0 ; 
  if ( outputfilename == 0 ) 
  {
    if ( jobname == 0 ) 
    openlogfile () ; 
    packjobname ( 788 ) ; 
    riscostype = riscosdvitype ; 
    while ( ! bopenout ( dvifile ) ) promptfilename ( 789 , 788 ) ; 
    outputfilename = bmakenamestring ( dvifile ) ; 
  } 
  if ( totalpages == 0 ) 
  {
    {
      dvibuf [ dviptr ] = 247 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    {
      dvibuf [ dviptr ] = 2 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    dvifour ( 25400000L ) ; 
    dvifour ( 473628672L ) ; 
    preparemag () ; 
    dvifour ( eqtb [ 9180 ] .cint ) ; 
    oldsetting = selector ; 
    selector = 21 ; 
    print ( 821 ) ; 
    printint ( eqtb [ 9186 ] .cint ) ; 
    printchar ( 46 ) ; 
    printtwo ( eqtb [ 9185 ] .cint ) ; 
    printchar ( 46 ) ; 
    printtwo ( eqtb [ 9184 ] .cint ) ; 
    printchar ( 58 ) ; 
    printtwo ( eqtb [ 9183 ] .cint / 60 ) ; 
    printtwo ( eqtb [ 9183 ] .cint % 60 ) ; 
    selector = oldsetting ; 
    {
      dvibuf [ dviptr ] = ( poolptr - strstart [ strptr ] ) ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    {register integer for_end; s = strstart [ strptr ] ; for_end = poolptr - 
    1 ; if ( s <= for_end) do 
      {
	dvibuf [ dviptr ] = strpool [ s ] ; 
	incr ( dviptr ) ; 
	if ( dviptr == dvilimit ) 
	dviswap () ; 
      } 
    while ( s++ < for_end ) ; } 
    poolptr = strstart [ strptr ] ; 
  } 
  pageloc = dvioffset + dviptr ; 
  {
    dvibuf [ dviptr ] = 139 ; 
    incr ( dviptr ) ; 
    if ( dviptr == dvilimit ) 
    dviswap () ; 
  } 
  {register integer for_end; k = 0 ; for_end = 9 ; if ( k <= for_end) do 
    dvifour ( eqtb [ 9218 + k ] .cint ) ; 
  while ( k++ < for_end ) ; } 
  dvifour ( lastbop ) ; 
  lastbop = pageloc ; 
  curv = mem [ p + 3 ] .cint + eqtb [ 9749 ] .cint ; 
  tempptr = p ; 
  if ( mem [ p ] .hh.b0 == 1 ) 
  vlistout () ; 
  else hlistout () ; 
  {
    dvibuf [ dviptr ] = 140 ; 
    incr ( dviptr ) ; 
    if ( dviptr == dvilimit ) 
    dviswap () ; 
  } 
  incr ( totalpages ) ; 
  curs = -1 ; 
  lab30: ; 
  if ( eqtb [ 9197 ] .cint <= 0 ) 
  printchar ( 93 ) ; 
  deadcycles = 0 ; 
  flush ( stdout ) ; 
	;
#ifdef STAT
  if ( eqtb [ 9194 ] .cint > 1 ) 
  {
    printnl ( 824 ) ; 
    printint ( varused ) ; 
    printchar ( 38 ) ; 
    printint ( dynused ) ; 
    printchar ( 59 ) ; 
  } 
#endif /* STAT */
  flushnodelist ( p ) ; 
	;
#ifdef STAT
  if ( eqtb [ 9194 ] .cint > 1 ) 
  {
    print ( 825 ) ; 
    printint ( varused ) ; 
    printchar ( 38 ) ; 
    printint ( dynused ) ; 
    print ( 826 ) ; 
    printint ( himemmin - lomemmax - 1 ) ; 
    println () ; 
  } 
#endif /* STAT */
} 
void zscanspec ( c , threecodes ) 
groupcode c ; 
boolean threecodes ; 
{/* 40 */ scanspec_regmem 
  integer s  ; 
  char speccode  ; 
  if ( threecodes ) 
  s = savestack [ saveptr + 0 ] .cint ; 
  if ( scankeyword ( 836 ) ) 
  speccode = 0 ; 
  else if ( scankeyword ( 837 ) ) 
  speccode = 1 ; 
  else {
      
    speccode = 1 ; 
    curval = 0 ; 
    goto lab40 ; 
  } 
  scandimen ( false , false , false ) ; 
  lab40: if ( threecodes ) 
  {
    savestack [ saveptr + 0 ] .cint = s ; 
    incr ( saveptr ) ; 
  } 
  savestack [ saveptr + 0 ] .cint = speccode ; 
  savestack [ saveptr + 1 ] .cint = curval ; 
  saveptr = saveptr + 2 ; 
  newsavelevel ( c ) ; 
  scanleftbrace () ; 
} 
halfword zhpack ( p , w , m ) 
halfword p ; 
scaled w ; 
smallnumber m ; 
{/* 21 50 10 */ register halfword Result; hpack_regmem 
  halfword r  ; 
  halfword q  ; 
  scaled h, d, x  ; 
  scaled s  ; 
  halfword g  ; 
  glueord o  ; 
  internalfontnumber f  ; 
  fourquarters i  ; 
  eightbits hd  ; 
  lastbadness = 0 ; 
  r = getnode ( 7 ) ; 
  mem [ r ] .hh.b0 = 0 ; 
  mem [ r ] .hh.b1 = 0 ; 
  mem [ r + 4 ] .cint = 0 ; 
  q = r + 5 ; 
  mem [ q ] .hh .v.RH = p ; 
  h = 0 ; 
  d = 0 ; 
  x = 0 ; 
  totalstretch [ 0 ] = 0 ; 
  totalshrink [ 0 ] = 0 ; 
  totalstretch [ 1 ] = 0 ; 
  totalshrink [ 1 ] = 0 ; 
  totalstretch [ 2 ] = 0 ; 
  totalshrink [ 2 ] = 0 ; 
  totalstretch [ 3 ] = 0 ; 
  totalshrink [ 3 ] = 0 ; 
  while ( p != 0 ) {
      
    lab21: while ( ( p >= himemmin ) ) {
	
      f = mem [ p ] .hh.b0 ; 
      i = fontinfo [ charbase [ f ] + mem [ p ] .hh.b1 ] .qqqq ; 
      hd = i .b1 ; 
      x = x + fontinfo [ widthbase [ f ] + i .b0 ] .cint ; 
      s = fontinfo [ heightbase [ f ] + ( hd ) / 16 ] .cint ; 
      if ( s > h ) 
      h = s ; 
      s = fontinfo [ depthbase [ f ] + ( hd ) % 16 ] .cint ; 
      if ( s > d ) 
      d = s ; 
      p = mem [ p ] .hh .v.RH ; 
    } 
    if ( p != 0 ) 
    {
      switch ( mem [ p ] .hh.b0 ) 
      {case 0 : 
      case 1 : 
      case 2 : 
      case 13 : 
	{
	  x = x + mem [ p + 1 ] .cint ; 
	  if ( mem [ p ] .hh.b0 >= 2 ) 
	  s = 0 ; 
	  else s = mem [ p + 4 ] .cint ; 
	  if ( mem [ p + 3 ] .cint - s > h ) 
	  h = mem [ p + 3 ] .cint - s ; 
	  if ( mem [ p + 2 ] .cint + s > d ) 
	  d = mem [ p + 2 ] .cint + s ; 
	} 
	break ; 
      case 3 : 
      case 4 : 
      case 5 : 
	if ( adjusttail != 0 ) 
	{
	  while ( mem [ q ] .hh .v.RH != p ) q = mem [ q ] .hh .v.RH ; 
	  if ( mem [ p ] .hh.b0 == 5 ) 
	  {
	    mem [ adjusttail ] .hh .v.RH = mem [ p + 1 ] .cint ; 
	    while ( mem [ adjusttail ] .hh .v.RH != 0 ) adjusttail = mem [ 
	    adjusttail ] .hh .v.RH ; 
	    p = mem [ p ] .hh .v.RH ; 
	    freenode ( mem [ q ] .hh .v.RH , 2 ) ; 
	  } 
	  else {
	      
	    mem [ adjusttail ] .hh .v.RH = p ; 
	    adjusttail = p ; 
	    p = mem [ p ] .hh .v.RH ; 
	  } 
	  mem [ q ] .hh .v.RH = p ; 
	  p = q ; 
	} 
	break ; 
      case 8 : 
	; 
	break ; 
      case 10 : 
	{
	  g = mem [ p + 1 ] .hh .v.LH ; 
	  x = x + mem [ g + 1 ] .cint ; 
	  o = mem [ g ] .hh.b0 ; 
	  totalstretch [ o ] = totalstretch [ o ] + mem [ g + 2 ] .cint ; 
	  o = mem [ g ] .hh.b1 ; 
	  totalshrink [ o ] = totalshrink [ o ] + mem [ g + 3 ] .cint ; 
	  if ( mem [ p ] .hh.b1 >= 100 ) 
	  {
	    g = mem [ p + 1 ] .hh .v.RH ; 
	    if ( mem [ g + 3 ] .cint > h ) 
	    h = mem [ g + 3 ] .cint ; 
	    if ( mem [ g + 2 ] .cint > d ) 
	    d = mem [ g + 2 ] .cint ; 
	  } 
	} 
	break ; 
      case 11 : 
      case 9 : 
	x = x + mem [ p + 1 ] .cint ; 
	break ; 
      case 6 : 
	{
	  mem [ memtop - 12 ] = mem [ p + 1 ] ; 
	  mem [ memtop - 12 ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
	  p = memtop - 12 ; 
	  goto lab21 ; 
	} 
	break ; 
	default: 
	; 
	break ; 
      } 
      p = mem [ p ] .hh .v.RH ; 
    } 
  } 
  if ( adjusttail != 0 ) 
  mem [ adjusttail ] .hh .v.RH = 0 ; 
  mem [ r + 3 ] .cint = h ; 
  mem [ r + 2 ] .cint = d ; 
  if ( m == 1 ) 
  w = x + w ; 
  mem [ r + 1 ] .cint = w ; 
  x = w - x ; 
  if ( x == 0 ) 
  {
    mem [ r + 5 ] .hh.b0 = 0 ; 
    mem [ r + 5 ] .hh.b1 = 0 ; 
    mem [ r + 6 ] .gr = 0.0 ; 
    goto lab10 ; 
  } 
  else if ( x > 0 ) 
  {
    if ( totalstretch [ 3 ] != 0 ) 
    o = 3 ; 
    else if ( totalstretch [ 2 ] != 0 ) 
    o = 2 ; 
    else if ( totalstretch [ 1 ] != 0 ) 
    o = 1 ; 
    else o = 0 ; 
    mem [ r + 5 ] .hh.b1 = o ; 
    mem [ r + 5 ] .hh.b0 = 1 ; 
    if ( totalstretch [ o ] != 0 ) 
    mem [ r + 6 ] .gr = x / ((double) totalstretch [ o ] ) ; 
    else {
	
      mem [ r + 5 ] .hh.b0 = 0 ; 
      mem [ r + 6 ] .gr = 0.0 ; 
    } 
    if ( o == 0 ) 
    if ( mem [ r + 5 ] .hh .v.RH != 0 ) 
    {
      lastbadness = badness ( x , totalstretch [ 0 ] ) ; 
      if ( lastbadness > eqtb [ 9189 ] .cint ) 
      {
	println () ; 
	if ( lastbadness > 100 ) 
	printnl ( 838 ) ; 
	else printnl ( 839 ) ; 
	print ( 840 ) ; 
	printint ( lastbadness ) ; 
	goto lab50 ; 
      } 
    } 
    goto lab10 ; 
  } 
  else {
      
    if ( totalshrink [ 3 ] != 0 ) 
    o = 3 ; 
    else if ( totalshrink [ 2 ] != 0 ) 
    o = 2 ; 
    else if ( totalshrink [ 1 ] != 0 ) 
    o = 1 ; 
    else o = 0 ; 
    mem [ r + 5 ] .hh.b1 = o ; 
    mem [ r + 5 ] .hh.b0 = 2 ; 
    if ( totalshrink [ o ] != 0 ) 
    mem [ r + 6 ] .gr = ( - (integer) x ) / ((double) totalshrink [ o ] ) ; 
    else {
	
      mem [ r + 5 ] .hh.b0 = 0 ; 
      mem [ r + 6 ] .gr = 0.0 ; 
    } 
    if ( ( totalshrink [ o ] < - (integer) x ) && ( o == 0 ) && ( mem [ r + 5 
    ] .hh .v.RH != 0 ) ) 
    {
      lastbadness = 1000000L ; 
      mem [ r + 6 ] .gr = 1.0 ; 
      if ( ( - (integer) x - totalshrink [ 0 ] > eqtb [ 9738 ] .cint ) || ( 
      eqtb [ 9189 ] .cint < 100 ) ) 
      {
	if ( ( eqtb [ 9746 ] .cint > 0 ) && ( - (integer) x - totalshrink [ 0 
	] > eqtb [ 9738 ] .cint ) ) 
	{
	  while ( mem [ q ] .hh .v.RH != 0 ) q = mem [ q ] .hh .v.RH ; 
	  mem [ q ] .hh .v.RH = newrule () ; 
	  mem [ mem [ q ] .hh .v.RH + 1 ] .cint = eqtb [ 9746 ] .cint ; 
	} 
	println () ; 
	printnl ( 846 ) ; 
	printscaled ( - (integer) x - totalshrink [ 0 ] ) ; 
	print ( 847 ) ; 
	goto lab50 ; 
      } 
    } 
    else if ( o == 0 ) 
    if ( mem [ r + 5 ] .hh .v.RH != 0 ) 
    {
      lastbadness = badness ( - (integer) x , totalshrink [ 0 ] ) ; 
      if ( lastbadness > eqtb [ 9189 ] .cint ) 
      {
	println () ; 
	printnl ( 848 ) ; 
	printint ( lastbadness ) ; 
	goto lab50 ; 
      } 
    } 
    goto lab10 ; 
  } 
  lab50: if ( outputactive ) 
  print ( 841 ) ; 
  else {
      
    if ( packbeginline != 0 ) 
    {
      if ( packbeginline > 0 ) 
      print ( 842 ) ; 
      else print ( 843 ) ; 
      printint ( abs ( packbeginline ) ) ; 
      print ( 844 ) ; 
    } 
    else print ( 845 ) ; 
    printint ( line ) ; 
  } 
  println () ; 
  fontinshortdisplay = 0 ; 
  shortdisplay ( mem [ r + 5 ] .hh .v.RH ) ; 
  println () ; 
  begindiagnostic () ; 
  showbox ( r ) ; 
  enddiagnostic ( true ) ; 
  lab10: Result = r ; 
  return(Result) ; 
} 
halfword zvpackage ( p , h , m , l ) 
halfword p ; 
scaled h ; 
smallnumber m ; 
scaled l ; 
{/* 50 10 */ register halfword Result; vpackage_regmem 
  halfword r  ; 
  scaled w, d, x  ; 
  scaled s  ; 
  halfword g  ; 
  glueord o  ; 
  lastbadness = 0 ; 
  r = getnode ( 7 ) ; 
  mem [ r ] .hh.b0 = 1 ; 
  mem [ r ] .hh.b1 = 0 ; 
  mem [ r + 4 ] .cint = 0 ; 
  mem [ r + 5 ] .hh .v.RH = p ; 
  w = 0 ; 
  d = 0 ; 
  x = 0 ; 
  totalstretch [ 0 ] = 0 ; 
  totalshrink [ 0 ] = 0 ; 
  totalstretch [ 1 ] = 0 ; 
  totalshrink [ 1 ] = 0 ; 
  totalstretch [ 2 ] = 0 ; 
  totalshrink [ 2 ] = 0 ; 
  totalstretch [ 3 ] = 0 ; 
  totalshrink [ 3 ] = 0 ; 
  while ( p != 0 ) {
      
    if ( ( p >= himemmin ) ) 
    confusion ( 849 ) ; 
    else switch ( mem [ p ] .hh.b0 ) 
    {case 0 : 
    case 1 : 
    case 2 : 
    case 13 : 
      {
	x = x + d + mem [ p + 3 ] .cint ; 
	d = mem [ p + 2 ] .cint ; 
	if ( mem [ p ] .hh.b0 >= 2 ) 
	s = 0 ; 
	else s = mem [ p + 4 ] .cint ; 
	if ( mem [ p + 1 ] .cint + s > w ) 
	w = mem [ p + 1 ] .cint + s ; 
      } 
      break ; 
    case 8 : 
      ; 
      break ; 
    case 10 : 
      {
	x = x + d ; 
	d = 0 ; 
	g = mem [ p + 1 ] .hh .v.LH ; 
	x = x + mem [ g + 1 ] .cint ; 
	o = mem [ g ] .hh.b0 ; 
	totalstretch [ o ] = totalstretch [ o ] + mem [ g + 2 ] .cint ; 
	o = mem [ g ] .hh.b1 ; 
	totalshrink [ o ] = totalshrink [ o ] + mem [ g + 3 ] .cint ; 
	if ( mem [ p ] .hh.b1 >= 100 ) 
	{
	  g = mem [ p + 1 ] .hh .v.RH ; 
	  if ( mem [ g + 1 ] .cint > w ) 
	  w = mem [ g + 1 ] .cint ; 
	} 
      } 
      break ; 
    case 11 : 
      {
	x = x + d + mem [ p + 1 ] .cint ; 
	d = 0 ; 
      } 
      break ; 
      default: 
      ; 
      break ; 
    } 
    p = mem [ p ] .hh .v.RH ; 
  } 
  mem [ r + 1 ] .cint = w ; 
  if ( d > l ) 
  {
    x = x + d - l ; 
    mem [ r + 2 ] .cint = l ; 
  } 
  else mem [ r + 2 ] .cint = d ; 
  if ( m == 1 ) 
  h = x + h ; 
  mem [ r + 3 ] .cint = h ; 
  x = h - x ; 
  if ( x == 0 ) 
  {
    mem [ r + 5 ] .hh.b0 = 0 ; 
    mem [ r + 5 ] .hh.b1 = 0 ; 
    mem [ r + 6 ] .gr = 0.0 ; 
    goto lab10 ; 
  } 
  else if ( x > 0 ) 
  {
    if ( totalstretch [ 3 ] != 0 ) 
    o = 3 ; 
    else if ( totalstretch [ 2 ] != 0 ) 
    o = 2 ; 
    else if ( totalstretch [ 1 ] != 0 ) 
    o = 1 ; 
    else o = 0 ; 
    mem [ r + 5 ] .hh.b1 = o ; 
    mem [ r + 5 ] .hh.b0 = 1 ; 
    if ( totalstretch [ o ] != 0 ) 
    mem [ r + 6 ] .gr = x / ((double) totalstretch [ o ] ) ; 
    else {
	
      mem [ r + 5 ] .hh.b0 = 0 ; 
      mem [ r + 6 ] .gr = 0.0 ; 
    } 
    if ( o == 0 ) 
    if ( mem [ r + 5 ] .hh .v.RH != 0 ) 
    {
      lastbadness = badness ( x , totalstretch [ 0 ] ) ; 
      if ( lastbadness > eqtb [ 9190 ] .cint ) 
      {
	println () ; 
	if ( lastbadness > 100 ) 
	printnl ( 838 ) ; 
	else printnl ( 839 ) ; 
	print ( 850 ) ; 
	printint ( lastbadness ) ; 
	goto lab50 ; 
      } 
    } 
    goto lab10 ; 
  } 
  else {
      
    if ( totalshrink [ 3 ] != 0 ) 
    o = 3 ; 
    else if ( totalshrink [ 2 ] != 0 ) 
    o = 2 ; 
    else if ( totalshrink [ 1 ] != 0 ) 
    o = 1 ; 
    else o = 0 ; 
    mem [ r + 5 ] .hh.b1 = o ; 
    mem [ r + 5 ] .hh.b0 = 2 ; 
    if ( totalshrink [ o ] != 0 ) 
    mem [ r + 6 ] .gr = ( - (integer) x ) / ((double) totalshrink [ o ] ) ; 
    else {
	
      mem [ r + 5 ] .hh.b0 = 0 ; 
      mem [ r + 6 ] .gr = 0.0 ; 
    } 
    if ( ( totalshrink [ o ] < - (integer) x ) && ( o == 0 ) && ( mem [ r + 5 
    ] .hh .v.RH != 0 ) ) 
    {
      lastbadness = 1000000L ; 
      mem [ r + 6 ] .gr = 1.0 ; 
      if ( ( - (integer) x - totalshrink [ 0 ] > eqtb [ 9739 ] .cint ) || ( 
      eqtb [ 9190 ] .cint < 100 ) ) 
      {
	println () ; 
	printnl ( 851 ) ; 
	printscaled ( - (integer) x - totalshrink [ 0 ] ) ; 
	print ( 852 ) ; 
	goto lab50 ; 
      } 
    } 
    else if ( o == 0 ) 
    if ( mem [ r + 5 ] .hh .v.RH != 0 ) 
    {
      lastbadness = badness ( - (integer) x , totalshrink [ 0 ] ) ; 
      if ( lastbadness > eqtb [ 9190 ] .cint ) 
      {
	println () ; 
	printnl ( 853 ) ; 
	printint ( lastbadness ) ; 
	goto lab50 ; 
      } 
    } 
    goto lab10 ; 
  } 
  lab50: if ( outputactive ) 
  print ( 841 ) ; 
  else {
      
    if ( packbeginline != 0 ) 
    {
      print ( 843 ) ; 
      printint ( abs ( packbeginline ) ) ; 
      print ( 844 ) ; 
    } 
    else print ( 845 ) ; 
    printint ( line ) ; 
    println () ; 
  } 
  begindiagnostic () ; 
  showbox ( r ) ; 
  enddiagnostic ( true ) ; 
  lab10: Result = r ; 
  return(Result) ; 
} 
void zappendtovlist ( b ) 
halfword b ; 
{appendtovlist_regmem 
  scaled d  ; 
  halfword p  ; 
  if ( curlist .auxfield .cint > -65536000L ) 
  {
    d = mem [ eqtb [ 6783 ] .hh .v.RH + 1 ] .cint - curlist .auxfield .cint - 
    mem [ b + 3 ] .cint ; 
    if ( d < eqtb [ 9732 ] .cint ) 
    p = newparamglue ( 0 ) ; 
    else {
	
      p = newskipparam ( 1 ) ; 
      mem [ tempptr + 1 ] .cint = d ; 
    } 
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    curlist .tailfield = p ; 
  } 
  mem [ curlist .tailfield ] .hh .v.RH = b ; 
  curlist .tailfield = b ; 
  curlist .auxfield .cint = mem [ b + 2 ] .cint ; 
} 
halfword newnoad ( ) 
{register halfword Result; newnoad_regmem 
  halfword p  ; 
  p = getnode ( 4 ) ; 
  mem [ p ] .hh.b0 = 16 ; 
  mem [ p ] .hh.b1 = 0 ; 
  mem [ p + 1 ] .hh = emptyfield ; 
  mem [ p + 3 ] .hh = emptyfield ; 
  mem [ p + 2 ] .hh = emptyfield ; 
  Result = p ; 
  return(Result) ; 
} 
halfword znewstyle ( s ) 
smallnumber s ; 
{register halfword Result; newstyle_regmem 
  halfword p  ; 
  p = getnode ( 3 ) ; 
  mem [ p ] .hh.b0 = 14 ; 
  mem [ p ] .hh.b1 = s ; 
  mem [ p + 1 ] .cint = 0 ; 
  mem [ p + 2 ] .cint = 0 ; 
  Result = p ; 
  return(Result) ; 
} 
halfword newchoice ( ) 
{register halfword Result; newchoice_regmem 
  halfword p  ; 
  p = getnode ( 3 ) ; 
  mem [ p ] .hh.b0 = 15 ; 
  mem [ p ] .hh.b1 = 0 ; 
  mem [ p + 1 ] .hh .v.LH = 0 ; 
  mem [ p + 1 ] .hh .v.RH = 0 ; 
  mem [ p + 2 ] .hh .v.LH = 0 ; 
  mem [ p + 2 ] .hh .v.RH = 0 ; 
  Result = p ; 
  return(Result) ; 
} 
void showinfo ( ) 
{showinfo_regmem 
  shownodelist ( mem [ tempptr ] .hh .v.LH ) ; 
} 
halfword zfractionrule ( t ) 
scaled t ; 
{register halfword Result; fractionrule_regmem 
  halfword p  ; 
  p = newrule () ; 
  mem [ p + 3 ] .cint = t ; 
  mem [ p + 2 ] .cint = 0 ; 
  Result = p ; 
  return(Result) ; 
} 
halfword zoverbar ( b , k , t ) 
halfword b ; 
scaled k ; 
scaled t ; 
{register halfword Result; overbar_regmem 
  halfword p, q  ; 
  p = newkern ( k ) ; 
  mem [ p ] .hh .v.RH = b ; 
  q = fractionrule ( t ) ; 
  mem [ q ] .hh .v.RH = p ; 
  p = newkern ( t ) ; 
  mem [ p ] .hh .v.RH = q ; 
  Result = vpackage ( p , 0 , 1 , 1073741823L ) ; 
  return(Result) ; 
} 
halfword zcharbox ( f , c ) 
internalfontnumber f ; 
quarterword c ; 
{register halfword Result; charbox_regmem 
  fourquarters q  ; 
  eightbits hd  ; 
  halfword b, p  ; 
  q = fontinfo [ charbase [ f ] + c ] .qqqq ; 
  hd = q .b1 ; 
  b = newnullbox () ; 
  mem [ b + 1 ] .cint = fontinfo [ widthbase [ f ] + q .b0 ] .cint + fontinfo 
  [ italicbase [ f ] + ( q .b2 ) / 4 ] .cint ; 
  mem [ b + 3 ] .cint = fontinfo [ heightbase [ f ] + ( hd ) / 16 ] .cint ; 
  mem [ b + 2 ] .cint = fontinfo [ depthbase [ f ] + ( hd ) % 16 ] .cint ; 
  p = getavail () ; 
  mem [ p ] .hh.b1 = c ; 
  mem [ p ] .hh.b0 = f ; 
  mem [ b + 5 ] .hh .v.RH = p ; 
  Result = b ; 
  return(Result) ; 
} 
void zstackintobox ( b , f , c ) 
halfword b ; 
internalfontnumber f ; 
quarterword c ; 
{stackintobox_regmem 
  halfword p  ; 
  p = charbox ( f , c ) ; 
  mem [ p ] .hh .v.RH = mem [ b + 5 ] .hh .v.RH ; 
  mem [ b + 5 ] .hh .v.RH = p ; 
  mem [ b + 3 ] .cint = mem [ p + 3 ] .cint ; 
} 
scaled zheightplusdepth ( f , c ) 
internalfontnumber f ; 
quarterword c ; 
{register scaled Result; heightplusdepth_regmem 
  fourquarters q  ; 
  eightbits hd  ; 
  q = fontinfo [ charbase [ f ] + c ] .qqqq ; 
  hd = q .b1 ; 
  Result = fontinfo [ heightbase [ f ] + ( hd ) / 16 ] .cint + fontinfo [ 
  depthbase [ f ] + ( hd ) % 16 ] .cint ; 
  return(Result) ; 
} 
halfword zvardelimiter ( d , s , v ) 
halfword d ; 
smallnumber s ; 
scaled v ; 
{/* 40 22 */ register halfword Result; vardelimiter_regmem 
  halfword b  ; 
  internalfontnumber f, g  ; 
  quarterword c, x, y  ; 
  integer m, n  ; 
  scaled u  ; 
  scaled w  ; 
  fourquarters q  ; 
  eightbits hd  ; 
  fourquarters r  ; 
  smallnumber z  ; 
  boolean largeattempt  ; 
  f = 0 ; 
  w = 0 ; 
  largeattempt = false ; 
  z = mem [ d ] .qqqq .b0 ; 
  x = mem [ d ] .qqqq .b1 ; 
  while ( true ) {
      
    if ( ( z != 0 ) || ( x != 0 ) ) 
    {
      z = z + s + 16 ; 
      do {
	  z = z - 16 ; 
	g = eqtb [ 7835 + z ] .hh .v.RH ; 
	if ( g != 0 ) 
	{
	  y = x ; 
	  if ( ( y >= fontbc [ g ] ) && ( y <= fontec [ g ] ) ) 
	  {
	    lab22: q = fontinfo [ charbase [ g ] + y ] .qqqq ; 
	    if ( ( q .b0 > 0 ) ) 
	    {
	      if ( ( ( q .b2 ) % 4 ) == 3 ) 
	      {
		f = g ; 
		c = y ; 
		goto lab40 ; 
	      } 
	      hd = q .b1 ; 
	      u = fontinfo [ heightbase [ g ] + ( hd ) / 16 ] .cint + fontinfo 
	      [ depthbase [ g ] + ( hd ) % 16 ] .cint ; 
	      if ( u > w ) 
	      {
		f = g ; 
		c = y ; 
		w = u ; 
		if ( u >= v ) 
		goto lab40 ; 
	      } 
	      if ( ( ( q .b2 ) % 4 ) == 2 ) 
	      {
		y = q .b3 ; 
		goto lab22 ; 
	      } 
	    } 
	  } 
	} 
      } while ( ! ( z < 16 ) ) ; 
    } 
    if ( largeattempt ) 
    goto lab40 ; 
    largeattempt = true ; 
    z = mem [ d ] .qqqq .b2 ; 
    x = mem [ d ] .qqqq .b3 ; 
  } 
  lab40: if ( f != 0 ) 
  if ( ( ( q .b2 ) % 4 ) == 3 ) 
  {
    b = newnullbox () ; 
    mem [ b ] .hh.b0 = 1 ; 
    r = fontinfo [ extenbase [ f ] + q .b3 ] .qqqq ; 
    c = r .b3 ; 
    u = heightplusdepth ( f , c ) ; 
    w = 0 ; 
    q = fontinfo [ charbase [ f ] + c ] .qqqq ; 
    mem [ b + 1 ] .cint = fontinfo [ widthbase [ f ] + q .b0 ] .cint + 
    fontinfo [ italicbase [ f ] + ( q .b2 ) / 4 ] .cint ; 
    c = r .b2 ; 
    if ( c != 0 ) 
    w = w + heightplusdepth ( f , c ) ; 
    c = r .b1 ; 
    if ( c != 0 ) 
    w = w + heightplusdepth ( f , c ) ; 
    c = r .b0 ; 
    if ( c != 0 ) 
    w = w + heightplusdepth ( f , c ) ; 
    n = 0 ; 
    if ( u > 0 ) 
    while ( w < v ) {
	
      w = w + u ; 
      incr ( n ) ; 
      if ( r .b1 != 0 ) 
      w = w + u ; 
    } 
    c = r .b2 ; 
    if ( c != 0 ) 
    stackintobox ( b , f , c ) ; 
    c = r .b3 ; 
    {register integer for_end; m = 1 ; for_end = n ; if ( m <= for_end) do 
      stackintobox ( b , f , c ) ; 
    while ( m++ < for_end ) ; } 
    c = r .b1 ; 
    if ( c != 0 ) 
    {
      stackintobox ( b , f , c ) ; 
      c = r .b3 ; 
      {register integer for_end; m = 1 ; for_end = n ; if ( m <= for_end) do 
	stackintobox ( b , f , c ) ; 
      while ( m++ < for_end ) ; } 
    } 
    c = r .b0 ; 
    if ( c != 0 ) 
    stackintobox ( b , f , c ) ; 
    mem [ b + 2 ] .cint = w - mem [ b + 3 ] .cint ; 
  } 
  else b = charbox ( f , c ) ; 
  else {
      
    b = newnullbox () ; 
    mem [ b + 1 ] .cint = eqtb [ 9741 ] .cint ; 
  } 
  mem [ b + 4 ] .cint = half ( mem [ b + 3 ] .cint - mem [ b + 2 ] .cint ) - 
  fontinfo [ 22 + parambase [ eqtb [ 7837 + s ] .hh .v.RH ] ] .cint ; 
  Result = b ; 
  return(Result) ; 
} 
halfword zrebox ( b , w ) 
halfword b ; 
scaled w ; 
{register halfword Result; rebox_regmem 
  halfword p  ; 
  internalfontnumber f  ; 
  scaled v  ; 
  if ( ( mem [ b + 1 ] .cint != w ) && ( mem [ b + 5 ] .hh .v.RH != 0 ) ) 
  {
    if ( mem [ b ] .hh.b0 == 1 ) 
    b = hpack ( b , 0 , 1 ) ; 
    p = mem [ b + 5 ] .hh .v.RH ; 
    if ( ( ( p >= himemmin ) ) && ( mem [ p ] .hh .v.RH == 0 ) ) 
    {
      f = mem [ p ] .hh.b0 ; 
      v = fontinfo [ widthbase [ f ] + fontinfo [ charbase [ f ] + mem [ p ] 
      .hh.b1 ] .qqqq .b0 ] .cint ; 
      if ( v != mem [ b + 1 ] .cint ) 
      mem [ p ] .hh .v.RH = newkern ( mem [ b + 1 ] .cint - v ) ; 
    } 
    freenode ( b , 7 ) ; 
    b = newglue ( 12 ) ; 
    mem [ b ] .hh .v.RH = p ; 
    while ( mem [ p ] .hh .v.RH != 0 ) p = mem [ p ] .hh .v.RH ; 
    mem [ p ] .hh .v.RH = newglue ( 12 ) ; 
    Result = hpack ( b , w , 0 ) ; 
  } 
  else {
      
    mem [ b + 1 ] .cint = w ; 
    Result = b ; 
  } 
  return(Result) ; 
} 
halfword zmathglue ( g , m ) 
halfword g ; 
scaled m ; 
{register halfword Result; mathglue_regmem 
  halfword p  ; 
  integer n  ; 
  scaled f  ; 
  n = xovern ( m , 65536L ) ; 
  f = texremainder ; 
  if ( f < 0 ) 
  {
    decr ( n ) ; 
    f = f + 65536L ; 
  } 
  p = getnode ( 4 ) ; 
  mem [ p + 1 ] .cint = multandadd ( n , mem [ g + 1 ] .cint , xnoverd ( mem [ 
  g + 1 ] .cint , f , 65536L ) , 1073741823L ) ; 
  mem [ p ] .hh.b0 = mem [ g ] .hh.b0 ; 
  if ( mem [ p ] .hh.b0 == 0 ) 
  mem [ p + 2 ] .cint = multandadd ( n , mem [ g + 2 ] .cint , xnoverd ( mem [ 
  g + 2 ] .cint , f , 65536L ) , 1073741823L ) ; 
  else mem [ p + 2 ] .cint = mem [ g + 2 ] .cint ; 
  mem [ p ] .hh.b1 = mem [ g ] .hh.b1 ; 
  if ( mem [ p ] .hh.b1 == 0 ) 
  mem [ p + 3 ] .cint = multandadd ( n , mem [ g + 3 ] .cint , xnoverd ( mem [ 
  g + 3 ] .cint , f , 65536L ) , 1073741823L ) ; 
  else mem [ p + 3 ] .cint = mem [ g + 3 ] .cint ; 
  Result = p ; 
  return(Result) ; 
} 
void zmathkern ( p , m ) 
halfword p ; 
scaled m ; 
{mathkern_regmem 
  integer n  ; 
  scaled f  ; 
  if ( mem [ p ] .hh.b1 == 99 ) 
  {
    n = xovern ( m , 65536L ) ; 
    f = texremainder ; 
    if ( f < 0 ) 
    {
      decr ( n ) ; 
      f = f + 65536L ; 
    } 
    mem [ p + 1 ] .cint = multandadd ( n , mem [ p + 1 ] .cint , xnoverd ( mem 
    [ p + 1 ] .cint , f , 65536L ) , 1073741823L ) ; 
    mem [ p ] .hh.b1 = 1 ; 
  } 
} 
void flushmath ( ) 
{flushmath_regmem 
  flushnodelist ( mem [ curlist .headfield ] .hh .v.RH ) ; 
  flushnodelist ( curlist .auxfield .cint ) ; 
  mem [ curlist .headfield ] .hh .v.RH = 0 ; 
  curlist .tailfield = curlist .headfield ; 
  curlist .auxfield .cint = 0 ; 
} 
halfword zcleanbox ( p , s ) 
halfword p ; 
smallnumber s ; 
{/* 40 */ register halfword Result; cleanbox_regmem 
  halfword q  ; 
  smallnumber savestyle  ; 
  halfword x  ; 
  halfword r  ; 
  switch ( mem [ p ] .hh .v.RH ) 
  {case 1 : 
    {
      curmlist = newnoad () ; 
      mem [ curmlist + 1 ] = mem [ p ] ; 
    } 
    break ; 
  case 2 : 
    {
      q = mem [ p ] .hh .v.LH ; 
      goto lab40 ; 
    } 
    break ; 
  case 3 : 
    curmlist = mem [ p ] .hh .v.LH ; 
    break ; 
    default: 
    {
      q = newnullbox () ; 
      goto lab40 ; 
    } 
    break ; 
  } 
  savestyle = curstyle ; 
  curstyle = s ; 
  mlistpenalties = false ; 
  mlisttohlist () ; 
  q = mem [ memtop - 3 ] .hh .v.RH ; 
  curstyle = savestyle ; 
  {
    if ( curstyle < 4 ) 
    cursize = 0 ; 
    else cursize = 16 * ( ( curstyle - 2 ) / 2 ) ; 
    curmu = xovern ( fontinfo [ 6 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint , 18 ) ; 
  } 
  lab40: if ( ( q >= himemmin ) || ( q == 0 ) ) 
  x = hpack ( q , 0 , 1 ) ; 
  else if ( ( mem [ q ] .hh .v.RH == 0 ) && ( mem [ q ] .hh.b0 <= 1 ) && ( mem 
  [ q + 4 ] .cint == 0 ) ) 
  x = q ; 
  else x = hpack ( q , 0 , 1 ) ; 
  q = mem [ x + 5 ] .hh .v.RH ; 
  if ( ( q >= himemmin ) ) 
  {
    r = mem [ q ] .hh .v.RH ; 
    if ( r != 0 ) 
    if ( mem [ r ] .hh .v.RH == 0 ) 
    if ( ! ( r >= himemmin ) ) 
    if ( mem [ r ] .hh.b0 == 11 ) 
    {
      freenode ( r , 2 ) ; 
      mem [ q ] .hh .v.RH = 0 ; 
    } 
  } 
  Result = x ; 
  return(Result) ; 
} 
void zfetch ( a ) 
halfword a ; 
{fetch_regmem 
  curc = mem [ a ] .hh.b1 ; 
  curf = eqtb [ 7835 + mem [ a ] .hh.b0 + cursize ] .hh .v.RH ; 
  if ( curf == 0 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 335 ) ; 
    } 
    printsize ( cursize ) ; 
    printchar ( 32 ) ; 
    printint ( mem [ a ] .hh.b0 ) ; 
    print ( 878 ) ; 
    print ( curc ) ; 
    printchar ( 41 ) ; 
    {
      helpptr = 4 ; 
      helpline [ 3 ] = 879 ; 
      helpline [ 2 ] = 880 ; 
      helpline [ 1 ] = 881 ; 
      helpline [ 0 ] = 882 ; 
    } 
    error () ; 
    curi = nullcharacter ; 
    mem [ a ] .hh .v.RH = 0 ; 
  } 
  else {
      
    if ( ( curc >= fontbc [ curf ] ) && ( curc <= fontec [ curf ] ) ) 
    curi = fontinfo [ charbase [ curf ] + curc ] .qqqq ; 
    else curi = nullcharacter ; 
    if ( ! ( ( curi .b0 > 0 ) ) ) 
    {
      charwarning ( curf , curc ) ; 
      mem [ a ] .hh .v.RH = 0 ; 
    } 
  } 
} 
void zmakeover ( q ) 
halfword q ; 
{makeover_regmem 
  mem [ q + 1 ] .hh .v.LH = overbar ( cleanbox ( q + 1 , 2 * ( curstyle / 2 ) 
  + 1 ) , 3 * fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] ] 
  .cint , fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] ] 
  .cint ) ; 
  mem [ q + 1 ] .hh .v.RH = 2 ; 
} 
void zmakeunder ( q ) 
halfword q ; 
{makeunder_regmem 
  halfword p, x, y  ; 
  scaled delta  ; 
  x = cleanbox ( q + 1 , curstyle ) ; 
  p = newkern ( 3 * fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh 
  .v.RH ] ] .cint ) ; 
  mem [ x ] .hh .v.RH = p ; 
  mem [ p ] .hh .v.RH = fractionrule ( fontinfo [ 8 + parambase [ eqtb [ 7838 
  + cursize ] .hh .v.RH ] ] .cint ) ; 
  y = vpackage ( x , 0 , 1 , 1073741823L ) ; 
  delta = mem [ y + 3 ] .cint + mem [ y + 2 ] .cint + fontinfo [ 8 + parambase 
  [ eqtb [ 7838 + cursize ] .hh .v.RH ] ] .cint ; 
  mem [ y + 3 ] .cint = mem [ x + 3 ] .cint ; 
  mem [ y + 2 ] .cint = delta - mem [ y + 3 ] .cint ; 
  mem [ q + 1 ] .hh .v.LH = y ; 
  mem [ q + 1 ] .hh .v.RH = 2 ; 
} 
void zmakevcenter ( q ) 
halfword q ; 
{makevcenter_regmem 
  halfword v  ; 
  scaled delta  ; 
  v = mem [ q + 1 ] .hh .v.LH ; 
  if ( mem [ v ] .hh.b0 != 1 ) 
  confusion ( 536 ) ; 
  delta = mem [ v + 3 ] .cint + mem [ v + 2 ] .cint ; 
  mem [ v + 3 ] .cint = fontinfo [ 22 + parambase [ eqtb [ 7837 + cursize ] 
  .hh .v.RH ] ] .cint + half ( delta ) ; 
  mem [ v + 2 ] .cint = delta - mem [ v + 3 ] .cint ; 
} 
void zmakeradical ( q ) 
halfword q ; 
{makeradical_regmem 
  halfword x, y  ; 
  scaled delta, clr  ; 
  x = cleanbox ( q + 1 , 2 * ( curstyle / 2 ) + 1 ) ; 
  if ( curstyle < 2 ) 
  clr = fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] ] .cint 
  + ( abs ( fontinfo [ 5 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] 
  .cint ) / 4 ) ; 
  else {
      
    clr = fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] ] 
    .cint ; 
    clr = clr + ( abs ( clr ) / 4 ) ; 
  } 
  y = vardelimiter ( q + 4 , cursize , mem [ x + 3 ] .cint + mem [ x + 2 ] 
  .cint + clr + fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] 
  ] .cint ) ; 
  delta = mem [ y + 2 ] .cint - ( mem [ x + 3 ] .cint + mem [ x + 2 ] .cint + 
  clr ) ; 
  if ( delta > 0 ) 
  clr = clr + half ( delta ) ; 
  mem [ y + 4 ] .cint = - (integer) ( mem [ x + 3 ] .cint + clr ) ; 
  mem [ y ] .hh .v.RH = overbar ( x , clr , mem [ y + 3 ] .cint ) ; 
  mem [ q + 1 ] .hh .v.LH = hpack ( y , 0 , 1 ) ; 
  mem [ q + 1 ] .hh .v.RH = 2 ; 
} 
void zmakemathaccent ( q ) 
halfword q ; 
{/* 30 31 */ makemathaccent_regmem 
  halfword p, x, y  ; 
  integer a  ; 
  quarterword c  ; 
  internalfontnumber f  ; 
  fourquarters i  ; 
  scaled s  ; 
  scaled h  ; 
  scaled delta  ; 
  scaled w  ; 
  fetch ( q + 4 ) ; 
  if ( ( curi .b0 > 0 ) ) 
  {
    i = curi ; 
    c = curc ; 
    f = curf ; 
    s = 0 ; 
    if ( mem [ q + 1 ] .hh .v.RH == 1 ) 
    {
      fetch ( q + 1 ) ; 
      if ( ( ( curi .b2 ) % 4 ) == 1 ) 
      {
	a = ligkernbase [ curf ] + curi .b3 ; 
	curi = fontinfo [ a ] .qqqq ; 
	if ( curi .b0 > 128 ) 
	{
	  a = ligkernbase [ curf ] + 256 * curi .b2 + curi .b3 + 32768L - 256 
	  * ( 128 ) ; 
	  curi = fontinfo [ a ] .qqqq ; 
	} 
	while ( true ) {
	    
	  if ( curi .b1 == skewchar [ curf ] ) 
	  {
	    if ( curi .b2 >= 128 ) 
	    if ( curi .b0 <= 128 ) 
	    s = fontinfo [ kernbase [ curf ] + 256 * curi .b2 + curi .b3 ] 
	    .cint ; 
	    goto lab31 ; 
	  } 
	  if ( curi .b0 >= 128 ) 
	  goto lab31 ; 
	  a = a + curi .b0 + 1 ; 
	  curi = fontinfo [ a ] .qqqq ; 
	} 
      } 
    } 
    lab31: ; 
    x = cleanbox ( q + 1 , 2 * ( curstyle / 2 ) + 1 ) ; 
    w = mem [ x + 1 ] .cint ; 
    h = mem [ x + 3 ] .cint ; 
    while ( true ) {
	
      if ( ( ( i .b2 ) % 4 ) != 2 ) 
      goto lab30 ; 
      y = i .b3 ; 
      i = fontinfo [ charbase [ f ] + y ] .qqqq ; 
      if ( ! ( i .b0 > 0 ) ) 
      goto lab30 ; 
      if ( fontinfo [ widthbase [ f ] + i .b0 ] .cint > w ) 
      goto lab30 ; 
      c = y ; 
    } 
    lab30: ; 
    if ( h < fontinfo [ 5 + parambase [ f ] ] .cint ) 
    delta = h ; 
    else delta = fontinfo [ 5 + parambase [ f ] ] .cint ; 
    if ( ( mem [ q + 2 ] .hh .v.RH != 0 ) || ( mem [ q + 3 ] .hh .v.RH != 0 ) 
    ) 
    if ( mem [ q + 1 ] .hh .v.RH == 1 ) 
    {
      flushnodelist ( x ) ; 
      x = newnoad () ; 
      mem [ x + 1 ] = mem [ q + 1 ] ; 
      mem [ x + 2 ] = mem [ q + 2 ] ; 
      mem [ x + 3 ] = mem [ q + 3 ] ; 
      mem [ q + 2 ] .hh = emptyfield ; 
      mem [ q + 3 ] .hh = emptyfield ; 
      mem [ q + 1 ] .hh .v.RH = 3 ; 
      mem [ q + 1 ] .hh .v.LH = x ; 
      x = cleanbox ( q + 1 , curstyle ) ; 
      delta = delta + mem [ x + 3 ] .cint - h ; 
      h = mem [ x + 3 ] .cint ; 
    } 
    y = charbox ( f , c ) ; 
    mem [ y + 4 ] .cint = s + half ( w - mem [ y + 1 ] .cint ) ; 
    mem [ y + 1 ] .cint = 0 ; 
    p = newkern ( - (integer) delta ) ; 
    mem [ p ] .hh .v.RH = x ; 
    mem [ y ] .hh .v.RH = p ; 
    y = vpackage ( y , 0 , 1 , 1073741823L ) ; 
    mem [ y + 1 ] .cint = mem [ x + 1 ] .cint ; 
    if ( mem [ y + 3 ] .cint < h ) 
    {
      p = newkern ( h - mem [ y + 3 ] .cint ) ; 
      mem [ p ] .hh .v.RH = mem [ y + 5 ] .hh .v.RH ; 
      mem [ y + 5 ] .hh .v.RH = p ; 
      mem [ y + 3 ] .cint = h ; 
    } 
    mem [ q + 1 ] .hh .v.LH = y ; 
    mem [ q + 1 ] .hh .v.RH = 2 ; 
  } 
} 
void zmakefraction ( q ) 
halfword q ; 
{makefraction_regmem 
  halfword p, v, x, y, z  ; 
  scaled delta, delta1, delta2, shiftup, shiftdown, clr  ; 
  if ( mem [ q + 1 ] .cint == 1073741824L ) 
  mem [ q + 1 ] .cint = fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh 
  .v.RH ] ] .cint ; 
  x = cleanbox ( q + 2 , curstyle + 2 - 2 * ( curstyle / 6 ) ) ; 
  z = cleanbox ( q + 3 , 2 * ( curstyle / 2 ) + 3 - 2 * ( curstyle / 6 ) ) ; 
  if ( mem [ x + 1 ] .cint < mem [ z + 1 ] .cint ) 
  x = rebox ( x , mem [ z + 1 ] .cint ) ; 
  else z = rebox ( z , mem [ x + 1 ] .cint ) ; 
  if ( curstyle < 2 ) 
  {
    shiftup = fontinfo [ 8 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] 
    .cint ; 
    shiftdown = fontinfo [ 11 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH 
    ] ] .cint ; 
  } 
  else {
      
    shiftdown = fontinfo [ 12 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH 
    ] ] .cint ; 
    if ( mem [ q + 1 ] .cint != 0 ) 
    shiftup = fontinfo [ 9 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] 
    .cint ; 
    else shiftup = fontinfo [ 10 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint ; 
  } 
  if ( mem [ q + 1 ] .cint == 0 ) 
  {
    if ( curstyle < 2 ) 
    clr = 7 * fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] ] 
    .cint ; 
    else clr = 3 * fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh 
    .v.RH ] ] .cint ; 
    delta = half ( clr - ( ( shiftup - mem [ x + 2 ] .cint ) - ( mem [ z + 3 ] 
    .cint - shiftdown ) ) ) ; 
    if ( delta > 0 ) 
    {
      shiftup = shiftup + delta ; 
      shiftdown = shiftdown + delta ; 
    } 
  } 
  else {
      
    if ( curstyle < 2 ) 
    clr = 3 * mem [ q + 1 ] .cint ; 
    else clr = mem [ q + 1 ] .cint ; 
    delta = half ( mem [ q + 1 ] .cint ) ; 
    delta1 = clr - ( ( shiftup - mem [ x + 2 ] .cint ) - ( fontinfo [ 22 + 
    parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] .cint + delta ) ) ; 
    delta2 = clr - ( ( fontinfo [ 22 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint - delta ) - ( mem [ z + 3 ] .cint - shiftdown ) ) ; 
    if ( delta1 > 0 ) 
    shiftup = shiftup + delta1 ; 
    if ( delta2 > 0 ) 
    shiftdown = shiftdown + delta2 ; 
  } 
  v = newnullbox () ; 
  mem [ v ] .hh.b0 = 1 ; 
  mem [ v + 3 ] .cint = shiftup + mem [ x + 3 ] .cint ; 
  mem [ v + 2 ] .cint = mem [ z + 2 ] .cint + shiftdown ; 
  mem [ v + 1 ] .cint = mem [ x + 1 ] .cint ; 
  if ( mem [ q + 1 ] .cint == 0 ) 
  {
    p = newkern ( ( shiftup - mem [ x + 2 ] .cint ) - ( mem [ z + 3 ] .cint - 
    shiftdown ) ) ; 
    mem [ p ] .hh .v.RH = z ; 
  } 
  else {
      
    y = fractionrule ( mem [ q + 1 ] .cint ) ; 
    p = newkern ( ( fontinfo [ 22 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint - delta ) - ( mem [ z + 3 ] .cint - shiftdown ) ) ; 
    mem [ y ] .hh .v.RH = p ; 
    mem [ p ] .hh .v.RH = z ; 
    p = newkern ( ( shiftup - mem [ x + 2 ] .cint ) - ( fontinfo [ 22 + 
    parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] .cint + delta ) ) ; 
    mem [ p ] .hh .v.RH = y ; 
  } 
  mem [ x ] .hh .v.RH = p ; 
  mem [ v + 5 ] .hh .v.RH = x ; 
  if ( curstyle < 2 ) 
  delta = fontinfo [ 20 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] 
  .cint ; 
  else delta = fontinfo [ 21 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] 
  ] .cint ; 
  x = vardelimiter ( q + 4 , cursize , delta ) ; 
  mem [ x ] .hh .v.RH = v ; 
  z = vardelimiter ( q + 5 , cursize , delta ) ; 
  mem [ v ] .hh .v.RH = z ; 
  mem [ q + 1 ] .cint = hpack ( x , 0 , 1 ) ; 
} 
scaled zmakeop ( q ) 
halfword q ; 
{register scaled Result; makeop_regmem 
  scaled delta  ; 
  halfword p, v, x, y, z  ; 
  quarterword c  ; 
  fourquarters i  ; 
  scaled shiftup, shiftdown  ; 
  if ( ( mem [ q ] .hh.b1 == 0 ) && ( curstyle < 2 ) ) 
  mem [ q ] .hh.b1 = 1 ; 
  if ( mem [ q + 1 ] .hh .v.RH == 1 ) 
  {
    fetch ( q + 1 ) ; 
    if ( ( curstyle < 2 ) && ( ( ( curi .b2 ) % 4 ) == 2 ) ) 
    {
      c = curi .b3 ; 
      i = fontinfo [ charbase [ curf ] + c ] .qqqq ; 
      if ( ( i .b0 > 0 ) ) 
      {
	curc = c ; 
	curi = i ; 
	mem [ q + 1 ] .hh.b1 = c ; 
      } 
    } 
    delta = fontinfo [ italicbase [ curf ] + ( curi .b2 ) / 4 ] .cint ; 
    x = cleanbox ( q + 1 , curstyle ) ; 
    if ( ( mem [ q + 3 ] .hh .v.RH != 0 ) && ( mem [ q ] .hh.b1 != 1 ) ) 
    mem [ x + 1 ] .cint = mem [ x + 1 ] .cint - delta ; 
    mem [ x + 4 ] .cint = half ( mem [ x + 3 ] .cint - mem [ x + 2 ] .cint ) - 
    fontinfo [ 22 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] .cint ; 
    mem [ q + 1 ] .hh .v.RH = 2 ; 
    mem [ q + 1 ] .hh .v.LH = x ; 
  } 
  else delta = 0 ; 
  if ( mem [ q ] .hh.b1 == 1 ) 
  {
    x = cleanbox ( q + 2 , 2 * ( curstyle / 4 ) + 4 + ( curstyle % 2 ) ) ; 
    y = cleanbox ( q + 1 , curstyle ) ; 
    z = cleanbox ( q + 3 , 2 * ( curstyle / 4 ) + 5 ) ; 
    v = newnullbox () ; 
    mem [ v ] .hh.b0 = 1 ; 
    mem [ v + 1 ] .cint = mem [ y + 1 ] .cint ; 
    if ( mem [ x + 1 ] .cint > mem [ v + 1 ] .cint ) 
    mem [ v + 1 ] .cint = mem [ x + 1 ] .cint ; 
    if ( mem [ z + 1 ] .cint > mem [ v + 1 ] .cint ) 
    mem [ v + 1 ] .cint = mem [ z + 1 ] .cint ; 
    x = rebox ( x , mem [ v + 1 ] .cint ) ; 
    y = rebox ( y , mem [ v + 1 ] .cint ) ; 
    z = rebox ( z , mem [ v + 1 ] .cint ) ; 
    mem [ x + 4 ] .cint = half ( delta ) ; 
    mem [ z + 4 ] .cint = - (integer) mem [ x + 4 ] .cint ; 
    mem [ v + 3 ] .cint = mem [ y + 3 ] .cint ; 
    mem [ v + 2 ] .cint = mem [ y + 2 ] .cint ; 
    if ( mem [ q + 2 ] .hh .v.RH == 0 ) 
    {
      freenode ( x , 7 ) ; 
      mem [ v + 5 ] .hh .v.RH = y ; 
    } 
    else {
	
      shiftup = fontinfo [ 11 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH 
      ] ] .cint - mem [ x + 2 ] .cint ; 
      if ( shiftup < fontinfo [ 9 + parambase [ eqtb [ 7838 + cursize ] .hh 
      .v.RH ] ] .cint ) 
      shiftup = fontinfo [ 9 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] 
      ] .cint ; 
      p = newkern ( shiftup ) ; 
      mem [ p ] .hh .v.RH = y ; 
      mem [ x ] .hh .v.RH = p ; 
      p = newkern ( fontinfo [ 13 + parambase [ eqtb [ 7838 + cursize ] .hh 
      .v.RH ] ] .cint ) ; 
      mem [ p ] .hh .v.RH = x ; 
      mem [ v + 5 ] .hh .v.RH = p ; 
      mem [ v + 3 ] .cint = mem [ v + 3 ] .cint + fontinfo [ 13 + parambase [ 
      eqtb [ 7838 + cursize ] .hh .v.RH ] ] .cint + mem [ x + 3 ] .cint + mem 
      [ x + 2 ] .cint + shiftup ; 
    } 
    if ( mem [ q + 3 ] .hh .v.RH == 0 ) 
    freenode ( z , 7 ) ; 
    else {
	
      shiftdown = fontinfo [ 12 + parambase [ eqtb [ 7838 + cursize ] .hh 
      .v.RH ] ] .cint - mem [ z + 3 ] .cint ; 
      if ( shiftdown < fontinfo [ 10 + parambase [ eqtb [ 7838 + cursize ] .hh 
      .v.RH ] ] .cint ) 
      shiftdown = fontinfo [ 10 + parambase [ eqtb [ 7838 + cursize ] .hh 
      .v.RH ] ] .cint ; 
      p = newkern ( shiftdown ) ; 
      mem [ y ] .hh .v.RH = p ; 
      mem [ p ] .hh .v.RH = z ; 
      p = newkern ( fontinfo [ 13 + parambase [ eqtb [ 7838 + cursize ] .hh 
      .v.RH ] ] .cint ) ; 
      mem [ z ] .hh .v.RH = p ; 
      mem [ v + 2 ] .cint = mem [ v + 2 ] .cint + fontinfo [ 13 + parambase [ 
      eqtb [ 7838 + cursize ] .hh .v.RH ] ] .cint + mem [ z + 3 ] .cint + mem 
      [ z + 2 ] .cint + shiftdown ; 
    } 
    mem [ q + 1 ] .cint = v ; 
  } 
  Result = delta ; 
  return(Result) ; 
} 
void zmakeord ( q ) 
halfword q ; 
{/* 20 10 */ makeord_regmem 
  integer a  ; 
  halfword p, r  ; 
  lab20: if ( mem [ q + 3 ] .hh .v.RH == 0 ) 
  if ( mem [ q + 2 ] .hh .v.RH == 0 ) 
  if ( mem [ q + 1 ] .hh .v.RH == 1 ) 
  {
    p = mem [ q ] .hh .v.RH ; 
    if ( p != 0 ) 
    if ( ( mem [ p ] .hh.b0 >= 16 ) && ( mem [ p ] .hh.b0 <= 22 ) ) 
    if ( mem [ p + 1 ] .hh .v.RH == 1 ) 
    if ( mem [ p + 1 ] .hh.b0 == mem [ q + 1 ] .hh.b0 ) 
    {
      mem [ q + 1 ] .hh .v.RH = 4 ; 
      fetch ( q + 1 ) ; 
      if ( ( ( curi .b2 ) % 4 ) == 1 ) 
      {
	a = ligkernbase [ curf ] + curi .b3 ; 
	curc = mem [ p + 1 ] .hh.b1 ; 
	curi = fontinfo [ a ] .qqqq ; 
	if ( curi .b0 > 128 ) 
	{
	  a = ligkernbase [ curf ] + 256 * curi .b2 + curi .b3 + 32768L - 256 
	  * ( 128 ) ; 
	  curi = fontinfo [ a ] .qqqq ; 
	} 
	while ( true ) {
	    
	  if ( curi .b1 == curc ) 
	  if ( curi .b0 <= 128 ) 
	  if ( curi .b2 >= 128 ) 
	  {
	    p = newkern ( fontinfo [ kernbase [ curf ] + 256 * curi .b2 + curi 
	    .b3 ] .cint ) ; 
	    mem [ p ] .hh .v.RH = mem [ q ] .hh .v.RH ; 
	    mem [ q ] .hh .v.RH = p ; 
	    return ; 
	  } 
	  else {
	      
	    {
	      if ( interrupt != 0 ) 
	      pauseforinstructions () ; 
	    } 
	    switch ( curi .b2 ) 
	    {case 1 : 
	    case 5 : 
	      mem [ q + 1 ] .hh.b1 = curi .b3 ; 
	      break ; 
	    case 2 : 
	    case 6 : 
	      mem [ p + 1 ] .hh.b1 = curi .b3 ; 
	      break ; 
	    case 3 : 
	    case 7 : 
	    case 11 : 
	      {
		r = newnoad () ; 
		mem [ r + 1 ] .hh.b1 = curi .b3 ; 
		mem [ r + 1 ] .hh.b0 = mem [ q + 1 ] .hh.b0 ; 
		mem [ q ] .hh .v.RH = r ; 
		mem [ r ] .hh .v.RH = p ; 
		if ( curi .b2 < 11 ) 
		mem [ r + 1 ] .hh .v.RH = 1 ; 
		else mem [ r + 1 ] .hh .v.RH = 4 ; 
	      } 
	      break ; 
	      default: 
	      {
		mem [ q ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
		mem [ q + 1 ] .hh.b1 = curi .b3 ; 
		mem [ q + 3 ] = mem [ p + 3 ] ; 
		mem [ q + 2 ] = mem [ p + 2 ] ; 
		freenode ( p , 4 ) ; 
	      } 
	      break ; 
	    } 
	    if ( curi .b2 > 3 ) 
	    return ; 
	    mem [ q + 1 ] .hh .v.RH = 1 ; 
	    goto lab20 ; 
	  } 
	  if ( curi .b0 >= 128 ) 
	  return ; 
	  a = a + curi .b0 + 1 ; 
	  curi = fontinfo [ a ] .qqqq ; 
	} 
      } 
    } 
  } 
} 
void zmakescripts ( q , delta ) 
halfword q ; 
scaled delta ; 
{makescripts_regmem 
  halfword p, x, y, z  ; 
  scaled shiftup, shiftdown, clr  ; 
  smallnumber t  ; 
  p = mem [ q + 1 ] .cint ; 
  if ( ( p >= himemmin ) ) 
  {
    shiftup = 0 ; 
    shiftdown = 0 ; 
  } 
  else {
      
    z = hpack ( p , 0 , 1 ) ; 
    if ( curstyle < 4 ) 
    t = 16 ; 
    else t = 32 ; 
    shiftup = mem [ z + 3 ] .cint - fontinfo [ 18 + parambase [ eqtb [ 7837 + 
    t ] .hh .v.RH ] ] .cint ; 
    shiftdown = mem [ z + 2 ] .cint + fontinfo [ 19 + parambase [ eqtb [ 7837 
    + t ] .hh .v.RH ] ] .cint ; 
    freenode ( z , 7 ) ; 
  } 
  if ( mem [ q + 2 ] .hh .v.RH == 0 ) 
  {
    x = cleanbox ( q + 3 , 2 * ( curstyle / 4 ) + 5 ) ; 
    mem [ x + 1 ] .cint = mem [ x + 1 ] .cint + eqtb [ 9742 ] .cint ; 
    if ( shiftdown < fontinfo [ 16 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint ) 
    shiftdown = fontinfo [ 16 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH 
    ] ] .cint ; 
    clr = mem [ x + 3 ] .cint - ( abs ( fontinfo [ 5 + parambase [ eqtb [ 7837 
    + cursize ] .hh .v.RH ] ] .cint * 4 ) / 5 ) ; 
    if ( shiftdown < clr ) 
    shiftdown = clr ; 
    mem [ x + 4 ] .cint = shiftdown ; 
  } 
  else {
      
    {
      x = cleanbox ( q + 2 , 2 * ( curstyle / 4 ) + 4 + ( curstyle % 2 ) ) ; 
      mem [ x + 1 ] .cint = mem [ x + 1 ] .cint + eqtb [ 9742 ] .cint ; 
      if ( odd ( curstyle ) ) 
      clr = fontinfo [ 15 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] 
      .cint ; 
      else if ( curstyle < 2 ) 
      clr = fontinfo [ 13 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH ] ] 
      .cint ; 
      else clr = fontinfo [ 14 + parambase [ eqtb [ 7837 + cursize ] .hh .v.RH 
      ] ] .cint ; 
      if ( shiftup < clr ) 
      shiftup = clr ; 
      clr = mem [ x + 2 ] .cint + ( abs ( fontinfo [ 5 + parambase [ eqtb [ 
      7837 + cursize ] .hh .v.RH ] ] .cint ) / 4 ) ; 
      if ( shiftup < clr ) 
      shiftup = clr ; 
    } 
    if ( mem [ q + 3 ] .hh .v.RH == 0 ) 
    mem [ x + 4 ] .cint = - (integer) shiftup ; 
    else {
	
      y = cleanbox ( q + 3 , 2 * ( curstyle / 4 ) + 5 ) ; 
      mem [ y + 1 ] .cint = mem [ y + 1 ] .cint + eqtb [ 9742 ] .cint ; 
      if ( shiftdown < fontinfo [ 17 + parambase [ eqtb [ 7837 + cursize ] .hh 
      .v.RH ] ] .cint ) 
      shiftdown = fontinfo [ 17 + parambase [ eqtb [ 7837 + cursize ] .hh 
      .v.RH ] ] .cint ; 
      clr = 4 * fontinfo [ 8 + parambase [ eqtb [ 7838 + cursize ] .hh .v.RH ] 
      ] .cint - ( ( shiftup - mem [ x + 2 ] .cint ) - ( mem [ y + 3 ] .cint - 
      shiftdown ) ) ; 
      if ( clr > 0 ) 
      {
	shiftdown = shiftdown + clr ; 
	clr = ( abs ( fontinfo [ 5 + parambase [ eqtb [ 7837 + cursize ] .hh 
	.v.RH ] ] .cint * 4 ) / 5 ) - ( shiftup - mem [ x + 2 ] .cint ) ; 
	if ( clr > 0 ) 
	{
	  shiftup = shiftup + clr ; 
	  shiftdown = shiftdown - clr ; 
	} 
      } 
      mem [ x + 4 ] .cint = delta ; 
      p = newkern ( ( shiftup - mem [ x + 2 ] .cint ) - ( mem [ y + 3 ] .cint 
      - shiftdown ) ) ; 
      mem [ x ] .hh .v.RH = p ; 
      mem [ p ] .hh .v.RH = y ; 
      x = vpackage ( x , 0 , 1 , 1073741823L ) ; 
      mem [ x + 4 ] .cint = shiftdown ; 
    } 
  } 
  if ( mem [ q + 1 ] .cint == 0 ) 
  mem [ q + 1 ] .cint = x ; 
  else {
      
    p = mem [ q + 1 ] .cint ; 
    while ( mem [ p ] .hh .v.RH != 0 ) p = mem [ p ] .hh .v.RH ; 
    mem [ p ] .hh .v.RH = x ; 
  } 
} 
smallnumber zmakeleftright ( q , style , maxd , maxh ) 
halfword q ; 
smallnumber style ; 
scaled maxd ; 
scaled maxh ; 
{register smallnumber Result; makeleftright_regmem 
  scaled delta, delta1, delta2  ; 
  if ( style < 4 ) 
  cursize = 0 ; 
  else cursize = 16 * ( ( style - 2 ) / 2 ) ; 
  delta2 = maxd + fontinfo [ 22 + parambase [ eqtb [ 7837 + cursize ] .hh 
  .v.RH ] ] .cint ; 
  delta1 = maxh + maxd - delta2 ; 
  if ( delta2 > delta1 ) 
  delta1 = delta2 ; 
  delta = ( delta1 / 500 ) * eqtb [ 9181 ] .cint ; 
  delta2 = delta1 + delta1 - eqtb [ 9740 ] .cint ; 
  if ( delta < delta2 ) 
  delta = delta2 ; 
  mem [ q + 1 ] .cint = vardelimiter ( q + 1 , cursize , delta ) ; 
  Result = mem [ q ] .hh.b0 - ( 10 ) ; 
  return(Result) ; 
} 
void mlisttohlist ( ) 
{/* 21 82 80 81 83 30 */ mlisttohlist_regmem 
  halfword mlist  ; 
  boolean penalties  ; 
  smallnumber style  ; 
  smallnumber savestyle  ; 
  halfword q  ; 
  halfword r  ; 
  smallnumber rtype  ; 
  smallnumber t  ; 
  halfword p, x, y, z  ; 
  integer pen  ; 
  smallnumber s  ; 
  scaled maxh, maxd  ; 
  scaled delta  ; 
  mlist = curmlist ; 
  penalties = mlistpenalties ; 
  style = curstyle ; 
  q = mlist ; 
  r = 0 ; 
  rtype = 17 ; 
  maxh = 0 ; 
  maxd = 0 ; 
  {
    if ( curstyle < 4 ) 
    cursize = 0 ; 
    else cursize = 16 * ( ( curstyle - 2 ) / 2 ) ; 
    curmu = xovern ( fontinfo [ 6 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint , 18 ) ; 
  } 
  while ( q != 0 ) {
      
    lab21: delta = 0 ; 
    switch ( mem [ q ] .hh.b0 ) 
    {case 18 : 
      switch ( rtype ) 
      {case 18 : 
      case 17 : 
      case 19 : 
      case 20 : 
      case 22 : 
      case 30 : 
	{
	  mem [ q ] .hh.b0 = 16 ; 
	  goto lab21 ; 
	} 
	break ; 
	default: 
	; 
	break ; 
      } 
      break ; 
    case 19 : 
    case 21 : 
    case 22 : 
    case 31 : 
      {
	if ( rtype == 18 ) 
	mem [ r ] .hh.b0 = 16 ; 
	if ( mem [ q ] .hh.b0 == 31 ) 
	goto lab80 ; 
      } 
      break ; 
    case 30 : 
      goto lab80 ; 
      break ; 
    case 25 : 
      {
	makefraction ( q ) ; 
	goto lab82 ; 
      } 
      break ; 
    case 17 : 
      {
	delta = makeop ( q ) ; 
	if ( mem [ q ] .hh.b1 == 1 ) 
	goto lab82 ; 
      } 
      break ; 
    case 16 : 
      makeord ( q ) ; 
      break ; 
    case 20 : 
    case 23 : 
      ; 
      break ; 
    case 24 : 
      makeradical ( q ) ; 
      break ; 
    case 27 : 
      makeover ( q ) ; 
      break ; 
    case 26 : 
      makeunder ( q ) ; 
      break ; 
    case 28 : 
      makemathaccent ( q ) ; 
      break ; 
    case 29 : 
      makevcenter ( q ) ; 
      break ; 
    case 14 : 
      {
	curstyle = mem [ q ] .hh.b1 ; 
	{
	  if ( curstyle < 4 ) 
	  cursize = 0 ; 
	  else cursize = 16 * ( ( curstyle - 2 ) / 2 ) ; 
	  curmu = xovern ( fontinfo [ 6 + parambase [ eqtb [ 7837 + cursize ] 
	  .hh .v.RH ] ] .cint , 18 ) ; 
	} 
	goto lab81 ; 
      } 
      break ; 
    case 15 : 
      {
	switch ( curstyle / 2 ) 
	{case 0 : 
	  {
	    p = mem [ q + 1 ] .hh .v.LH ; 
	    mem [ q + 1 ] .hh .v.LH = 0 ; 
	  } 
	  break ; 
	case 1 : 
	  {
	    p = mem [ q + 1 ] .hh .v.RH ; 
	    mem [ q + 1 ] .hh .v.RH = 0 ; 
	  } 
	  break ; 
	case 2 : 
	  {
	    p = mem [ q + 2 ] .hh .v.LH ; 
	    mem [ q + 2 ] .hh .v.LH = 0 ; 
	  } 
	  break ; 
	case 3 : 
	  {
	    p = mem [ q + 2 ] .hh .v.RH ; 
	    mem [ q + 2 ] .hh .v.RH = 0 ; 
	  } 
	  break ; 
	} 
	flushnodelist ( mem [ q + 1 ] .hh .v.LH ) ; 
	flushnodelist ( mem [ q + 1 ] .hh .v.RH ) ; 
	flushnodelist ( mem [ q + 2 ] .hh .v.LH ) ; 
	flushnodelist ( mem [ q + 2 ] .hh .v.RH ) ; 
	mem [ q ] .hh.b0 = 14 ; 
	mem [ q ] .hh.b1 = curstyle ; 
	mem [ q + 1 ] .cint = 0 ; 
	mem [ q + 2 ] .cint = 0 ; 
	if ( p != 0 ) 
	{
	  z = mem [ q ] .hh .v.RH ; 
	  mem [ q ] .hh .v.RH = p ; 
	  while ( mem [ p ] .hh .v.RH != 0 ) p = mem [ p ] .hh .v.RH ; 
	  mem [ p ] .hh .v.RH = z ; 
	} 
	goto lab81 ; 
      } 
      break ; 
    case 3 : 
    case 4 : 
    case 5 : 
    case 8 : 
    case 12 : 
    case 7 : 
      goto lab81 ; 
      break ; 
    case 2 : 
      {
	if ( mem [ q + 3 ] .cint > maxh ) 
	maxh = mem [ q + 3 ] .cint ; 
	if ( mem [ q + 2 ] .cint > maxd ) 
	maxd = mem [ q + 2 ] .cint ; 
	goto lab81 ; 
      } 
      break ; 
    case 10 : 
      {
	if ( mem [ q ] .hh.b1 == 99 ) 
	{
	  x = mem [ q + 1 ] .hh .v.LH ; 
	  y = mathglue ( x , curmu ) ; 
	  deleteglueref ( x ) ; 
	  mem [ q + 1 ] .hh .v.LH = y ; 
	  mem [ q ] .hh.b1 = 0 ; 
	} 
	else if ( ( cursize != 0 ) && ( mem [ q ] .hh.b1 == 98 ) ) 
	{
	  p = mem [ q ] .hh .v.RH ; 
	  if ( p != 0 ) 
	  if ( ( mem [ p ] .hh.b0 == 10 ) || ( mem [ p ] .hh.b0 == 11 ) ) 
	  {
	    mem [ q ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
	    mem [ p ] .hh .v.RH = 0 ; 
	    flushnodelist ( p ) ; 
	  } 
	} 
	goto lab81 ; 
      } 
      break ; 
    case 11 : 
      {
	mathkern ( q , curmu ) ; 
	goto lab81 ; 
      } 
      break ; 
      default: 
      confusion ( 883 ) ; 
      break ; 
    } 
    switch ( mem [ q + 1 ] .hh .v.RH ) 
    {case 1 : 
    case 4 : 
      {
	fetch ( q + 1 ) ; 
	if ( ( curi .b0 > 0 ) ) 
	{
	  delta = fontinfo [ italicbase [ curf ] + ( curi .b2 ) / 4 ] .cint ; 
	  p = newcharacter ( curf , curc ) ; 
	  if ( ( mem [ q + 1 ] .hh .v.RH == 4 ) && ( fontinfo [ 2 + parambase 
	  [ curf ] ] .cint != 0 ) ) 
	  delta = 0 ; 
	  if ( ( mem [ q + 3 ] .hh .v.RH == 0 ) && ( delta != 0 ) ) 
	  {
	    mem [ p ] .hh .v.RH = newkern ( delta ) ; 
	    delta = 0 ; 
	  } 
	} 
	else p = 0 ; 
      } 
      break ; 
    case 0 : 
      p = 0 ; 
      break ; 
    case 2 : 
      p = mem [ q + 1 ] .hh .v.LH ; 
      break ; 
    case 3 : 
      {
	curmlist = mem [ q + 1 ] .hh .v.LH ; 
	savestyle = curstyle ; 
	mlistpenalties = false ; 
	mlisttohlist () ; 
	curstyle = savestyle ; 
	{
	  if ( curstyle < 4 ) 
	  cursize = 0 ; 
	  else cursize = 16 * ( ( curstyle - 2 ) / 2 ) ; 
	  curmu = xovern ( fontinfo [ 6 + parambase [ eqtb [ 7837 + cursize ] 
	  .hh .v.RH ] ] .cint , 18 ) ; 
	} 
	p = hpack ( mem [ memtop - 3 ] .hh .v.RH , 0 , 1 ) ; 
      } 
      break ; 
      default: 
      confusion ( 884 ) ; 
      break ; 
    } 
    mem [ q + 1 ] .cint = p ; 
    if ( ( mem [ q + 3 ] .hh .v.RH == 0 ) && ( mem [ q + 2 ] .hh .v.RH == 0 ) 
    ) 
    goto lab82 ; 
    makescripts ( q , delta ) ; 
    lab82: z = hpack ( mem [ q + 1 ] .cint , 0 , 1 ) ; 
    if ( mem [ z + 3 ] .cint > maxh ) 
    maxh = mem [ z + 3 ] .cint ; 
    if ( mem [ z + 2 ] .cint > maxd ) 
    maxd = mem [ z + 2 ] .cint ; 
    freenode ( z , 7 ) ; 
    lab80: r = q ; 
    rtype = mem [ r ] .hh.b0 ; 
    lab81: q = mem [ q ] .hh .v.RH ; 
  } 
  if ( rtype == 18 ) 
  mem [ r ] .hh.b0 = 16 ; 
  p = memtop - 3 ; 
  mem [ p ] .hh .v.RH = 0 ; 
  q = mlist ; 
  rtype = 0 ; 
  curstyle = style ; 
  {
    if ( curstyle < 4 ) 
    cursize = 0 ; 
    else cursize = 16 * ( ( curstyle - 2 ) / 2 ) ; 
    curmu = xovern ( fontinfo [ 6 + parambase [ eqtb [ 7837 + cursize ] .hh 
    .v.RH ] ] .cint , 18 ) ; 
  } 
  while ( q != 0 ) {
      
    t = 16 ; 
    s = 4 ; 
    pen = 10000 ; 
    switch ( mem [ q ] .hh.b0 ) 
    {case 17 : 
    case 20 : 
    case 21 : 
    case 22 : 
    case 23 : 
      t = mem [ q ] .hh.b0 ; 
      break ; 
    case 18 : 
      {
	t = 18 ; 
	pen = eqtb [ 9172 ] .cint ; 
      } 
      break ; 
    case 19 : 
      {
	t = 19 ; 
	pen = eqtb [ 9173 ] .cint ; 
      } 
      break ; 
    case 16 : 
    case 29 : 
    case 27 : 
    case 26 : 
      ; 
      break ; 
    case 24 : 
      s = 5 ; 
      break ; 
    case 28 : 
      s = 5 ; 
      break ; 
    case 25 : 
      {
	t = 23 ; 
	s = 6 ; 
      } 
      break ; 
    case 30 : 
    case 31 : 
      t = makeleftright ( q , style , maxd , maxh ) ; 
      break ; 
    case 14 : 
      {
	curstyle = mem [ q ] .hh.b1 ; 
	s = 3 ; 
	{
	  if ( curstyle < 4 ) 
	  cursize = 0 ; 
	  else cursize = 16 * ( ( curstyle - 2 ) / 2 ) ; 
	  curmu = xovern ( fontinfo [ 6 + parambase [ eqtb [ 7837 + cursize ] 
	  .hh .v.RH ] ] .cint , 18 ) ; 
	} 
	goto lab83 ; 
      } 
      break ; 
    case 8 : 
    case 12 : 
    case 2 : 
    case 7 : 
    case 5 : 
    case 3 : 
    case 4 : 
    case 10 : 
    case 11 : 
      {
	mem [ p ] .hh .v.RH = q ; 
	p = q ; 
	q = mem [ q ] .hh .v.RH ; 
	mem [ p ] .hh .v.RH = 0 ; 
	goto lab30 ; 
      } 
      break ; 
      default: 
      confusion ( 885 ) ; 
      break ; 
    } 
    if ( rtype > 0 ) 
    {
      switch ( strpool [ rtype * 8 + t + magicoffset ] ) 
      {case 48 : 
	x = 0 ; 
	break ; 
      case 49 : 
	if ( curstyle < 4 ) 
	x = 15 ; 
	else x = 0 ; 
	break ; 
      case 50 : 
	x = 15 ; 
	break ; 
      case 51 : 
	if ( curstyle < 4 ) 
	x = 16 ; 
	else x = 0 ; 
	break ; 
      case 52 : 
	if ( curstyle < 4 ) 
	x = 17 ; 
	else x = 0 ; 
	break ; 
	default: 
	confusion ( 887 ) ; 
	break ; 
      } 
      if ( x != 0 ) 
      {
	y = mathglue ( eqtb [ 6782 + x ] .hh .v.RH , curmu ) ; 
	z = newglue ( y ) ; 
	mem [ y ] .hh .v.RH = 0 ; 
	mem [ p ] .hh .v.RH = z ; 
	p = z ; 
	mem [ z ] .hh.b1 = x + 1 ; 
      } 
    } 
    if ( mem [ q + 1 ] .cint != 0 ) 
    {
      mem [ p ] .hh .v.RH = mem [ q + 1 ] .cint ; 
      do {
	  p = mem [ p ] .hh .v.RH ; 
      } while ( ! ( mem [ p ] .hh .v.RH == 0 ) ) ; 
    } 
    if ( penalties ) 
    if ( mem [ q ] .hh .v.RH != 0 ) 
    if ( pen < 10000 ) 
    {
      rtype = mem [ mem [ q ] .hh .v.RH ] .hh.b0 ; 
      if ( rtype != 12 ) 
      if ( rtype != 19 ) 
      {
	z = newpenalty ( pen ) ; 
	mem [ p ] .hh .v.RH = z ; 
	p = z ; 
      } 
    } 
    rtype = t ; 
    lab83: r = q ; 
    q = mem [ q ] .hh .v.RH ; 
    freenode ( r , s ) ; 
    lab30: ; 
  } 
} 
void pushalignment ( ) 
{pushalignment_regmem 
  halfword p  ; 
  p = getnode ( 5 ) ; 
  mem [ p ] .hh .v.RH = alignptr ; 
  mem [ p ] .hh .v.LH = curalign ; 
  mem [ p + 1 ] .hh .v.LH = mem [ memtop - 8 ] .hh .v.RH ; 
  mem [ p + 1 ] .hh .v.RH = curspan ; 
  mem [ p + 2 ] .cint = curloop ; 
  mem [ p + 3 ] .cint = alignstate ; 
  mem [ p + 4 ] .hh .v.LH = curhead ; 
  mem [ p + 4 ] .hh .v.RH = curtail ; 
  alignptr = p ; 
  curhead = getavail () ; 
} 
void popalignment ( ) 
{popalignment_regmem 
  halfword p  ; 
  {
    mem [ curhead ] .hh .v.RH = avail ; 
    avail = curhead ; 
	;
#ifdef STAT
    decr ( dynused ) ; 
#endif /* STAT */
  } 
  p = alignptr ; 
  curtail = mem [ p + 4 ] .hh .v.RH ; 
  curhead = mem [ p + 4 ] .hh .v.LH ; 
  alignstate = mem [ p + 3 ] .cint ; 
  curloop = mem [ p + 2 ] .cint ; 
  curspan = mem [ p + 1 ] .hh .v.RH ; 
  mem [ memtop - 8 ] .hh .v.RH = mem [ p + 1 ] .hh .v.LH ; 
  curalign = mem [ p ] .hh .v.LH ; 
  alignptr = mem [ p ] .hh .v.RH ; 
  freenode ( p , 5 ) ; 
} 
void getpreambletoken ( ) 
{/* 20 */ getpreambletoken_regmem 
  lab20: gettoken () ; 
  while ( ( curchr == 256 ) && ( curcmd == 4 ) ) {
      
    gettoken () ; 
    if ( curcmd > 100 ) 
    {
      expand () ; 
      gettoken () ; 
    } 
  } 
  if ( curcmd == 9 ) 
  fatalerror ( 592 ) ; 
  if ( ( curcmd == 75 ) && ( curchr == 6793 ) ) 
  {
    scanoptionalequals () ; 
    scanglue ( 2 ) ; 
    if ( eqtb [ 9206 ] .cint > 0 ) 
    geqdefine ( 6793 , 117 , curval ) ; 
    else eqdefine ( 6793 , 117 , curval ) ; 
    goto lab20 ; 
  } 
} 
void initalign ( ) 
{/* 30 31 32 22 */ initalign_regmem 
  halfword savecsptr  ; 
  halfword p  ; 
  savecsptr = curcs ; 
  pushalignment () ; 
  alignstate = -1000000L ; 
  if ( ( curlist .modefield == 203 ) && ( ( curlist .tailfield != curlist 
  .headfield ) || ( curlist .auxfield .cint != 0 ) ) ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 677 ) ; 
    } 
    printesc ( 517 ) ; 
    print ( 888 ) ; 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 889 ; 
      helpline [ 1 ] = 890 ; 
      helpline [ 0 ] = 891 ; 
    } 
    error () ; 
    flushmath () ; 
  } 
  pushnest () ; 
  if ( curlist .modefield == 203 ) 
  {
    curlist .modefield = -1 ; 
    curlist .auxfield .cint = nest [ nestptr - 2 ] .auxfield .cint ; 
  } 
  else if ( curlist .modefield > 0 ) 
  curlist .modefield = - (integer) curlist .modefield ; 
  scanspec ( 6 , false ) ; 
  mem [ memtop - 8 ] .hh .v.RH = 0 ; 
  curalign = memtop - 8 ; 
  curloop = 0 ; 
  scannerstatus = 4 ; 
  warningindex = savecsptr ; 
  alignstate = -1000000L ; 
  while ( true ) {
      
    mem [ curalign ] .hh .v.RH = newparamglue ( 11 ) ; 
    curalign = mem [ curalign ] .hh .v.RH ; 
    if ( curcmd == 5 ) 
    goto lab30 ; 
    p = memtop - 4 ; 
    mem [ p ] .hh .v.RH = 0 ; 
    while ( true ) {
	
      getpreambletoken () ; 
      if ( curcmd == 6 ) 
      goto lab31 ; 
      if ( ( curcmd <= 5 ) && ( curcmd >= 4 ) && ( alignstate == -1000000L ) ) 
      if ( ( p == memtop - 4 ) && ( curloop == 0 ) && ( curcmd == 4 ) ) 
      curloop = curalign ; 
      else {
	  
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 897 ) ; 
	} 
	{
	  helpptr = 3 ; 
	  helpline [ 2 ] = 898 ; 
	  helpline [ 1 ] = 899 ; 
	  helpline [ 0 ] = 900 ; 
	} 
	backerror () ; 
	goto lab31 ; 
      } 
      else if ( ( curcmd != 10 ) || ( p != memtop - 4 ) ) 
      {
	mem [ p ] .hh .v.RH = getavail () ; 
	p = mem [ p ] .hh .v.RH ; 
	mem [ p ] .hh .v.LH = curtok ; 
      } 
    } 
    lab31: ; 
    mem [ curalign ] .hh .v.RH = newnullbox () ; 
    curalign = mem [ curalign ] .hh .v.RH ; 
    mem [ curalign ] .hh .v.LH = memtop - 9 ; 
    mem [ curalign + 1 ] .cint = -1073741824L ; 
    mem [ curalign + 3 ] .cint = mem [ memtop - 4 ] .hh .v.RH ; 
    p = memtop - 4 ; 
    mem [ p ] .hh .v.RH = 0 ; 
    while ( true ) {
	
      lab22: getpreambletoken () ; 
      if ( ( curcmd <= 5 ) && ( curcmd >= 4 ) && ( alignstate == -1000000L ) ) 
      goto lab32 ; 
      if ( curcmd == 6 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 901 ) ; 
	} 
	{
	  helpptr = 3 ; 
	  helpline [ 2 ] = 898 ; 
	  helpline [ 1 ] = 899 ; 
	  helpline [ 0 ] = 902 ; 
	} 
	error () ; 
	goto lab22 ; 
      } 
      mem [ p ] .hh .v.RH = getavail () ; 
      p = mem [ p ] .hh .v.RH ; 
      mem [ p ] .hh .v.LH = curtok ; 
    } 
    lab32: mem [ p ] .hh .v.RH = getavail () ; 
    p = mem [ p ] .hh .v.RH ; 
    mem [ p ] .hh .v.LH = 10614 ; 
    mem [ curalign + 2 ] .cint = mem [ memtop - 4 ] .hh .v.RH ; 
  } 
  lab30: scannerstatus = 0 ; 
  newsavelevel ( 6 ) ; 
  if ( eqtb [ 7320 ] .hh .v.RH != 0 ) 
  begintokenlist ( eqtb [ 7320 ] .hh .v.RH , 13 ) ; 
  alignpeek () ; 
} 
void zinitspan ( p ) 
halfword p ; 
{initspan_regmem 
  pushnest () ; 
  if ( curlist .modefield == -102 ) 
  curlist .auxfield .hh .v.LH = 1000 ; 
  else {
      
    curlist .auxfield .cint = -65536000L ; 
    normalparagraph () ; 
  } 
  curspan = p ; 
} 
void initrow ( ) 
{initrow_regmem 
  pushnest () ; 
  curlist .modefield = ( -103 ) - curlist .modefield ; 
  if ( curlist .modefield == -102 ) 
  curlist .auxfield .hh .v.LH = 0 ; 
  else curlist .auxfield .cint = 0 ; 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newglue ( mem [ mem [ memtop - 8 ] 
    .hh .v.RH + 1 ] .hh .v.LH ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  mem [ curlist .tailfield ] .hh.b1 = 12 ; 
  curalign = mem [ mem [ memtop - 8 ] .hh .v.RH ] .hh .v.RH ; 
  curtail = curhead ; 
  initspan ( curalign ) ; 
} 
void initcol ( ) 
{initcol_regmem 
  mem [ curalign + 5 ] .hh .v.LH = curcmd ; 
  if ( curcmd == 63 ) 
  alignstate = 0 ; 
  else {
      
    backinput () ; 
    begintokenlist ( mem [ curalign + 3 ] .cint , 1 ) ; 
  } 
} 
boolean fincol ( ) 
{/* 10 */ register boolean Result; fincol_regmem 
  halfword p  ; 
  halfword q, r  ; 
  halfword s  ; 
  halfword u  ; 
  scaled w  ; 
  glueord o  ; 
  halfword n  ; 
  if ( curalign == 0 ) 
  confusion ( 903 ) ; 
  q = mem [ curalign ] .hh .v.RH ; 
  if ( q == 0 ) 
  confusion ( 903 ) ; 
  if ( alignstate < 500000L ) 
  fatalerror ( 592 ) ; 
  p = mem [ q ] .hh .v.RH ; 
  if ( ( p == 0 ) && ( mem [ curalign + 5 ] .hh .v.LH < 257 ) ) 
  if ( curloop != 0 ) 
  {
    mem [ q ] .hh .v.RH = newnullbox () ; 
    p = mem [ q ] .hh .v.RH ; 
    mem [ p ] .hh .v.LH = memtop - 9 ; 
    mem [ p + 1 ] .cint = -1073741824L ; 
    curloop = mem [ curloop ] .hh .v.RH ; 
    q = memtop - 4 ; 
    r = mem [ curloop + 3 ] .cint ; 
    while ( r != 0 ) {
	
      mem [ q ] .hh .v.RH = getavail () ; 
      q = mem [ q ] .hh .v.RH ; 
      mem [ q ] .hh .v.LH = mem [ r ] .hh .v.LH ; 
      r = mem [ r ] .hh .v.RH ; 
    } 
    mem [ q ] .hh .v.RH = 0 ; 
    mem [ p + 3 ] .cint = mem [ memtop - 4 ] .hh .v.RH ; 
    q = memtop - 4 ; 
    r = mem [ curloop + 2 ] .cint ; 
    while ( r != 0 ) {
	
      mem [ q ] .hh .v.RH = getavail () ; 
      q = mem [ q ] .hh .v.RH ; 
      mem [ q ] .hh .v.LH = mem [ r ] .hh .v.LH ; 
      r = mem [ r ] .hh .v.RH ; 
    } 
    mem [ q ] .hh .v.RH = 0 ; 
    mem [ p + 2 ] .cint = mem [ memtop - 4 ] .hh .v.RH ; 
    curloop = mem [ curloop ] .hh .v.RH ; 
    mem [ p ] .hh .v.RH = newglue ( mem [ curloop + 1 ] .hh .v.LH ) ; 
  } 
  else {
      
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 904 ) ; 
    } 
    printesc ( 893 ) ; 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 905 ; 
      helpline [ 1 ] = 906 ; 
      helpline [ 0 ] = 907 ; 
    } 
    mem [ curalign + 5 ] .hh .v.LH = 257 ; 
    error () ; 
  } 
  if ( mem [ curalign + 5 ] .hh .v.LH != 256 ) 
  {
    unsave () ; 
    newsavelevel ( 6 ) ; 
    {
      if ( curlist .modefield == -102 ) 
      {
	adjusttail = curtail ; 
	u = hpack ( mem [ curlist .headfield ] .hh .v.RH , 0 , 1 ) ; 
	w = mem [ u + 1 ] .cint ; 
	curtail = adjusttail ; 
	adjusttail = 0 ; 
      } 
      else {
	  
	u = vpackage ( mem [ curlist .headfield ] .hh .v.RH , 0 , 1 , 0 ) ; 
	w = mem [ u + 3 ] .cint ; 
      } 
      n = 0 ; 
      if ( curspan != curalign ) 
      {
	q = curspan ; 
	do {
	    incr ( n ) ; 
	  q = mem [ mem [ q ] .hh .v.RH ] .hh .v.RH ; 
	} while ( ! ( q == curalign ) ) ; 
	if ( n > 255 ) 
	confusion ( 908 ) ; 
	q = curspan ; 
	while ( mem [ mem [ q ] .hh .v.LH ] .hh .v.RH < n ) q = mem [ q ] .hh 
	.v.LH ; 
	if ( mem [ mem [ q ] .hh .v.LH ] .hh .v.RH > n ) 
	{
	  s = getnode ( 2 ) ; 
	  mem [ s ] .hh .v.LH = mem [ q ] .hh .v.LH ; 
	  mem [ s ] .hh .v.RH = n ; 
	  mem [ q ] .hh .v.LH = s ; 
	  mem [ s + 1 ] .cint = w ; 
	} 
	else if ( mem [ mem [ q ] .hh .v.LH + 1 ] .cint < w ) 
	mem [ mem [ q ] .hh .v.LH + 1 ] .cint = w ; 
      } 
      else if ( w > mem [ curalign + 1 ] .cint ) 
      mem [ curalign + 1 ] .cint = w ; 
      mem [ u ] .hh.b0 = 13 ; 
      mem [ u ] .hh.b1 = n ; 
      if ( totalstretch [ 3 ] != 0 ) 
      o = 3 ; 
      else if ( totalstretch [ 2 ] != 0 ) 
      o = 2 ; 
      else if ( totalstretch [ 1 ] != 0 ) 
      o = 1 ; 
      else o = 0 ; 
      mem [ u + 5 ] .hh.b1 = o ; 
      mem [ u + 6 ] .cint = totalstretch [ o ] ; 
      if ( totalshrink [ 3 ] != 0 ) 
      o = 3 ; 
      else if ( totalshrink [ 2 ] != 0 ) 
      o = 2 ; 
      else if ( totalshrink [ 1 ] != 0 ) 
      o = 1 ; 
      else o = 0 ; 
      mem [ u + 5 ] .hh.b0 = o ; 
      mem [ u + 4 ] .cint = totalshrink [ o ] ; 
      popnest () ; 
      mem [ curlist .tailfield ] .hh .v.RH = u ; 
      curlist .tailfield = u ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newglue ( mem [ mem [ curalign ] 
      .hh .v.RH + 1 ] .hh .v.LH ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    mem [ curlist .tailfield ] .hh.b1 = 12 ; 
    if ( mem [ curalign + 5 ] .hh .v.LH >= 257 ) 
    {
      Result = true ; 
      return(Result) ; 
    } 
    initspan ( p ) ; 
  } 
  alignstate = 1000000L ; 
  do {
      getxtoken () ; 
  } while ( ! ( curcmd != 10 ) ) ; 
  curalign = p ; 
  initcol () ; 
  Result = false ; 
  return(Result) ; 
} 
void finrow ( ) 
{finrow_regmem 
  halfword p  ; 
  if ( curlist .modefield == -102 ) 
  {
    p = hpack ( mem [ curlist .headfield ] .hh .v.RH , 0 , 1 ) ; 
    popnest () ; 
    appendtovlist ( p ) ; 
    if ( curhead != curtail ) 
    {
      mem [ curlist .tailfield ] .hh .v.RH = mem [ curhead ] .hh .v.RH ; 
      curlist .tailfield = curtail ; 
    } 
  } 
  else {
      
    p = vpackage ( mem [ curlist .headfield ] .hh .v.RH , 0 , 1 , 1073741823L 
    ) ; 
    popnest () ; 
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    curlist .tailfield = p ; 
    curlist .auxfield .hh .v.LH = 1000 ; 
  } 
  mem [ p ] .hh.b0 = 13 ; 
  mem [ p + 6 ] .cint = 0 ; 
  if ( eqtb [ 7320 ] .hh .v.RH != 0 ) 
  begintokenlist ( eqtb [ 7320 ] .hh .v.RH , 13 ) ; 
  alignpeek () ; 
} 
void finalign ( ) 
{finalign_regmem 
  halfword p, q, r, s, u, v  ; 
  scaled t, w  ; 
  scaled o  ; 
  halfword n  ; 
  scaled rulesave  ; 
  memoryword auxsave  ; 
  if ( curgroup != 6 ) 
  confusion ( 909 ) ; 
  unsave () ; 
  if ( curgroup != 6 ) 
  confusion ( 910 ) ; 
  unsave () ; 
  if ( nest [ nestptr - 1 ] .modefield == 203 ) 
  o = eqtb [ 9745 ] .cint ; 
  else o = 0 ; 
  q = mem [ mem [ memtop - 8 ] .hh .v.RH ] .hh .v.RH ; 
  do {
      flushlist ( mem [ q + 3 ] .cint ) ; 
    flushlist ( mem [ q + 2 ] .cint ) ; 
    p = mem [ mem [ q ] .hh .v.RH ] .hh .v.RH ; 
    if ( mem [ q + 1 ] .cint == -1073741824L ) 
    {
      mem [ q + 1 ] .cint = 0 ; 
      r = mem [ q ] .hh .v.RH ; 
      s = mem [ r + 1 ] .hh .v.LH ; 
      if ( s != 0 ) 
      {
	incr ( mem [ 0 ] .hh .v.RH ) ; 
	deleteglueref ( s ) ; 
	mem [ r + 1 ] .hh .v.LH = 0 ; 
      } 
    } 
    if ( mem [ q ] .hh .v.LH != memtop - 9 ) 
    {
      t = mem [ q + 1 ] .cint + mem [ mem [ mem [ q ] .hh .v.RH + 1 ] .hh 
      .v.LH + 1 ] .cint ; 
      r = mem [ q ] .hh .v.LH ; 
      s = memtop - 9 ; 
      mem [ s ] .hh .v.LH = p ; 
      n = 1 ; 
      do {
	  mem [ r + 1 ] .cint = mem [ r + 1 ] .cint - t ; 
	u = mem [ r ] .hh .v.LH ; 
	while ( mem [ r ] .hh .v.RH > n ) {
	    
	  s = mem [ s ] .hh .v.LH ; 
	  n = mem [ mem [ s ] .hh .v.LH ] .hh .v.RH + 1 ; 
	} 
	if ( mem [ r ] .hh .v.RH < n ) 
	{
	  mem [ r ] .hh .v.LH = mem [ s ] .hh .v.LH ; 
	  mem [ s ] .hh .v.LH = r ; 
	  decr ( mem [ r ] .hh .v.RH ) ; 
	  s = r ; 
	} 
	else {
	    
	  if ( mem [ r + 1 ] .cint > mem [ mem [ s ] .hh .v.LH + 1 ] .cint ) 
	  mem [ mem [ s ] .hh .v.LH + 1 ] .cint = mem [ r + 1 ] .cint ; 
	  freenode ( r , 2 ) ; 
	} 
	r = u ; 
      } while ( ! ( r == memtop - 9 ) ) ; 
    } 
    mem [ q ] .hh.b0 = 13 ; 
    mem [ q ] .hh.b1 = 0 ; 
    mem [ q + 3 ] .cint = 0 ; 
    mem [ q + 2 ] .cint = 0 ; 
    mem [ q + 5 ] .hh.b1 = 0 ; 
    mem [ q + 5 ] .hh.b0 = 0 ; 
    mem [ q + 6 ] .cint = 0 ; 
    mem [ q + 4 ] .cint = 0 ; 
    q = p ; 
  } while ( ! ( q == 0 ) ) ; 
  saveptr = saveptr - 2 ; 
  packbeginline = - (integer) curlist .mlfield ; 
  if ( curlist .modefield == -1 ) 
  {
    rulesave = eqtb [ 9746 ] .cint ; 
    eqtb [ 9746 ] .cint = 0 ; 
    p = hpack ( mem [ memtop - 8 ] .hh .v.RH , savestack [ saveptr + 1 ] .cint 
    , savestack [ saveptr + 0 ] .cint ) ; 
    eqtb [ 9746 ] .cint = rulesave ; 
  } 
  else {
      
    q = mem [ mem [ memtop - 8 ] .hh .v.RH ] .hh .v.RH ; 
    do {
	mem [ q + 3 ] .cint = mem [ q + 1 ] .cint ; 
      mem [ q + 1 ] .cint = 0 ; 
      q = mem [ mem [ q ] .hh .v.RH ] .hh .v.RH ; 
    } while ( ! ( q == 0 ) ) ; 
    p = vpackage ( mem [ memtop - 8 ] .hh .v.RH , savestack [ saveptr + 1 ] 
    .cint , savestack [ saveptr + 0 ] .cint , 1073741823L ) ; 
    q = mem [ mem [ memtop - 8 ] .hh .v.RH ] .hh .v.RH ; 
    do {
	mem [ q + 1 ] .cint = mem [ q + 3 ] .cint ; 
      mem [ q + 3 ] .cint = 0 ; 
      q = mem [ mem [ q ] .hh .v.RH ] .hh .v.RH ; 
    } while ( ! ( q == 0 ) ) ; 
  } 
  packbeginline = 0 ; 
  q = mem [ curlist .headfield ] .hh .v.RH ; 
  s = curlist .headfield ; 
  while ( q != 0 ) {
      
    if ( ! ( q >= himemmin ) ) 
    if ( mem [ q ] .hh.b0 == 13 ) 
    {
      if ( curlist .modefield == -1 ) 
      {
	mem [ q ] .hh.b0 = 0 ; 
	mem [ q + 1 ] .cint = mem [ p + 1 ] .cint ; 
      } 
      else {
	  
	mem [ q ] .hh.b0 = 1 ; 
	mem [ q + 3 ] .cint = mem [ p + 3 ] .cint ; 
      } 
      mem [ q + 5 ] .hh.b1 = mem [ p + 5 ] .hh.b1 ; 
      mem [ q + 5 ] .hh.b0 = mem [ p + 5 ] .hh.b0 ; 
      mem [ q + 6 ] .gr = mem [ p + 6 ] .gr ; 
      mem [ q + 4 ] .cint = o ; 
      r = mem [ mem [ q + 5 ] .hh .v.RH ] .hh .v.RH ; 
      s = mem [ mem [ p + 5 ] .hh .v.RH ] .hh .v.RH ; 
      do {
	  n = mem [ r ] .hh.b1 ; 
	t = mem [ s + 1 ] .cint ; 
	w = t ; 
	u = memtop - 4 ; 
	while ( n > 0 ) {
	    
	  decr ( n ) ; 
	  s = mem [ s ] .hh .v.RH ; 
	  v = mem [ s + 1 ] .hh .v.LH ; 
	  mem [ u ] .hh .v.RH = newglue ( v ) ; 
	  u = mem [ u ] .hh .v.RH ; 
	  mem [ u ] .hh.b1 = 12 ; 
	  t = t + mem [ v + 1 ] .cint ; 
	  if ( mem [ p + 5 ] .hh.b0 == 1 ) 
	  {
	    if ( mem [ v ] .hh.b0 == mem [ p + 5 ] .hh.b1 ) 
	    t = t + round ( mem [ p + 6 ] .gr * mem [ v + 2 ] .cint ) ; 
	  } 
	  else if ( mem [ p + 5 ] .hh.b0 == 2 ) 
	  {
	    if ( mem [ v ] .hh.b1 == mem [ p + 5 ] .hh.b1 ) 
	    t = t - round ( mem [ p + 6 ] .gr * mem [ v + 3 ] .cint ) ; 
	  } 
	  s = mem [ s ] .hh .v.RH ; 
	  mem [ u ] .hh .v.RH = newnullbox () ; 
	  u = mem [ u ] .hh .v.RH ; 
	  t = t + mem [ s + 1 ] .cint ; 
	  if ( curlist .modefield == -1 ) 
	  mem [ u + 1 ] .cint = mem [ s + 1 ] .cint ; 
	  else {
	      
	    mem [ u ] .hh.b0 = 1 ; 
	    mem [ u + 3 ] .cint = mem [ s + 1 ] .cint ; 
	  } 
	} 
	if ( curlist .modefield == -1 ) 
	{
	  mem [ r + 3 ] .cint = mem [ q + 3 ] .cint ; 
	  mem [ r + 2 ] .cint = mem [ q + 2 ] .cint ; 
	  if ( t == mem [ r + 1 ] .cint ) 
	  {
	    mem [ r + 5 ] .hh.b0 = 0 ; 
	    mem [ r + 5 ] .hh.b1 = 0 ; 
	    mem [ r + 6 ] .gr = 0.0 ; 
	  } 
	  else if ( t > mem [ r + 1 ] .cint ) 
	  {
	    mem [ r + 5 ] .hh.b0 = 1 ; 
	    if ( mem [ r + 6 ] .cint == 0 ) 
	    mem [ r + 6 ] .gr = 0.0 ; 
	    else mem [ r + 6 ] .gr = ( t - mem [ r + 1 ] .cint ) / ((double) 
	    mem [ r + 6 ] .cint ) ; 
	  } 
	  else {
	      
	    mem [ r + 5 ] .hh.b1 = mem [ r + 5 ] .hh.b0 ; 
	    mem [ r + 5 ] .hh.b0 = 2 ; 
	    if ( mem [ r + 4 ] .cint == 0 ) 
	    mem [ r + 6 ] .gr = 0.0 ; 
	    else if ( ( mem [ r + 5 ] .hh.b1 == 0 ) && ( mem [ r + 1 ] .cint - 
	    t > mem [ r + 4 ] .cint ) ) 
	    mem [ r + 6 ] .gr = 1.0 ; 
	    else mem [ r + 6 ] .gr = ( mem [ r + 1 ] .cint - t ) / ((double) 
	    mem [ r + 4 ] .cint ) ; 
	  } 
	  mem [ r + 1 ] .cint = w ; 
	  mem [ r ] .hh.b0 = 0 ; 
	} 
	else {
	    
	  mem [ r + 1 ] .cint = mem [ q + 1 ] .cint ; 
	  if ( t == mem [ r + 3 ] .cint ) 
	  {
	    mem [ r + 5 ] .hh.b0 = 0 ; 
	    mem [ r + 5 ] .hh.b1 = 0 ; 
	    mem [ r + 6 ] .gr = 0.0 ; 
	  } 
	  else if ( t > mem [ r + 3 ] .cint ) 
	  {
	    mem [ r + 5 ] .hh.b0 = 1 ; 
	    if ( mem [ r + 6 ] .cint == 0 ) 
	    mem [ r + 6 ] .gr = 0.0 ; 
	    else mem [ r + 6 ] .gr = ( t - mem [ r + 3 ] .cint ) / ((double) 
	    mem [ r + 6 ] .cint ) ; 
	  } 
	  else {
	      
	    mem [ r + 5 ] .hh.b1 = mem [ r + 5 ] .hh.b0 ; 
	    mem [ r + 5 ] .hh.b0 = 2 ; 
	    if ( mem [ r + 4 ] .cint == 0 ) 
	    mem [ r + 6 ] .gr = 0.0 ; 
	    else if ( ( mem [ r + 5 ] .hh.b1 == 0 ) && ( mem [ r + 3 ] .cint - 
	    t > mem [ r + 4 ] .cint ) ) 
	    mem [ r + 6 ] .gr = 1.0 ; 
	    else mem [ r + 6 ] .gr = ( mem [ r + 3 ] .cint - t ) / ((double) 
	    mem [ r + 4 ] .cint ) ; 
	  } 
	  mem [ r + 3 ] .cint = w ; 
	  mem [ r ] .hh.b0 = 1 ; 
	} 
	mem [ r + 4 ] .cint = 0 ; 
	if ( u != memtop - 4 ) 
	{
	  mem [ u ] .hh .v.RH = mem [ r ] .hh .v.RH ; 
	  mem [ r ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
	  r = u ; 
	} 
	r = mem [ mem [ r ] .hh .v.RH ] .hh .v.RH ; 
	s = mem [ mem [ s ] .hh .v.RH ] .hh .v.RH ; 
      } while ( ! ( r == 0 ) ) ; 
    } 
    else if ( mem [ q ] .hh.b0 == 2 ) 
    {
      if ( ( mem [ q + 1 ] .cint == -1073741824L ) ) 
      mem [ q + 1 ] .cint = mem [ p + 1 ] .cint ; 
      if ( ( mem [ q + 3 ] .cint == -1073741824L ) ) 
      mem [ q + 3 ] .cint = mem [ p + 3 ] .cint ; 
      if ( ( mem [ q + 2 ] .cint == -1073741824L ) ) 
      mem [ q + 2 ] .cint = mem [ p + 2 ] .cint ; 
      if ( o != 0 ) 
      {
	r = mem [ q ] .hh .v.RH ; 
	mem [ q ] .hh .v.RH = 0 ; 
	q = hpack ( q , 0 , 1 ) ; 
	mem [ q + 4 ] .cint = o ; 
	mem [ q ] .hh .v.RH = r ; 
	mem [ s ] .hh .v.RH = q ; 
      } 
    } 
    s = q ; 
    q = mem [ q ] .hh .v.RH ; 
  } 
  flushnodelist ( p ) ; 
  popalignment () ; 
  auxsave = curlist .auxfield ; 
  p = mem [ curlist .headfield ] .hh .v.RH ; 
  q = curlist .tailfield ; 
  popnest () ; 
  if ( curlist .modefield == 203 ) 
  {
    doassignments () ; 
    if ( curcmd != 3 ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1164 ) ; 
      } 
      {
	helpptr = 2 ; 
	helpline [ 1 ] = 889 ; 
	helpline [ 0 ] = 890 ; 
      } 
      backerror () ; 
    } 
    else {
	
      getxtoken () ; 
      if ( curcmd != 3 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1160 ) ; 
	} 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1161 ; 
	  helpline [ 0 ] = 1162 ; 
	} 
	backerror () ; 
      } 
    } 
    popnest () ; 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( eqtb [ 9174 ] .cint 
      ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newparamglue ( 3 ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    if ( p != 0 ) 
    curlist .tailfield = q ; 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( eqtb [ 9175 ] .cint 
      ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newparamglue ( 4 ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    curlist .auxfield .cint = auxsave .cint ; 
    resumeafterdisplay () ; 
  } 
  else {
      
    curlist .auxfield = auxsave ; 
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    if ( p != 0 ) 
    curlist .tailfield = q ; 
    if ( curlist .modefield == 1 ) 
    buildpage () ; 
  } 
} 
void alignpeek ( ) 
{/* 20 */ alignpeek_regmem 
  lab20: alignstate = 1000000L ; 
  do {
      getxtoken () ; 
  } while ( ! ( curcmd != 10 ) ) ; 
  if ( curcmd == 34 ) 
  {
    scanleftbrace () ; 
    newsavelevel ( 7 ) ; 
    if ( curlist .modefield == -1 ) 
    normalparagraph () ; 
  } 
  else if ( curcmd == 2 ) 
  finalign () ; 
  else if ( ( curcmd == 5 ) && ( curchr == 258 ) ) 
  goto lab20 ; 
  else {
      
    initrow () ; 
    initcol () ; 
  } 
} 
halfword zfiniteshrink ( p ) 
halfword p ; 
{register halfword Result; finiteshrink_regmem 
  halfword q  ; 
  if ( noshrinkerroryet ) 
  {
    noshrinkerroryet = false ; 
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 911 ) ; 
    } 
    {
      helpptr = 5 ; 
      helpline [ 4 ] = 912 ; 
      helpline [ 3 ] = 913 ; 
      helpline [ 2 ] = 914 ; 
      helpline [ 1 ] = 915 ; 
      helpline [ 0 ] = 916 ; 
    } 
    error () ; 
  } 
  q = newspec ( p ) ; 
  mem [ q ] .hh.b1 = 0 ; 
  deleteglueref ( p ) ; 
  Result = q ; 
  return(Result) ; 
} 
void ztrybreak ( pi , breaktype ) 
integer pi ; 
smallnumber breaktype ; 
{/* 10 30 31 22 60 */ trybreak_regmem 
  halfword r  ; 
  halfword prevr  ; 
  halfword oldl  ; 
  boolean nobreakyet  ; 
  halfword prevprevr  ; 
  halfword s  ; 
  halfword q  ; 
  halfword v  ; 
  integer t  ; 
  internalfontnumber f  ; 
  halfword l  ; 
  boolean noderstaysactive  ; 
  scaled linewidth  ; 
  char fitclass  ; 
  halfword b  ; 
  integer d  ; 
  boolean artificialdemerits  ; 
  halfword savelink  ; 
  scaled shortfall  ; 
  if ( abs ( pi ) >= 10000 ) 
  if ( pi > 0 ) 
  goto lab10 ; 
  else pi = -10000 ; 
  nobreakyet = true ; 
  prevr = memtop - 7 ; 
  oldl = 0 ; 
  curactivewidth [ 1 ] = activewidth [ 1 ] ; 
  curactivewidth [ 2 ] = activewidth [ 2 ] ; 
  curactivewidth [ 3 ] = activewidth [ 3 ] ; 
  curactivewidth [ 4 ] = activewidth [ 4 ] ; 
  curactivewidth [ 5 ] = activewidth [ 5 ] ; 
  curactivewidth [ 6 ] = activewidth [ 6 ] ; 
  while ( true ) {
      
    lab22: r = mem [ prevr ] .hh .v.RH ; 
    if ( mem [ r ] .hh.b0 == 2 ) 
    {
      curactivewidth [ 1 ] = curactivewidth [ 1 ] + mem [ r + 1 ] .cint ; 
      curactivewidth [ 2 ] = curactivewidth [ 2 ] + mem [ r + 2 ] .cint ; 
      curactivewidth [ 3 ] = curactivewidth [ 3 ] + mem [ r + 3 ] .cint ; 
      curactivewidth [ 4 ] = curactivewidth [ 4 ] + mem [ r + 4 ] .cint ; 
      curactivewidth [ 5 ] = curactivewidth [ 5 ] + mem [ r + 5 ] .cint ; 
      curactivewidth [ 6 ] = curactivewidth [ 6 ] + mem [ r + 6 ] .cint ; 
      prevprevr = prevr ; 
      prevr = r ; 
      goto lab22 ; 
    } 
    {
      l = mem [ r + 1 ] .hh .v.LH ; 
      if ( l > oldl ) 
      {
	if ( ( minimumdemerits < 1073741823L ) && ( ( oldl != easyline ) || ( 
	r == memtop - 7 ) ) ) 
	{
	  if ( nobreakyet ) 
	  {
	    nobreakyet = false ; 
	    breakwidth [ 1 ] = background [ 1 ] ; 
	    breakwidth [ 2 ] = background [ 2 ] ; 
	    breakwidth [ 3 ] = background [ 3 ] ; 
	    breakwidth [ 4 ] = background [ 4 ] ; 
	    breakwidth [ 5 ] = background [ 5 ] ; 
	    breakwidth [ 6 ] = background [ 6 ] ; 
	    s = curp ; 
	    if ( breaktype > 0 ) 
	    if ( curp != 0 ) 
	    {
	      t = mem [ curp ] .hh.b1 ; 
	      v = curp ; 
	      s = mem [ curp + 1 ] .hh .v.RH ; 
	      while ( t > 0 ) {
		  
		decr ( t ) ; 
		v = mem [ v ] .hh .v.RH ; 
		if ( ( v >= himemmin ) ) 
		{
		  f = mem [ v ] .hh.b0 ; 
		  breakwidth [ 1 ] = breakwidth [ 1 ] - fontinfo [ widthbase [ 
		  f ] + fontinfo [ charbase [ f ] + mem [ v ] .hh.b1 ] .qqqq 
		  .b0 ] .cint ; 
		} 
		else switch ( mem [ v ] .hh.b0 ) 
		{case 6 : 
		  {
		    f = mem [ v + 1 ] .hh.b0 ; 
		    breakwidth [ 1 ] = breakwidth [ 1 ] - fontinfo [ widthbase 
		    [ f ] + fontinfo [ charbase [ f ] + mem [ v + 1 ] .hh.b1 ] 
		    .qqqq .b0 ] .cint ; 
		  } 
		  break ; 
		case 0 : 
		case 1 : 
		case 2 : 
		case 11 : 
		  breakwidth [ 1 ] = breakwidth [ 1 ] - mem [ v + 1 ] .cint ; 
		  break ; 
		  default: 
		  confusion ( 917 ) ; 
		  break ; 
		} 
	      } 
	      while ( s != 0 ) {
		  
		if ( ( s >= himemmin ) ) 
		{
		  f = mem [ s ] .hh.b0 ; 
		  breakwidth [ 1 ] = breakwidth [ 1 ] + fontinfo [ widthbase [ 
		  f ] + fontinfo [ charbase [ f ] + mem [ s ] .hh.b1 ] .qqqq 
		  .b0 ] .cint ; 
		} 
		else switch ( mem [ s ] .hh.b0 ) 
		{case 6 : 
		  {
		    f = mem [ s + 1 ] .hh.b0 ; 
		    breakwidth [ 1 ] = breakwidth [ 1 ] + fontinfo [ widthbase 
		    [ f ] + fontinfo [ charbase [ f ] + mem [ s + 1 ] .hh.b1 ] 
		    .qqqq .b0 ] .cint ; 
		  } 
		  break ; 
		case 0 : 
		case 1 : 
		case 2 : 
		case 11 : 
		  breakwidth [ 1 ] = breakwidth [ 1 ] + mem [ s + 1 ] .cint ; 
		  break ; 
		  default: 
		  confusion ( 918 ) ; 
		  break ; 
		} 
		s = mem [ s ] .hh .v.RH ; 
	      } 
	      breakwidth [ 1 ] = breakwidth [ 1 ] + discwidth ; 
	      if ( mem [ curp + 1 ] .hh .v.RH == 0 ) 
	      s = mem [ v ] .hh .v.RH ; 
	    } 
	    while ( s != 0 ) {
		
	      if ( ( s >= himemmin ) ) 
	      goto lab30 ; 
	      switch ( mem [ s ] .hh.b0 ) 
	      {case 10 : 
		{
		  v = mem [ s + 1 ] .hh .v.LH ; 
		  breakwidth [ 1 ] = breakwidth [ 1 ] - mem [ v + 1 ] .cint ; 
		  breakwidth [ 2 + mem [ v ] .hh.b0 ] = breakwidth [ 2 + mem [ 
		  v ] .hh.b0 ] - mem [ v + 2 ] .cint ; 
		  breakwidth [ 6 ] = breakwidth [ 6 ] - mem [ v + 3 ] .cint ; 
		} 
		break ; 
	      case 12 : 
		; 
		break ; 
	      case 9 : 
		breakwidth [ 1 ] = breakwidth [ 1 ] - mem [ s + 1 ] .cint ; 
		break ; 
	      case 11 : 
		if ( mem [ s ] .hh.b1 != 1 ) 
		goto lab30 ; 
		else breakwidth [ 1 ] = breakwidth [ 1 ] - mem [ s + 1 ] .cint 
		; 
		break ; 
		default: 
		goto lab30 ; 
		break ; 
	      } 
	      s = mem [ s ] .hh .v.RH ; 
	    } 
	    lab30: ; 
	  } 
	  if ( mem [ prevr ] .hh.b0 == 2 ) 
	  {
	    mem [ prevr + 1 ] .cint = mem [ prevr + 1 ] .cint - curactivewidth 
	    [ 1 ] + breakwidth [ 1 ] ; 
	    mem [ prevr + 2 ] .cint = mem [ prevr + 2 ] .cint - curactivewidth 
	    [ 2 ] + breakwidth [ 2 ] ; 
	    mem [ prevr + 3 ] .cint = mem [ prevr + 3 ] .cint - curactivewidth 
	    [ 3 ] + breakwidth [ 3 ] ; 
	    mem [ prevr + 4 ] .cint = mem [ prevr + 4 ] .cint - curactivewidth 
	    [ 4 ] + breakwidth [ 4 ] ; 
	    mem [ prevr + 5 ] .cint = mem [ prevr + 5 ] .cint - curactivewidth 
	    [ 5 ] + breakwidth [ 5 ] ; 
	    mem [ prevr + 6 ] .cint = mem [ prevr + 6 ] .cint - curactivewidth 
	    [ 6 ] + breakwidth [ 6 ] ; 
	  } 
	  else if ( prevr == memtop - 7 ) 
	  {
	    activewidth [ 1 ] = breakwidth [ 1 ] ; 
	    activewidth [ 2 ] = breakwidth [ 2 ] ; 
	    activewidth [ 3 ] = breakwidth [ 3 ] ; 
	    activewidth [ 4 ] = breakwidth [ 4 ] ; 
	    activewidth [ 5 ] = breakwidth [ 5 ] ; 
	    activewidth [ 6 ] = breakwidth [ 6 ] ; 
	  } 
	  else {
	      
	    q = getnode ( 7 ) ; 
	    mem [ q ] .hh .v.RH = r ; 
	    mem [ q ] .hh.b0 = 2 ; 
	    mem [ q ] .hh.b1 = 0 ; 
	    mem [ q + 1 ] .cint = breakwidth [ 1 ] - curactivewidth [ 1 ] ; 
	    mem [ q + 2 ] .cint = breakwidth [ 2 ] - curactivewidth [ 2 ] ; 
	    mem [ q + 3 ] .cint = breakwidth [ 3 ] - curactivewidth [ 3 ] ; 
	    mem [ q + 4 ] .cint = breakwidth [ 4 ] - curactivewidth [ 4 ] ; 
	    mem [ q + 5 ] .cint = breakwidth [ 5 ] - curactivewidth [ 5 ] ; 
	    mem [ q + 6 ] .cint = breakwidth [ 6 ] - curactivewidth [ 6 ] ; 
	    mem [ prevr ] .hh .v.RH = q ; 
	    prevprevr = prevr ; 
	    prevr = q ; 
	  } 
	  if ( abs ( eqtb [ 9179 ] .cint ) >= 1073741823L - minimumdemerits ) 
	  minimumdemerits = 1073741822L ; 
	  else minimumdemerits = minimumdemerits + abs ( eqtb [ 9179 ] .cint ) 
	  ; 
	  {register integer for_end; fitclass = 0 ; for_end = 3 ; if ( 
	  fitclass <= for_end) do 
	    {
	      if ( minimaldemerits [ fitclass ] <= minimumdemerits ) 
	      {
		q = getnode ( 2 ) ; 
		mem [ q ] .hh .v.RH = passive ; 
		passive = q ; 
		mem [ q + 1 ] .hh .v.RH = curp ; 
	;
#ifdef STAT
		incr ( passnumber ) ; 
		mem [ q ] .hh .v.LH = passnumber ; 
#endif /* STAT */
		mem [ q + 1 ] .hh .v.LH = bestplace [ fitclass ] ; 
		q = getnode ( 3 ) ; 
		mem [ q + 1 ] .hh .v.RH = passive ; 
		mem [ q + 1 ] .hh .v.LH = bestplline [ fitclass ] + 1 ; 
		mem [ q ] .hh.b1 = fitclass ; 
		mem [ q ] .hh.b0 = breaktype ; 
		mem [ q + 2 ] .cint = minimaldemerits [ fitclass ] ; 
		mem [ q ] .hh .v.RH = r ; 
		mem [ prevr ] .hh .v.RH = q ; 
		prevr = q ; 
	;
#ifdef STAT
		if ( eqtb [ 9195 ] .cint > 0 ) 
		{
		  printnl ( 919 ) ; 
		  printint ( mem [ passive ] .hh .v.LH ) ; 
		  print ( 920 ) ; 
		  printint ( mem [ q + 1 ] .hh .v.LH - 1 ) ; 
		  printchar ( 46 ) ; 
		  printint ( fitclass ) ; 
		  if ( breaktype == 1 ) 
		  printchar ( 45 ) ; 
		  print ( 921 ) ; 
		  printint ( mem [ q + 2 ] .cint ) ; 
		  print ( 922 ) ; 
		  if ( mem [ passive + 1 ] .hh .v.LH == 0 ) 
		  printchar ( 48 ) ; 
		  else printint ( mem [ mem [ passive + 1 ] .hh .v.LH ] .hh 
		  .v.LH ) ; 
		} 
#endif /* STAT */
	      } 
	      minimaldemerits [ fitclass ] = 1073741823L ; 
	    } 
	  while ( fitclass++ < for_end ) ; } 
	  minimumdemerits = 1073741823L ; 
	  if ( r != memtop - 7 ) 
	  {
	    q = getnode ( 7 ) ; 
	    mem [ q ] .hh .v.RH = r ; 
	    mem [ q ] .hh.b0 = 2 ; 
	    mem [ q ] .hh.b1 = 0 ; 
	    mem [ q + 1 ] .cint = curactivewidth [ 1 ] - breakwidth [ 1 ] ; 
	    mem [ q + 2 ] .cint = curactivewidth [ 2 ] - breakwidth [ 2 ] ; 
	    mem [ q + 3 ] .cint = curactivewidth [ 3 ] - breakwidth [ 3 ] ; 
	    mem [ q + 4 ] .cint = curactivewidth [ 4 ] - breakwidth [ 4 ] ; 
	    mem [ q + 5 ] .cint = curactivewidth [ 5 ] - breakwidth [ 5 ] ; 
	    mem [ q + 6 ] .cint = curactivewidth [ 6 ] - breakwidth [ 6 ] ; 
	    mem [ prevr ] .hh .v.RH = q ; 
	    prevprevr = prevr ; 
	    prevr = q ; 
	  } 
	} 
	if ( r == memtop - 7 ) 
	goto lab10 ; 
	if ( l > easyline ) 
	{
	  linewidth = secondwidth ; 
	  oldl = 65534L ; 
	} 
	else {
	    
	  oldl = l ; 
	  if ( l > lastspecialline ) 
	  linewidth = secondwidth ; 
	  else if ( eqtb [ 7312 ] .hh .v.RH == 0 ) 
	  linewidth = firstwidth ; 
	  else linewidth = mem [ eqtb [ 7312 ] .hh .v.RH + 2 * l ] .cint ; 
	} 
      } 
    } 
    {
      artificialdemerits = false ; 
      shortfall = linewidth - curactivewidth [ 1 ] ; 
      if ( shortfall > 0 ) 
      if ( ( curactivewidth [ 3 ] != 0 ) || ( curactivewidth [ 4 ] != 0 ) || ( 
      curactivewidth [ 5 ] != 0 ) ) 
      {
	b = 0 ; 
	fitclass = 2 ; 
      } 
      else {
	  
	if ( shortfall > 7230584L ) 
	if ( curactivewidth [ 2 ] < 1663497L ) 
	{
	  b = 10000 ; 
	  fitclass = 0 ; 
	  goto lab31 ; 
	} 
	b = badness ( shortfall , curactivewidth [ 2 ] ) ; 
	if ( b > 12 ) 
	if ( b > 99 ) 
	fitclass = 0 ; 
	else fitclass = 1 ; 
	else fitclass = 2 ; 
	lab31: ; 
      } 
      else {
	  
	if ( - (integer) shortfall > curactivewidth [ 6 ] ) 
	b = 10001 ; 
	else b = badness ( - (integer) shortfall , curactivewidth [ 6 ] ) ; 
	if ( b > 12 ) 
	fitclass = 3 ; 
	else fitclass = 2 ; 
      } 
      if ( ( b > 10000 ) || ( pi == -10000 ) ) 
      {
	if ( finalpass && ( minimumdemerits == 1073741823L ) && ( mem [ r ] 
	.hh .v.RH == memtop - 7 ) && ( prevr == memtop - 7 ) ) 
	artificialdemerits = true ; 
	else if ( b > threshold ) 
	goto lab60 ; 
	noderstaysactive = false ; 
      } 
      else {
	  
	prevr = r ; 
	if ( b > threshold ) 
	goto lab22 ; 
	noderstaysactive = true ; 
      } 
      if ( artificialdemerits ) 
      d = 0 ; 
      else {
	  
	d = eqtb [ 9165 ] .cint + b ; 
	if ( abs ( d ) >= 10000 ) 
	d = 100000000L ; 
	else d = d * d ; 
	if ( pi != 0 ) 
	if ( pi > 0 ) 
	d = d + pi * pi ; 
	else if ( pi > -10000 ) 
	d = d - pi * pi ; 
	if ( ( breaktype == 1 ) && ( mem [ r ] .hh.b0 == 1 ) ) 
	if ( curp != 0 ) 
	d = d + eqtb [ 9177 ] .cint ; 
	else d = d + eqtb [ 9178 ] .cint ; 
	if ( abs ( toint ( fitclass ) - toint ( mem [ r ] .hh.b1 ) ) > 1 ) 
	d = d + eqtb [ 9179 ] .cint ; 
      } 
	;
#ifdef STAT
      if ( eqtb [ 9195 ] .cint > 0 ) 
      {
	if ( printednode != curp ) 
	{
	  printnl ( 335 ) ; 
	  if ( curp == 0 ) 
	  shortdisplay ( mem [ printednode ] .hh .v.RH ) ; 
	  else {
	      
	    savelink = mem [ curp ] .hh .v.RH ; 
	    mem [ curp ] .hh .v.RH = 0 ; 
	    printnl ( 335 ) ; 
	    shortdisplay ( mem [ printednode ] .hh .v.RH ) ; 
	    mem [ curp ] .hh .v.RH = savelink ; 
	  } 
	  printednode = curp ; 
	} 
	printnl ( 64 ) ; 
	if ( curp == 0 ) 
	printesc ( 594 ) ; 
	else if ( mem [ curp ] .hh.b0 != 10 ) 
	{
	  if ( mem [ curp ] .hh.b0 == 12 ) 
	  printesc ( 528 ) ; 
	  else if ( mem [ curp ] .hh.b0 == 7 ) 
	  printesc ( 346 ) ; 
	  else if ( mem [ curp ] .hh.b0 == 11 ) 
	  printesc ( 337 ) ; 
	  else printesc ( 340 ) ; 
	} 
	print ( 923 ) ; 
	if ( mem [ r + 1 ] .hh .v.RH == 0 ) 
	printchar ( 48 ) ; 
	else printint ( mem [ mem [ r + 1 ] .hh .v.RH ] .hh .v.LH ) ; 
	print ( 924 ) ; 
	if ( b > 10000 ) 
	printchar ( 42 ) ; 
	else printint ( b ) ; 
	print ( 925 ) ; 
	printint ( pi ) ; 
	print ( 926 ) ; 
	if ( artificialdemerits ) 
	printchar ( 42 ) ; 
	else printint ( d ) ; 
      } 
#endif /* STAT */
      d = d + mem [ r + 2 ] .cint ; 
      if ( d <= minimaldemerits [ fitclass ] ) 
      {
	minimaldemerits [ fitclass ] = d ; 
	bestplace [ fitclass ] = mem [ r + 1 ] .hh .v.RH ; 
	bestplline [ fitclass ] = l ; 
	if ( d < minimumdemerits ) 
	minimumdemerits = d ; 
      } 
      if ( noderstaysactive ) 
      goto lab22 ; 
      lab60: mem [ prevr ] .hh .v.RH = mem [ r ] .hh .v.RH ; 
      freenode ( r , 3 ) ; 
      if ( prevr == memtop - 7 ) 
      {
	r = mem [ memtop - 7 ] .hh .v.RH ; 
	if ( mem [ r ] .hh.b0 == 2 ) 
	{
	  activewidth [ 1 ] = activewidth [ 1 ] + mem [ r + 1 ] .cint ; 
	  activewidth [ 2 ] = activewidth [ 2 ] + mem [ r + 2 ] .cint ; 
	  activewidth [ 3 ] = activewidth [ 3 ] + mem [ r + 3 ] .cint ; 
	  activewidth [ 4 ] = activewidth [ 4 ] + mem [ r + 4 ] .cint ; 
	  activewidth [ 5 ] = activewidth [ 5 ] + mem [ r + 5 ] .cint ; 
	  activewidth [ 6 ] = activewidth [ 6 ] + mem [ r + 6 ] .cint ; 
	  curactivewidth [ 1 ] = activewidth [ 1 ] ; 
	  curactivewidth [ 2 ] = activewidth [ 2 ] ; 
	  curactivewidth [ 3 ] = activewidth [ 3 ] ; 
	  curactivewidth [ 4 ] = activewidth [ 4 ] ; 
	  curactivewidth [ 5 ] = activewidth [ 5 ] ; 
	  curactivewidth [ 6 ] = activewidth [ 6 ] ; 
	  mem [ memtop - 7 ] .hh .v.RH = mem [ r ] .hh .v.RH ; 
	  freenode ( r , 7 ) ; 
	} 
      } 
      else if ( mem [ prevr ] .hh.b0 == 2 ) 
      {
	r = mem [ prevr ] .hh .v.RH ; 
	if ( r == memtop - 7 ) 
	{
	  curactivewidth [ 1 ] = curactivewidth [ 1 ] - mem [ prevr + 1 ] 
	  .cint ; 
	  curactivewidth [ 2 ] = curactivewidth [ 2 ] - mem [ prevr + 2 ] 
	  .cint ; 
	  curactivewidth [ 3 ] = curactivewidth [ 3 ] - mem [ prevr + 3 ] 
	  .cint ; 
	  curactivewidth [ 4 ] = curactivewidth [ 4 ] - mem [ prevr + 4 ] 
	  .cint ; 
	  curactivewidth [ 5 ] = curactivewidth [ 5 ] - mem [ prevr + 5 ] 
	  .cint ; 
	  curactivewidth [ 6 ] = curactivewidth [ 6 ] - mem [ prevr + 6 ] 
	  .cint ; 
	  mem [ prevprevr ] .hh .v.RH = memtop - 7 ; 
	  freenode ( prevr , 7 ) ; 
	  prevr = prevprevr ; 
	} 
	else if ( mem [ r ] .hh.b0 == 2 ) 
	{
	  curactivewidth [ 1 ] = curactivewidth [ 1 ] + mem [ r + 1 ] .cint ; 
	  curactivewidth [ 2 ] = curactivewidth [ 2 ] + mem [ r + 2 ] .cint ; 
	  curactivewidth [ 3 ] = curactivewidth [ 3 ] + mem [ r + 3 ] .cint ; 
	  curactivewidth [ 4 ] = curactivewidth [ 4 ] + mem [ r + 4 ] .cint ; 
	  curactivewidth [ 5 ] = curactivewidth [ 5 ] + mem [ r + 5 ] .cint ; 
	  curactivewidth [ 6 ] = curactivewidth [ 6 ] + mem [ r + 6 ] .cint ; 
	  mem [ prevr + 1 ] .cint = mem [ prevr + 1 ] .cint + mem [ r + 1 ] 
	  .cint ; 
	  mem [ prevr + 2 ] .cint = mem [ prevr + 2 ] .cint + mem [ r + 2 ] 
	  .cint ; 
	  mem [ prevr + 3 ] .cint = mem [ prevr + 3 ] .cint + mem [ r + 3 ] 
	  .cint ; 
	  mem [ prevr + 4 ] .cint = mem [ prevr + 4 ] .cint + mem [ r + 4 ] 
	  .cint ; 
	  mem [ prevr + 5 ] .cint = mem [ prevr + 5 ] .cint + mem [ r + 5 ] 
	  .cint ; 
	  mem [ prevr + 6 ] .cint = mem [ prevr + 6 ] .cint + mem [ r + 6 ] 
	  .cint ; 
	  mem [ prevr ] .hh .v.RH = mem [ r ] .hh .v.RH ; 
	  freenode ( r , 7 ) ; 
	} 
      } 
    } 
  } 
  lab10: 
	;
#ifdef STAT
  if ( curp == printednode ) 
  if ( curp != 0 ) 
  if ( mem [ curp ] .hh.b0 == 7 ) 
  {
    t = mem [ curp ] .hh.b1 ; 
    while ( t > 0 ) {
	
      decr ( t ) ; 
      printednode = mem [ printednode ] .hh .v.RH ; 
    } 
  } 
#endif /* STAT */
} 
void zpostlinebreak ( finalwidowpenalty ) 
integer finalwidowpenalty ; 
{/* 30 31 */ postlinebreak_regmem 
  halfword q, r, s  ; 
  boolean discbreak  ; 
  boolean postdiscbreak  ; 
  scaled curwidth  ; 
  scaled curindent  ; 
  quarterword t  ; 
  integer pen  ; 
  halfword curline  ; 
  q = mem [ bestbet + 1 ] .hh .v.RH ; 
  curp = 0 ; 
  do {
      r = q ; 
    q = mem [ q + 1 ] .hh .v.LH ; 
    mem [ r + 1 ] .hh .v.LH = curp ; 
    curp = r ; 
  } while ( ! ( q == 0 ) ) ; 
  curline = curlist .pgfield + 1 ; 
  do {
      q = mem [ curp + 1 ] .hh .v.RH ; 
    discbreak = false ; 
    postdiscbreak = false ; 
    if ( q != 0 ) 
    if ( mem [ q ] .hh.b0 == 10 ) 
    {
      deleteglueref ( mem [ q + 1 ] .hh .v.LH ) ; 
      mem [ q + 1 ] .hh .v.LH = eqtb [ 6790 ] .hh .v.RH ; 
      mem [ q ] .hh.b1 = 9 ; 
      incr ( mem [ eqtb [ 6790 ] .hh .v.RH ] .hh .v.RH ) ; 
      goto lab30 ; 
    } 
    else {
	
      if ( mem [ q ] .hh.b0 == 7 ) 
      {
	t = mem [ q ] .hh.b1 ; 
	if ( t == 0 ) 
	r = mem [ q ] .hh .v.RH ; 
	else {
	    
	  r = q ; 
	  while ( t > 1 ) {
	      
	    r = mem [ r ] .hh .v.RH ; 
	    decr ( t ) ; 
	  } 
	  s = mem [ r ] .hh .v.RH ; 
	  r = mem [ s ] .hh .v.RH ; 
	  mem [ s ] .hh .v.RH = 0 ; 
	  flushnodelist ( mem [ q ] .hh .v.RH ) ; 
	  mem [ q ] .hh.b1 = 0 ; 
	} 
	if ( mem [ q + 1 ] .hh .v.RH != 0 ) 
	{
	  s = mem [ q + 1 ] .hh .v.RH ; 
	  while ( mem [ s ] .hh .v.RH != 0 ) s = mem [ s ] .hh .v.RH ; 
	  mem [ s ] .hh .v.RH = r ; 
	  r = mem [ q + 1 ] .hh .v.RH ; 
	  mem [ q + 1 ] .hh .v.RH = 0 ; 
	  postdiscbreak = true ; 
	} 
	if ( mem [ q + 1 ] .hh .v.LH != 0 ) 
	{
	  s = mem [ q + 1 ] .hh .v.LH ; 
	  mem [ q ] .hh .v.RH = s ; 
	  while ( mem [ s ] .hh .v.RH != 0 ) s = mem [ s ] .hh .v.RH ; 
	  mem [ q + 1 ] .hh .v.LH = 0 ; 
	  q = s ; 
	} 
	mem [ q ] .hh .v.RH = r ; 
	discbreak = true ; 
      } 
      else if ( ( mem [ q ] .hh.b0 == 9 ) || ( mem [ q ] .hh.b0 == 11 ) ) 
      mem [ q + 1 ] .cint = 0 ; 
    } 
    else {
	
      q = memtop - 3 ; 
      while ( mem [ q ] .hh .v.RH != 0 ) q = mem [ q ] .hh .v.RH ; 
    } 
    r = newparamglue ( 8 ) ; 
    mem [ r ] .hh .v.RH = mem [ q ] .hh .v.RH ; 
    mem [ q ] .hh .v.RH = r ; 
    q = r ; 
    lab30: ; 
    r = mem [ q ] .hh .v.RH ; 
    mem [ q ] .hh .v.RH = 0 ; 
    q = mem [ memtop - 3 ] .hh .v.RH ; 
    mem [ memtop - 3 ] .hh .v.RH = r ; 
    if ( eqtb [ 6789 ] .hh .v.RH != 0 ) 
    {
      r = newparamglue ( 7 ) ; 
      mem [ r ] .hh .v.RH = q ; 
      q = r ; 
    } 
    if ( curline > lastspecialline ) 
    {
      curwidth = secondwidth ; 
      curindent = secondindent ; 
    } 
    else if ( eqtb [ 7312 ] .hh .v.RH == 0 ) 
    {
      curwidth = firstwidth ; 
      curindent = firstindent ; 
    } 
    else {
	
      curwidth = mem [ eqtb [ 7312 ] .hh .v.RH + 2 * curline ] .cint ; 
      curindent = mem [ eqtb [ 7312 ] .hh .v.RH + 2 * curline - 1 ] .cint ; 
    } 
    adjusttail = memtop - 5 ; 
    justbox = hpack ( q , curwidth , 0 ) ; 
    mem [ justbox + 4 ] .cint = curindent ; 
    appendtovlist ( justbox ) ; 
    if ( memtop - 5 != adjusttail ) 
    {
      mem [ curlist .tailfield ] .hh .v.RH = mem [ memtop - 5 ] .hh .v.RH ; 
      curlist .tailfield = adjusttail ; 
    } 
    adjusttail = 0 ; 
    if ( curline + 1 != bestline ) 
    {
      pen = eqtb [ 9176 ] .cint ; 
      if ( curline == curlist .pgfield + 1 ) 
      pen = pen + eqtb [ 9168 ] .cint ; 
      if ( curline + 2 == bestline ) 
      pen = pen + finalwidowpenalty ; 
      if ( discbreak ) 
      pen = pen + eqtb [ 9171 ] .cint ; 
      if ( pen != 0 ) 
      {
	r = newpenalty ( pen ) ; 
	mem [ curlist .tailfield ] .hh .v.RH = r ; 
	curlist .tailfield = r ; 
      } 
    } 
    incr ( curline ) ; 
    curp = mem [ curp + 1 ] .hh .v.LH ; 
    if ( curp != 0 ) 
    if ( ! postdiscbreak ) 
    {
      r = memtop - 3 ; 
      while ( true ) {
	  
	q = mem [ r ] .hh .v.RH ; 
	if ( q == mem [ curp + 1 ] .hh .v.RH ) 
	goto lab31 ; 
	if ( ( q >= himemmin ) ) 
	goto lab31 ; 
	if ( ( mem [ q ] .hh.b0 < 9 ) ) 
	goto lab31 ; 
	if ( mem [ q ] .hh.b0 == 11 ) 
	if ( mem [ q ] .hh.b1 != 1 ) 
	goto lab31 ; 
	r = q ; 
      } 
      lab31: if ( r != memtop - 3 ) 
      {
	mem [ r ] .hh .v.RH = 0 ; 
	flushnodelist ( mem [ memtop - 3 ] .hh .v.RH ) ; 
	mem [ memtop - 3 ] .hh .v.RH = q ; 
      } 
    } 
  } while ( ! ( curp == 0 ) ) ; 
  if ( ( curline != bestline ) || ( mem [ memtop - 3 ] .hh .v.RH != 0 ) ) 
  confusion ( 933 ) ; 
  curlist .pgfield = bestline - 1 ; 
} 
smallnumber zreconstitute ( j , n , bchar , hchar ) 
smallnumber j ; 
smallnumber n ; 
halfword bchar ; 
halfword hchar ; 
{/* 22 30 */ register smallnumber Result; reconstitute_regmem 
  halfword p  ; 
  halfword t  ; 
  fourquarters q  ; 
  halfword currh  ; 
  halfword testchar  ; 
  scaled w  ; 
  fontindex k  ; 
  hyphenpassed = 0 ; 
  t = memtop - 4 ; 
  w = 0 ; 
  mem [ memtop - 4 ] .hh .v.RH = 0 ; 
  curl = hu [ j ] ; 
  curq = t ; 
  if ( j == 0 ) 
  {
    ligaturepresent = initlig ; 
    p = initlist ; 
    if ( ligaturepresent ) 
    lfthit = initlft ; 
    while ( p > 0 ) {
	
      {
	mem [ t ] .hh .v.RH = getavail () ; 
	t = mem [ t ] .hh .v.RH ; 
	mem [ t ] .hh.b0 = hf ; 
	mem [ t ] .hh.b1 = mem [ p ] .hh.b1 ; 
      } 
      p = mem [ p ] .hh .v.RH ; 
    } 
  } 
  else if ( curl < 256 ) 
  {
    mem [ t ] .hh .v.RH = getavail () ; 
    t = mem [ t ] .hh .v.RH ; 
    mem [ t ] .hh.b0 = hf ; 
    mem [ t ] .hh.b1 = curl ; 
  } 
  ligstack = 0 ; 
  {
    if ( j < n ) 
    curr = hu [ j + 1 ] ; 
    else curr = bchar ; 
    if ( odd ( hyf [ j ] ) ) 
    currh = hchar ; 
    else currh = 256 ; 
  } 
  lab22: if ( curl == 256 ) 
  {
    k = bcharlabel [ hf ] ; 
    if ( k == 0 ) 
    goto lab30 ; 
    else q = fontinfo [ k ] .qqqq ; 
  } 
  else {
      
    q = fontinfo [ charbase [ hf ] + curl ] .qqqq ; 
    if ( ( ( q .b2 ) % 4 ) != 1 ) 
    goto lab30 ; 
    k = ligkernbase [ hf ] + q .b3 ; 
    q = fontinfo [ k ] .qqqq ; 
    if ( q .b0 > 128 ) 
    {
      k = ligkernbase [ hf ] + 256 * q .b2 + q .b3 + 32768L - 256 * ( 128 ) ; 
      q = fontinfo [ k ] .qqqq ; 
    } 
  } 
  if ( currh < 256 ) 
  testchar = currh ; 
  else testchar = curr ; 
  while ( true ) {
      
    if ( q .b1 == testchar ) 
    if ( q .b0 <= 128 ) 
    if ( currh < 256 ) 
    {
      hyphenpassed = j ; 
      hchar = 256 ; 
      currh = 256 ; 
      goto lab22 ; 
    } 
    else {
	
      if ( hchar < 256 ) 
      if ( odd ( hyf [ j ] ) ) 
      {
	hyphenpassed = j ; 
	hchar = 256 ; 
      } 
      if ( q .b2 < 128 ) 
      {
	if ( curl == 256 ) 
	lfthit = true ; 
	if ( j == n ) 
	if ( ligstack == 0 ) 
	rthit = true ; 
	{
	  if ( interrupt != 0 ) 
	  pauseforinstructions () ; 
	} 
	switch ( q .b2 ) 
	{case 1 : 
	case 5 : 
	  {
	    curl = q .b3 ; 
	    ligaturepresent = true ; 
	  } 
	  break ; 
	case 2 : 
	case 6 : 
	  {
	    curr = q .b3 ; 
	    if ( ligstack > 0 ) 
	    mem [ ligstack ] .hh.b1 = curr ; 
	    else {
		
	      ligstack = newligitem ( curr ) ; 
	      if ( j == n ) 
	      bchar = 256 ; 
	      else {
		  
		p = getavail () ; 
		mem [ ligstack + 1 ] .hh .v.RH = p ; 
		mem [ p ] .hh.b1 = hu [ j + 1 ] ; 
		mem [ p ] .hh.b0 = hf ; 
	      } 
	    } 
	  } 
	  break ; 
	case 3 : 
	  {
	    curr = q .b3 ; 
	    p = ligstack ; 
	    ligstack = newligitem ( curr ) ; 
	    mem [ ligstack ] .hh .v.RH = p ; 
	  } 
	  break ; 
	case 7 : 
	case 11 : 
	  {
	    if ( ligaturepresent ) 
	    {
	      p = newligature ( hf , curl , mem [ curq ] .hh .v.RH ) ; 
	      if ( lfthit ) 
	      {
		mem [ p ] .hh.b1 = 2 ; 
		lfthit = false ; 
	      } 
	      if ( false ) 
	      if ( ligstack == 0 ) 
	      {
		incr ( mem [ p ] .hh.b1 ) ; 
		rthit = false ; 
	      } 
	      mem [ curq ] .hh .v.RH = p ; 
	      t = p ; 
	      ligaturepresent = false ; 
	    } 
	    curq = t ; 
	    curl = q .b3 ; 
	    ligaturepresent = true ; 
	  } 
	  break ; 
	  default: 
	  {
	    curl = q .b3 ; 
	    ligaturepresent = true ; 
	    if ( ligstack > 0 ) 
	    {
	      if ( mem [ ligstack + 1 ] .hh .v.RH > 0 ) 
	      {
		mem [ t ] .hh .v.RH = mem [ ligstack + 1 ] .hh .v.RH ; 
		t = mem [ t ] .hh .v.RH ; 
		incr ( j ) ; 
	      } 
	      p = ligstack ; 
	      ligstack = mem [ p ] .hh .v.RH ; 
	      freenode ( p , 2 ) ; 
	      if ( ligstack == 0 ) 
	      {
		if ( j < n ) 
		curr = hu [ j + 1 ] ; 
		else curr = bchar ; 
		if ( odd ( hyf [ j ] ) ) 
		currh = hchar ; 
		else currh = 256 ; 
	      } 
	      else curr = mem [ ligstack ] .hh.b1 ; 
	    } 
	    else if ( j == n ) 
	    goto lab30 ; 
	    else {
		
	      {
		mem [ t ] .hh .v.RH = getavail () ; 
		t = mem [ t ] .hh .v.RH ; 
		mem [ t ] .hh.b0 = hf ; 
		mem [ t ] .hh.b1 = curr ; 
	      } 
	      incr ( j ) ; 
	      {
		if ( j < n ) 
		curr = hu [ j + 1 ] ; 
		else curr = bchar ; 
		if ( odd ( hyf [ j ] ) ) 
		currh = hchar ; 
		else currh = 256 ; 
	      } 
	    } 
	  } 
	  break ; 
	} 
	if ( q .b2 > 4 ) 
	if ( q .b2 != 7 ) 
	goto lab30 ; 
	goto lab22 ; 
      } 
      w = fontinfo [ kernbase [ hf ] + 256 * q .b2 + q .b3 ] .cint ; 
      goto lab30 ; 
    } 
    if ( q .b0 >= 128 ) 
    if ( currh == 256 ) 
    goto lab30 ; 
    else {
	
      currh = 256 ; 
      goto lab22 ; 
    } 
    k = k + q .b0 + 1 ; 
    q = fontinfo [ k ] .qqqq ; 
  } 
  lab30: ; 
  if ( ligaturepresent ) 
  {
    p = newligature ( hf , curl , mem [ curq ] .hh .v.RH ) ; 
    if ( lfthit ) 
    {
      mem [ p ] .hh.b1 = 2 ; 
      lfthit = false ; 
    } 
    if ( rthit ) 
    if ( ligstack == 0 ) 
    {
      incr ( mem [ p ] .hh.b1 ) ; 
      rthit = false ; 
    } 
    mem [ curq ] .hh .v.RH = p ; 
    t = p ; 
    ligaturepresent = false ; 
  } 
  if ( w != 0 ) 
  {
    mem [ t ] .hh .v.RH = newkern ( w ) ; 
    t = mem [ t ] .hh .v.RH ; 
    w = 0 ; 
  } 
  if ( ligstack > 0 ) 
  {
    curq = t ; 
    curl = mem [ ligstack ] .hh.b1 ; 
    ligaturepresent = true ; 
    {
      if ( mem [ ligstack + 1 ] .hh .v.RH > 0 ) 
      {
	mem [ t ] .hh .v.RH = mem [ ligstack + 1 ] .hh .v.RH ; 
	t = mem [ t ] .hh .v.RH ; 
	incr ( j ) ; 
      } 
      p = ligstack ; 
      ligstack = mem [ p ] .hh .v.RH ; 
      freenode ( p , 2 ) ; 
      if ( ligstack == 0 ) 
      {
	if ( j < n ) 
	curr = hu [ j + 1 ] ; 
	else curr = bchar ; 
	if ( odd ( hyf [ j ] ) ) 
	currh = hchar ; 
	else currh = 256 ; 
      } 
      else curr = mem [ ligstack ] .hh.b1 ; 
    } 
    goto lab22 ; 
  } 
  Result = j ; 
  return(Result) ; 
} 
void hyphenate ( ) 
{/* 50 30 40 41 42 45 10 */ hyphenate_regmem 
  char i, j, l  ; 
  halfword q, r, s  ; 
  halfword bchar  ; 
  halfword majortail, minortail  ; 
  ASCIIcode c  ; 
  char cloc  ; 
  integer rcount  ; 
  halfword hyfnode  ; 
  triepointer z  ; 
  integer v  ; 
  hyphpointer h  ; 
  strnumber k  ; 
  poolpointer u  ; 
  {register integer for_end; j = 0 ; for_end = hn ; if ( j <= for_end) do 
    hyf [ j ] = 0 ; 
  while ( j++ < for_end ) ; } 
  h = hc [ 1 ] ; 
  incr ( hn ) ; 
  hc [ hn ] = curlang ; 
  {register integer for_end; j = 2 ; for_end = hn ; if ( j <= for_end) do 
    h = ( h + h + hc [ j ] ) % 307 ; 
  while ( j++ < for_end ) ; } 
  while ( true ) {
      
    k = hyphword [ h ] ; 
    if ( k == 0 ) 
    goto lab45 ; 
    if ( ( strstart [ k + 1 ] - strstart [ k ] ) < hn ) 
    goto lab45 ; 
    if ( ( strstart [ k + 1 ] - strstart [ k ] ) == hn ) 
    {
      j = 1 ; 
      u = strstart [ k ] ; 
      do {
	  if ( strpool [ u ] < hc [ j ] ) 
	goto lab45 ; 
	if ( strpool [ u ] > hc [ j ] ) 
	goto lab30 ; 
	incr ( j ) ; 
	incr ( u ) ; 
      } while ( ! ( j > hn ) ) ; 
      s = hyphlist [ h ] ; 
      while ( s != 0 ) {
	  
	hyf [ mem [ s ] .hh .v.LH ] = 1 ; 
	s = mem [ s ] .hh .v.RH ; 
      } 
      decr ( hn ) ; 
      goto lab40 ; 
    } 
    lab30: ; 
    if ( h > 0 ) 
    decr ( h ) ; 
    else h = 307 ; 
  } 
  lab45: decr ( hn ) ; 
  if ( trietrc [ curlang + 1 ] != curlang ) 
  return ; 
  hc [ 0 ] = 0 ; 
  hc [ hn + 1 ] = 0 ; 
  hc [ hn + 2 ] = 256 ; 
  {register integer for_end; j = 0 ; for_end = hn - rhyf + 1 ; if ( j <= 
  for_end) do 
    {
      z = trietrl [ curlang + 1 ] + hc [ j ] ; 
      l = j ; 
      while ( hc [ l ] == trietrc [ z ] ) {
	  
	if ( trietro [ z ] != mintrieop ) 
	{
	  v = trietro [ z ] ; 
	  do {
	      v = v + opstart [ curlang ] ; 
	    i = l - hyfdistance [ v ] ; 
	    if ( hyfnum [ v ] > hyf [ i ] ) 
	    hyf [ i ] = hyfnum [ v ] ; 
	    v = hyfnext [ v ] ; 
	  } while ( ! ( v == mintrieop ) ) ; 
	} 
	incr ( l ) ; 
	z = trietrl [ z ] + hc [ l ] ; 
      } 
    } 
  while ( j++ < for_end ) ; } 
  lab40: {
      register integer for_end; j = 0 ; for_end = lhyf - 1 ; if ( j <= 
  for_end) do 
    hyf [ j ] = 0 ; 
  while ( j++ < for_end ) ; } 
  {register integer for_end; j = 0 ; for_end = rhyf - 1 ; if ( j <= for_end) 
  do 
    hyf [ hn - j ] = 0 ; 
  while ( j++ < for_end ) ; } 
  {register integer for_end; j = lhyf ; for_end = hn - rhyf ; if ( j <= 
  for_end) do 
    if ( odd ( hyf [ j ] ) ) 
    goto lab41 ; 
  while ( j++ < for_end ) ; } 
  return ; 
  lab41: ; 
  q = mem [ hb ] .hh .v.RH ; 
  mem [ hb ] .hh .v.RH = 0 ; 
  r = mem [ ha ] .hh .v.RH ; 
  mem [ ha ] .hh .v.RH = 0 ; 
  bchar = hyfbchar ; 
  if ( ( ha >= himemmin ) ) 
  if ( mem [ ha ] .hh.b0 != hf ) 
  goto lab42 ; 
  else {
      
    initlist = ha ; 
    initlig = false ; 
    hu [ 0 ] = mem [ ha ] .hh.b1 ; 
  } 
  else if ( mem [ ha ] .hh.b0 == 6 ) 
  if ( mem [ ha + 1 ] .hh.b0 != hf ) 
  goto lab42 ; 
  else {
      
    initlist = mem [ ha + 1 ] .hh .v.RH ; 
    initlig = true ; 
    initlft = ( mem [ ha ] .hh.b1 > 1 ) ; 
    hu [ 0 ] = mem [ ha + 1 ] .hh.b1 ; 
    if ( initlist == 0 ) 
    if ( initlft ) 
    {
      hu [ 0 ] = 256 ; 
      initlig = false ; 
    } 
    freenode ( ha , 2 ) ; 
  } 
  else {
      
    if ( ! ( r >= himemmin ) ) 
    if ( mem [ r ] .hh.b0 == 6 ) 
    if ( mem [ r ] .hh.b1 > 1 ) 
    goto lab42 ; 
    j = 1 ; 
    s = ha ; 
    initlist = 0 ; 
    goto lab50 ; 
  } 
  s = curp ; 
  while ( mem [ s ] .hh .v.RH != ha ) s = mem [ s ] .hh .v.RH ; 
  j = 0 ; 
  goto lab50 ; 
  lab42: s = ha ; 
  j = 0 ; 
  hu [ 0 ] = 256 ; 
  initlig = false ; 
  initlist = 0 ; 
  lab50: flushnodelist ( r ) ; 
  do {
      l = j ; 
    j = reconstitute ( j , hn , bchar , hyfchar ) + 1 ; 
    if ( hyphenpassed == 0 ) 
    {
      mem [ s ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
      while ( mem [ s ] .hh .v.RH > 0 ) s = mem [ s ] .hh .v.RH ; 
      if ( odd ( hyf [ j - 1 ] ) ) 
      {
	l = j ; 
	hyphenpassed = j - 1 ; 
	mem [ memtop - 4 ] .hh .v.RH = 0 ; 
      } 
    } 
    if ( hyphenpassed > 0 ) 
    do {
	r = getnode ( 2 ) ; 
      mem [ r ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
      mem [ r ] .hh.b0 = 7 ; 
      majortail = r ; 
      rcount = 0 ; 
      while ( mem [ majortail ] .hh .v.RH > 0 ) {
	  
	majortail = mem [ majortail ] .hh .v.RH ; 
	incr ( rcount ) ; 
      } 
      i = hyphenpassed ; 
      hyf [ i ] = 0 ; 
      minortail = 0 ; 
      mem [ r + 1 ] .hh .v.LH = 0 ; 
      hyfnode = newcharacter ( hf , hyfchar ) ; 
      if ( hyfnode != 0 ) 
      {
	incr ( i ) ; 
	c = hu [ i ] ; 
	hu [ i ] = hyfchar ; 
	{
	  mem [ hyfnode ] .hh .v.RH = avail ; 
	  avail = hyfnode ; 
	;
#ifdef STAT
	  decr ( dynused ) ; 
#endif /* STAT */
	} 
      } 
      while ( l <= i ) {
	  
	l = reconstitute ( l , i , fontbchar [ hf ] , 256 ) + 1 ; 
	if ( mem [ memtop - 4 ] .hh .v.RH > 0 ) 
	{
	  if ( minortail == 0 ) 
	  mem [ r + 1 ] .hh .v.LH = mem [ memtop - 4 ] .hh .v.RH ; 
	  else mem [ minortail ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
	  minortail = mem [ memtop - 4 ] .hh .v.RH ; 
	  while ( mem [ minortail ] .hh .v.RH > 0 ) minortail = mem [ 
	  minortail ] .hh .v.RH ; 
	} 
      } 
      if ( hyfnode != 0 ) 
      {
	hu [ i ] = c ; 
	l = i ; 
	decr ( i ) ; 
      } 
      minortail = 0 ; 
      mem [ r + 1 ] .hh .v.RH = 0 ; 
      cloc = 0 ; 
      if ( bcharlabel [ hf ] != 0 ) 
      {
	decr ( l ) ; 
	c = hu [ l ] ; 
	cloc = l ; 
	hu [ l ] = 256 ; 
      } 
      while ( l < j ) {
	  
	do {
	    l = reconstitute ( l , hn , bchar , 256 ) + 1 ; 
	  if ( cloc > 0 ) 
	  {
	    hu [ cloc ] = c ; 
	    cloc = 0 ; 
	  } 
	  if ( mem [ memtop - 4 ] .hh .v.RH > 0 ) 
	  {
	    if ( minortail == 0 ) 
	    mem [ r + 1 ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
	    else mem [ minortail ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
	    minortail = mem [ memtop - 4 ] .hh .v.RH ; 
	    while ( mem [ minortail ] .hh .v.RH > 0 ) minortail = mem [ 
	    minortail ] .hh .v.RH ; 
	  } 
	} while ( ! ( l >= j ) ) ; 
	while ( l > j ) {
	    
	  j = reconstitute ( j , hn , bchar , 256 ) + 1 ; 
	  mem [ majortail ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
	  while ( mem [ majortail ] .hh .v.RH > 0 ) {
	      
	    majortail = mem [ majortail ] .hh .v.RH ; 
	    incr ( rcount ) ; 
	  } 
	} 
      } 
      if ( rcount > 127 ) 
      {
	mem [ s ] .hh .v.RH = mem [ r ] .hh .v.RH ; 
	mem [ r ] .hh .v.RH = 0 ; 
	flushnodelist ( r ) ; 
      } 
      else {
	  
	mem [ s ] .hh .v.RH = r ; 
	mem [ r ] .hh.b1 = rcount ; 
      } 
      s = majortail ; 
      hyphenpassed = j - 1 ; 
      mem [ memtop - 4 ] .hh .v.RH = 0 ; 
    } while ( ! ( ! odd ( hyf [ j - 1 ] ) ) ) ; 
  } while ( ! ( j > hn ) ) ; 
  mem [ s ] .hh .v.RH = q ; 
  flushlist ( initlist ) ; 
} 
void newhyphexceptions ( ) 
{/* 21 10 40 45 */ newhyphexceptions_regmem 
  char n  ; 
  char j  ; 
  hyphpointer h  ; 
  strnumber k  ; 
  halfword p  ; 
  halfword q  ; 
  strnumber s, t  ; 
  poolpointer u, v  ; 
  scanleftbrace () ; 
  if ( eqtb [ 9213 ] .cint <= 0 ) 
  curlang = 0 ; 
  else if ( eqtb [ 9213 ] .cint > 255 ) 
  curlang = 0 ; 
  else curlang = eqtb [ 9213 ] .cint ; 
  n = 0 ; 
  p = 0 ; 
  while ( true ) {
      
    getxtoken () ; 
    lab21: switch ( curcmd ) 
    {case 11 : 
    case 12 : 
    case 68 : 
      if ( curchr == 45 ) 
      {
	if ( n < 63 ) 
	{
	  q = getavail () ; 
	  mem [ q ] .hh .v.RH = p ; 
	  mem [ q ] .hh .v.LH = n ; 
	  p = q ; 
	} 
      } 
      else {
	  
	if ( eqtb [ 8139 + curchr ] .hh .v.RH == 0 ) 
	{
	  {
	    if ( interaction == 3 ) 
	    ; 
	    printnl ( 262 ) ; 
	    print ( 939 ) ; 
	  } 
	  {
	    helpptr = 2 ; 
	    helpline [ 1 ] = 940 ; 
	    helpline [ 0 ] = 941 ; 
	  } 
	  error () ; 
	} 
	else if ( n < 63 ) 
	{
	  incr ( n ) ; 
	  hc [ n ] = eqtb [ 8139 + curchr ] .hh .v.RH ; 
	} 
      } 
      break ; 
    case 16 : 
      {
	scancharnum () ; 
	curchr = curval ; 
	curcmd = 68 ; 
	goto lab21 ; 
      } 
      break ; 
    case 10 : 
    case 2 : 
      {
	if ( n > 1 ) 
	{
	  incr ( n ) ; 
	  hc [ n ] = curlang ; 
	  {
	    if ( poolptr + n > poolsize ) 
	    overflow ( 257 , poolsize - initpoolptr ) ; 
	  } 
	  h = 0 ; 
	  {register integer for_end; j = 1 ; for_end = n ; if ( j <= for_end) 
	  do 
	    {
	      h = ( h + h + hc [ j ] ) % 307 ; 
	      {
		strpool [ poolptr ] = hc [ j ] ; 
		incr ( poolptr ) ; 
	      } 
	    } 
	  while ( j++ < for_end ) ; } 
	  s = makestring () ; 
	  if ( hyphcount == 307 ) 
	  overflow ( 942 , 307 ) ; 
	  incr ( hyphcount ) ; 
	  while ( hyphword [ h ] != 0 ) {
	      
	    k = hyphword [ h ] ; 
	    if ( ( strstart [ k + 1 ] - strstart [ k ] ) < ( strstart [ s + 1 
	    ] - strstart [ s ] ) ) 
	    goto lab40 ; 
	    if ( ( strstart [ k + 1 ] - strstart [ k ] ) > ( strstart [ s + 1 
	    ] - strstart [ s ] ) ) 
	    goto lab45 ; 
	    u = strstart [ k ] ; 
	    v = strstart [ s ] ; 
	    do {
		if ( strpool [ u ] < strpool [ v ] ) 
	      goto lab40 ; 
	      if ( strpool [ u ] > strpool [ v ] ) 
	      goto lab45 ; 
	      incr ( u ) ; 
	      incr ( v ) ; 
	    } while ( ! ( u == strstart [ k + 1 ] ) ) ; 
	    lab40: q = hyphlist [ h ] ; 
	    hyphlist [ h ] = p ; 
	    p = q ; 
	    t = hyphword [ h ] ; 
	    hyphword [ h ] = s ; 
	    s = t ; 
	    lab45: ; 
	    if ( h > 0 ) 
	    decr ( h ) ; 
	    else h = 307 ; 
	  } 
	  hyphword [ h ] = s ; 
	  hyphlist [ h ] = p ; 
	} 
	if ( curcmd == 2 ) 
	return ; 
	n = 0 ; 
	p = 0 ; 
      } 
      break ; 
      default: 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 677 ) ; 
	} 
	printesc ( 935 ) ; 
	print ( 936 ) ; 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 937 ; 
	  helpline [ 0 ] = 938 ; 
	} 
	error () ; 
      } 
      break ; 
    } 
  } 
} 
halfword zprunepagetop ( p ) 
halfword p ; 
{register halfword Result; prunepagetop_regmem 
  halfword prevp  ; 
  halfword q  ; 
  prevp = memtop - 3 ; 
  mem [ memtop - 3 ] .hh .v.RH = p ; 
  while ( p != 0 ) switch ( mem [ p ] .hh.b0 ) 
  {case 0 : 
  case 1 : 
  case 2 : 
    {
      q = newskipparam ( 10 ) ; 
      mem [ prevp ] .hh .v.RH = q ; 
      mem [ q ] .hh .v.RH = p ; 
      if ( mem [ tempptr + 1 ] .cint > mem [ p + 3 ] .cint ) 
      mem [ tempptr + 1 ] .cint = mem [ tempptr + 1 ] .cint - mem [ p + 3 ] 
      .cint ; 
      else mem [ tempptr + 1 ] .cint = 0 ; 
      p = 0 ; 
    } 
    break ; 
  case 8 : 
  case 4 : 
  case 3 : 
    {
      prevp = p ; 
      p = mem [ prevp ] .hh .v.RH ; 
    } 
    break ; 
  case 10 : 
  case 11 : 
  case 12 : 
    {
      q = p ; 
      p = mem [ q ] .hh .v.RH ; 
      mem [ q ] .hh .v.RH = 0 ; 
      mem [ prevp ] .hh .v.RH = p ; 
      flushnodelist ( q ) ; 
    } 
    break ; 
    default: 
    confusion ( 953 ) ; 
    break ; 
  } 
  Result = mem [ memtop - 3 ] .hh .v.RH ; 
  return(Result) ; 
} 
halfword zvertbreak ( p , h , d ) 
halfword p ; 
scaled h ; 
scaled d ; 
{/* 30 45 90 */ register halfword Result; vertbreak_regmem 
  halfword prevp  ; 
  halfword q, r  ; 
  integer pi  ; 
  integer b  ; 
  integer leastcost  ; 
  halfword bestplace  ; 
  scaled prevdp  ; 
  smallnumber t  ; 
  prevp = p ; 
  leastcost = 1073741823L ; 
  activewidth [ 1 ] = 0 ; 
  activewidth [ 2 ] = 0 ; 
  activewidth [ 3 ] = 0 ; 
  activewidth [ 4 ] = 0 ; 
  activewidth [ 5 ] = 0 ; 
  activewidth [ 6 ] = 0 ; 
  prevdp = 0 ; 
  while ( true ) {
      
    if ( p == 0 ) 
    pi = -10000 ; 
    else switch ( mem [ p ] .hh.b0 ) 
    {case 0 : 
    case 1 : 
    case 2 : 
      {
	activewidth [ 1 ] = activewidth [ 1 ] + prevdp + mem [ p + 3 ] .cint ; 
	prevdp = mem [ p + 2 ] .cint ; 
	goto lab45 ; 
      } 
      break ; 
    case 8 : 
      goto lab45 ; 
      break ; 
    case 10 : 
      if ( ( mem [ prevp ] .hh.b0 < 9 ) ) 
      pi = 0 ; 
      else goto lab90 ; 
      break ; 
    case 11 : 
      {
	if ( mem [ p ] .hh .v.RH == 0 ) 
	t = 12 ; 
	else t = mem [ mem [ p ] .hh .v.RH ] .hh.b0 ; 
	if ( t == 10 ) 
	pi = 0 ; 
	else goto lab90 ; 
      } 
      break ; 
    case 12 : 
      pi = mem [ p + 1 ] .cint ; 
      break ; 
    case 4 : 
    case 3 : 
      goto lab45 ; 
      break ; 
      default: 
      confusion ( 954 ) ; 
      break ; 
    } 
    if ( pi < 10000 ) 
    {
      if ( activewidth [ 1 ] < h ) 
      if ( ( activewidth [ 3 ] != 0 ) || ( activewidth [ 4 ] != 0 ) || ( 
      activewidth [ 5 ] != 0 ) ) 
      b = 0 ; 
      else b = badness ( h - activewidth [ 1 ] , activewidth [ 2 ] ) ; 
      else if ( activewidth [ 1 ] - h > activewidth [ 6 ] ) 
      b = 1073741823L ; 
      else b = badness ( activewidth [ 1 ] - h , activewidth [ 6 ] ) ; 
      if ( b < 1073741823L ) 
      if ( pi <= -10000 ) 
      b = pi ; 
      else if ( b < 10000 ) 
      b = b + pi ; 
      else b = 100000L ; 
      if ( b <= leastcost ) 
      {
	bestplace = p ; 
	leastcost = b ; 
	bestheightplusdepth = activewidth [ 1 ] + prevdp ; 
      } 
      if ( ( b == 1073741823L ) || ( pi <= -10000 ) ) 
      goto lab30 ; 
    } 
    if ( ( mem [ p ] .hh.b0 < 10 ) || ( mem [ p ] .hh.b0 > 11 ) ) 
    goto lab45 ; 
    lab90: if ( mem [ p ] .hh.b0 == 11 ) 
    q = p ; 
    else {
	
      q = mem [ p + 1 ] .hh .v.LH ; 
      activewidth [ 2 + mem [ q ] .hh.b0 ] = activewidth [ 2 + mem [ q ] 
      .hh.b0 ] + mem [ q + 2 ] .cint ; 
      activewidth [ 6 ] = activewidth [ 6 ] + mem [ q + 3 ] .cint ; 
      if ( ( mem [ q ] .hh.b1 != 0 ) && ( mem [ q + 3 ] .cint != 0 ) ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 955 ) ; 
	} 
	{
	  helpptr = 4 ; 
	  helpline [ 3 ] = 956 ; 
	  helpline [ 2 ] = 957 ; 
	  helpline [ 1 ] = 958 ; 
	  helpline [ 0 ] = 916 ; 
	} 
	error () ; 
	r = newspec ( q ) ; 
	mem [ r ] .hh.b1 = 0 ; 
	deleteglueref ( q ) ; 
	mem [ p + 1 ] .hh .v.LH = r ; 
	q = r ; 
      } 
    } 
    activewidth [ 1 ] = activewidth [ 1 ] + prevdp + mem [ q + 1 ] .cint ; 
    prevdp = 0 ; 
    lab45: if ( prevdp > d ) 
    {
      activewidth [ 1 ] = activewidth [ 1 ] + prevdp - d ; 
      prevdp = d ; 
    } 
    prevp = p ; 
    p = mem [ prevp ] .hh .v.RH ; 
  } 
  lab30: Result = bestplace ; 
  return(Result) ; 
} 
halfword zvsplit ( n , h ) 
eightbits n ; 
scaled h ; 
{/* 10 30 */ register halfword Result; vsplit_regmem 
  halfword v  ; 
  halfword p  ; 
  halfword q  ; 
  v = eqtb [ 7578 + n ] .hh .v.RH ; 
  if ( curmark [ 3 ] != 0 ) 
  {
    deletetokenref ( curmark [ 3 ] ) ; 
    curmark [ 3 ] = 0 ; 
    deletetokenref ( curmark [ 4 ] ) ; 
    curmark [ 4 ] = 0 ; 
  } 
  if ( v == 0 ) 
  {
    Result = 0 ; 
    return(Result) ; 
  } 
  if ( mem [ v ] .hh.b0 != 1 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 335 ) ; 
    } 
    printesc ( 959 ) ; 
    print ( 960 ) ; 
    printesc ( 961 ) ; 
    {
      helpptr = 2 ; 
      helpline [ 1 ] = 962 ; 
      helpline [ 0 ] = 963 ; 
    } 
    error () ; 
    Result = 0 ; 
    return(Result) ; 
  } 
  q = vertbreak ( mem [ v + 5 ] .hh .v.RH , h , eqtb [ 9736 ] .cint ) ; 
  p = mem [ v + 5 ] .hh .v.RH ; 
  if ( p == q ) 
  mem [ v + 5 ] .hh .v.RH = 0 ; 
  else while ( true ) {
      
    if ( mem [ p ] .hh.b0 == 4 ) 
    if ( curmark [ 3 ] == 0 ) 
    {
      curmark [ 3 ] = mem [ p + 1 ] .cint ; 
      curmark [ 4 ] = curmark [ 3 ] ; 
      mem [ curmark [ 3 ] ] .hh .v.LH = mem [ curmark [ 3 ] ] .hh .v.LH + 2 ; 
    } 
    else {
	
      deletetokenref ( curmark [ 4 ] ) ; 
      curmark [ 4 ] = mem [ p + 1 ] .cint ; 
      incr ( mem [ curmark [ 4 ] ] .hh .v.LH ) ; 
    } 
    if ( mem [ p ] .hh .v.RH == q ) 
    {
      mem [ p ] .hh .v.RH = 0 ; 
      goto lab30 ; 
    } 
    p = mem [ p ] .hh .v.RH ; 
  } 
  lab30: ; 
  q = prunepagetop ( q ) ; 
  p = mem [ v + 5 ] .hh .v.RH ; 
  freenode ( v , 7 ) ; 
  if ( q == 0 ) 
  eqtb [ 7578 + n ] .hh .v.RH = 0 ; 
  else eqtb [ 7578 + n ] .hh .v.RH = vpackage ( q , 0 , 1 , 1073741823L ) ; 
  Result = vpackage ( p , h , 0 , eqtb [ 9736 ] .cint ) ; 
  return(Result) ; 
} 
void printtotals ( ) 
{printtotals_regmem 
  printscaled ( pagesofar [ 1 ] ) ; 
  if ( pagesofar [ 2 ] != 0 ) 
  {
    print ( 310 ) ; 
    printscaled ( pagesofar [ 2 ] ) ; 
    print ( 335 ) ; 
  } 
  if ( pagesofar [ 3 ] != 0 ) 
  {
    print ( 310 ) ; 
    printscaled ( pagesofar [ 3 ] ) ; 
    print ( 309 ) ; 
  } 
  if ( pagesofar [ 4 ] != 0 ) 
  {
    print ( 310 ) ; 
    printscaled ( pagesofar [ 4 ] ) ; 
    print ( 972 ) ; 
  } 
  if ( pagesofar [ 5 ] != 0 ) 
  {
    print ( 310 ) ; 
    printscaled ( pagesofar [ 5 ] ) ; 
    print ( 973 ) ; 
  } 
  if ( pagesofar [ 6 ] != 0 ) 
  {
    print ( 311 ) ; 
    printscaled ( pagesofar [ 6 ] ) ; 
  } 
} 
void zfreezepagespecs ( s ) 
smallnumber s ; 
{freezepagespecs_regmem 
  pagecontents = s ; 
  pagesofar [ 0 ] = eqtb [ 9734 ] .cint ; 
  pagemaxdepth = eqtb [ 9735 ] .cint ; 
  pagesofar [ 7 ] = 0 ; 
  pagesofar [ 1 ] = 0 ; 
  pagesofar [ 2 ] = 0 ; 
  pagesofar [ 3 ] = 0 ; 
  pagesofar [ 4 ] = 0 ; 
  pagesofar [ 5 ] = 0 ; 
  pagesofar [ 6 ] = 0 ; 
  leastpagecost = 1073741823L ; 
	;
#ifdef STAT
  if ( eqtb [ 9196 ] .cint > 0 ) 
  {
    begindiagnostic () ; 
    printnl ( 981 ) ; 
    printscaled ( pagesofar [ 0 ] ) ; 
    print ( 982 ) ; 
    printscaled ( pagemaxdepth ) ; 
    enddiagnostic ( false ) ; 
  } 
#endif /* STAT */
} 
void zboxerror ( n ) 
eightbits n ; 
{boxerror_regmem 
  error () ; 
  begindiagnostic () ; 
  printnl ( 830 ) ; 
  showbox ( eqtb [ 7578 + n ] .hh .v.RH ) ; 
  enddiagnostic ( true ) ; 
  flushnodelist ( eqtb [ 7578 + n ] .hh .v.RH ) ; 
  eqtb [ 7578 + n ] .hh .v.RH = 0 ; 
} 
void zensurevbox ( n ) 
eightbits n ; 
{ensurevbox_regmem 
  halfword p  ; 
  p = eqtb [ 7578 + n ] .hh .v.RH ; 
  if ( p != 0 ) 
  if ( mem [ p ] .hh.b0 == 0 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 983 ) ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 984 ; 
      helpline [ 1 ] = 985 ; 
      helpline [ 0 ] = 986 ; 
    } 
    boxerror ( n ) ; 
  } 
} 
void zfireup ( c ) 
halfword c ; 
{/* 10 */ fireup_regmem 
  halfword p, q, r, s  ; 
  halfword prevp  ; 
  unsigned char n  ; 
  boolean wait  ; 
  integer savevbadness  ; 
  scaled savevfuzz  ; 
  halfword savesplittopskip  ; 
  if ( mem [ bestpagebreak ] .hh.b0 == 12 ) 
  {
    geqworddefine ( 9202 , mem [ bestpagebreak + 1 ] .cint ) ; 
    mem [ bestpagebreak + 1 ] .cint = 10000 ; 
  } 
  else geqworddefine ( 9202 , 10000 ) ; 
  if ( curmark [ 2 ] != 0 ) 
  {
    if ( curmark [ 0 ] != 0 ) 
    deletetokenref ( curmark [ 0 ] ) ; 
    curmark [ 0 ] = curmark [ 2 ] ; 
    incr ( mem [ curmark [ 0 ] ] .hh .v.LH ) ; 
    deletetokenref ( curmark [ 1 ] ) ; 
    curmark [ 1 ] = 0 ; 
  } 
  if ( c == bestpagebreak ) 
  bestpagebreak = 0 ; 
  if ( eqtb [ 7833 ] .hh .v.RH != 0 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 335 ) ; 
    } 
    printesc ( 406 ) ; 
    print ( 997 ) ; 
    {
      helpptr = 2 ; 
      helpline [ 1 ] = 998 ; 
      helpline [ 0 ] = 986 ; 
    } 
    boxerror ( 255 ) ; 
  } 
  insertpenalties = 0 ; 
  savesplittopskip = eqtb [ 6792 ] .hh .v.RH ; 
  if ( eqtb [ 9216 ] .cint <= 0 ) 
  {
    r = mem [ memtop ] .hh .v.RH ; 
    while ( r != memtop ) {
	
      if ( mem [ r + 2 ] .hh .v.LH != 0 ) 
      {
	n = mem [ r ] .hh.b1 ; 
	ensurevbox ( n ) ; 
	if ( eqtb [ 7578 + n ] .hh .v.RH == 0 ) 
	eqtb [ 7578 + n ] .hh .v.RH = newnullbox () ; 
	p = eqtb [ 7578 + n ] .hh .v.RH + 5 ; 
	while ( mem [ p ] .hh .v.RH != 0 ) p = mem [ p ] .hh .v.RH ; 
	mem [ r + 2 ] .hh .v.RH = p ; 
      } 
      r = mem [ r ] .hh .v.RH ; 
    } 
  } 
  q = memtop - 4 ; 
  mem [ q ] .hh .v.RH = 0 ; 
  prevp = memtop - 2 ; 
  p = mem [ prevp ] .hh .v.RH ; 
  while ( p != bestpagebreak ) {
      
    if ( mem [ p ] .hh.b0 == 3 ) 
    {
      if ( eqtb [ 9216 ] .cint <= 0 ) 
      {
	r = mem [ memtop ] .hh .v.RH ; 
	while ( mem [ r ] .hh.b1 != mem [ p ] .hh.b1 ) r = mem [ r ] .hh .v.RH 
	; 
	if ( mem [ r + 2 ] .hh .v.LH == 0 ) 
	wait = true ; 
	else {
	    
	  wait = false ; 
	  s = mem [ r + 2 ] .hh .v.RH ; 
	  mem [ s ] .hh .v.RH = mem [ p + 4 ] .hh .v.LH ; 
	  if ( mem [ r + 2 ] .hh .v.LH == p ) 
	  {
	    if ( mem [ r ] .hh.b0 == 1 ) 
	    if ( ( mem [ r + 1 ] .hh .v.LH == p ) && ( mem [ r + 1 ] .hh .v.RH 
	    != 0 ) ) 
	    {
	      while ( mem [ s ] .hh .v.RH != mem [ r + 1 ] .hh .v.RH ) s = mem 
	      [ s ] .hh .v.RH ; 
	      mem [ s ] .hh .v.RH = 0 ; 
	      eqtb [ 6792 ] .hh .v.RH = mem [ p + 4 ] .hh .v.RH ; 
	      mem [ p + 4 ] .hh .v.LH = prunepagetop ( mem [ r + 1 ] .hh .v.RH 
	      ) ; 
	      if ( mem [ p + 4 ] .hh .v.LH != 0 ) 
	      {
		tempptr = vpackage ( mem [ p + 4 ] .hh .v.LH , 0 , 1 , 
		1073741823L ) ; 
		mem [ p + 3 ] .cint = mem [ tempptr + 3 ] .cint + mem [ 
		tempptr + 2 ] .cint ; 
		freenode ( tempptr , 7 ) ; 
		wait = true ; 
	      } 
	    } 
	    mem [ r + 2 ] .hh .v.LH = 0 ; 
	    n = mem [ r ] .hh.b1 ; 
	    tempptr = mem [ eqtb [ 7578 + n ] .hh .v.RH + 5 ] .hh .v.RH ; 
	    freenode ( eqtb [ 7578 + n ] .hh .v.RH , 7 ) ; 
	    eqtb [ 7578 + n ] .hh .v.RH = vpackage ( tempptr , 0 , 1 , 
	    1073741823L ) ; 
	  } 
	  else {
	      
	    while ( mem [ s ] .hh .v.RH != 0 ) s = mem [ s ] .hh .v.RH ; 
	    mem [ r + 2 ] .hh .v.RH = s ; 
	  } 
	} 
	mem [ prevp ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
	mem [ p ] .hh .v.RH = 0 ; 
	if ( wait ) 
	{
	  mem [ q ] .hh .v.RH = p ; 
	  q = p ; 
	  incr ( insertpenalties ) ; 
	} 
	else {
	    
	  deleteglueref ( mem [ p + 4 ] .hh .v.RH ) ; 
	  freenode ( p , 5 ) ; 
	} 
	p = prevp ; 
      } 
    } 
    else if ( mem [ p ] .hh.b0 == 4 ) 
    {
      if ( curmark [ 1 ] == 0 ) 
      {
	curmark [ 1 ] = mem [ p + 1 ] .cint ; 
	incr ( mem [ curmark [ 1 ] ] .hh .v.LH ) ; 
      } 
      if ( curmark [ 2 ] != 0 ) 
      deletetokenref ( curmark [ 2 ] ) ; 
      curmark [ 2 ] = mem [ p + 1 ] .cint ; 
      incr ( mem [ curmark [ 2 ] ] .hh .v.LH ) ; 
    } 
    prevp = p ; 
    p = mem [ prevp ] .hh .v.RH ; 
  } 
  eqtb [ 6792 ] .hh .v.RH = savesplittopskip ; 
  if ( p != 0 ) 
  {
    if ( mem [ memtop - 1 ] .hh .v.RH == 0 ) 
    if ( nestptr == 0 ) 
    curlist .tailfield = pagetail ; 
    else nest [ 0 ] .tailfield = pagetail ; 
    mem [ pagetail ] .hh .v.RH = mem [ memtop - 1 ] .hh .v.RH ; 
    mem [ memtop - 1 ] .hh .v.RH = p ; 
    mem [ prevp ] .hh .v.RH = 0 ; 
  } 
  savevbadness = eqtb [ 9190 ] .cint ; 
  eqtb [ 9190 ] .cint = 10000 ; 
  savevfuzz = eqtb [ 9739 ] .cint ; 
  eqtb [ 9739 ] .cint = 1073741823L ; 
  eqtb [ 7833 ] .hh .v.RH = vpackage ( mem [ memtop - 2 ] .hh .v.RH , bestsize 
  , 0 , pagemaxdepth ) ; 
  eqtb [ 9190 ] .cint = savevbadness ; 
  eqtb [ 9739 ] .cint = savevfuzz ; 
  if ( lastglue != 65535L ) 
  deleteglueref ( lastglue ) ; 
  pagecontents = 0 ; 
  pagetail = memtop - 2 ; 
  mem [ memtop - 2 ] .hh .v.RH = 0 ; 
  lastglue = 65535L ; 
  lastpenalty = 0 ; 
  lastkern = 0 ; 
  pagesofar [ 7 ] = 0 ; 
  pagemaxdepth = 0 ; 
  if ( q != memtop - 4 ) 
  {
    mem [ memtop - 2 ] .hh .v.RH = mem [ memtop - 4 ] .hh .v.RH ; 
    pagetail = q ; 
  } 
  r = mem [ memtop ] .hh .v.RH ; 
  while ( r != memtop ) {
      
    q = mem [ r ] .hh .v.RH ; 
    freenode ( r , 4 ) ; 
    r = q ; 
  } 
  mem [ memtop ] .hh .v.RH = memtop ; 
  if ( ( curmark [ 0 ] != 0 ) && ( curmark [ 1 ] == 0 ) ) 
  {
    curmark [ 1 ] = curmark [ 0 ] ; 
    incr ( mem [ curmark [ 0 ] ] .hh .v.LH ) ; 
  } 
  if ( eqtb [ 7313 ] .hh .v.RH != 0 ) 
  if ( deadcycles >= eqtb [ 9203 ] .cint ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 999 ) ; 
    } 
    printint ( deadcycles ) ; 
    print ( 1000 ) ; 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1001 ; 
      helpline [ 1 ] = 1002 ; 
      helpline [ 0 ] = 1003 ; 
    } 
    error () ; 
  } 
  else {
      
    outputactive = true ; 
    incr ( deadcycles ) ; 
    pushnest () ; 
    curlist .modefield = -1 ; 
    curlist .auxfield .cint = -65536000L ; 
    curlist .mlfield = - (integer) line ; 
    begintokenlist ( eqtb [ 7313 ] .hh .v.RH , 6 ) ; 
    newsavelevel ( 8 ) ; 
    normalparagraph () ; 
    scanleftbrace () ; 
    return ; 
  } 
  {
    if ( mem [ memtop - 2 ] .hh .v.RH != 0 ) 
    {
      if ( mem [ memtop - 1 ] .hh .v.RH == 0 ) 
      if ( nestptr == 0 ) 
      curlist .tailfield = pagetail ; 
      else nest [ 0 ] .tailfield = pagetail ; 
      else mem [ pagetail ] .hh .v.RH = mem [ memtop - 1 ] .hh .v.RH ; 
      mem [ memtop - 1 ] .hh .v.RH = mem [ memtop - 2 ] .hh .v.RH ; 
      mem [ memtop - 2 ] .hh .v.RH = 0 ; 
      pagetail = memtop - 2 ; 
    } 
    shipout ( eqtb [ 7833 ] .hh .v.RH ) ; 
    eqtb [ 7833 ] .hh .v.RH = 0 ; 
  } 
} 
void buildpage ( ) 
{/* 10 30 31 22 80 90 */ buildpage_regmem 
  halfword p  ; 
  halfword q, r  ; 
  integer b, c  ; 
  integer pi  ; 
  unsigned char n  ; 
  scaled delta, h, w  ; 
  if ( ( mem [ memtop - 1 ] .hh .v.RH == 0 ) || outputactive ) 
  return ; 
  do {
      lab22: p = mem [ memtop - 1 ] .hh .v.RH ; 
    if ( lastglue != 65535L ) 
    deleteglueref ( lastglue ) ; 
    lastpenalty = 0 ; 
    lastkern = 0 ; 
    if ( mem [ p ] .hh.b0 == 10 ) 
    {
      lastglue = mem [ p + 1 ] .hh .v.LH ; 
      incr ( mem [ lastglue ] .hh .v.RH ) ; 
    } 
    else {
	
      lastglue = 65535L ; 
      if ( mem [ p ] .hh.b0 == 12 ) 
      lastpenalty = mem [ p + 1 ] .cint ; 
      else if ( mem [ p ] .hh.b0 == 11 ) 
      lastkern = mem [ p + 1 ] .cint ; 
    } 
    switch ( mem [ p ] .hh.b0 ) 
    {case 0 : 
    case 1 : 
    case 2 : 
      if ( pagecontents < 2 ) 
      {
	if ( pagecontents == 0 ) 
	freezepagespecs ( 2 ) ; 
	else pagecontents = 2 ; 
	q = newskipparam ( 9 ) ; 
	if ( mem [ tempptr + 1 ] .cint > mem [ p + 3 ] .cint ) 
	mem [ tempptr + 1 ] .cint = mem [ tempptr + 1 ] .cint - mem [ p + 3 ] 
	.cint ; 
	else mem [ tempptr + 1 ] .cint = 0 ; 
	mem [ q ] .hh .v.RH = p ; 
	mem [ memtop - 1 ] .hh .v.RH = q ; 
	goto lab22 ; 
      } 
      else {
	  
	pagesofar [ 1 ] = pagesofar [ 1 ] + pagesofar [ 7 ] + mem [ p + 3 ] 
	.cint ; 
	pagesofar [ 7 ] = mem [ p + 2 ] .cint ; 
	goto lab80 ; 
      } 
      break ; 
    case 8 : 
      goto lab80 ; 
      break ; 
    case 10 : 
      if ( pagecontents < 2 ) 
      goto lab31 ; 
      else if ( ( mem [ pagetail ] .hh.b0 < 9 ) ) 
      pi = 0 ; 
      else goto lab90 ; 
      break ; 
    case 11 : 
      if ( pagecontents < 2 ) 
      goto lab31 ; 
      else if ( mem [ p ] .hh .v.RH == 0 ) 
      return ; 
      else if ( mem [ mem [ p ] .hh .v.RH ] .hh.b0 == 10 ) 
      pi = 0 ; 
      else goto lab90 ; 
      break ; 
    case 12 : 
      if ( pagecontents < 2 ) 
      goto lab31 ; 
      else pi = mem [ p + 1 ] .cint ; 
      break ; 
    case 4 : 
      goto lab80 ; 
      break ; 
    case 3 : 
      {
	if ( pagecontents == 0 ) 
	freezepagespecs ( 1 ) ; 
	n = mem [ p ] .hh.b1 ; 
	r = memtop ; 
	while ( n >= mem [ mem [ r ] .hh .v.RH ] .hh.b1 ) r = mem [ r ] .hh 
	.v.RH ; 
	n = n ; 
	if ( mem [ r ] .hh.b1 != n ) 
	{
	  q = getnode ( 4 ) ; 
	  mem [ q ] .hh .v.RH = mem [ r ] .hh .v.RH ; 
	  mem [ r ] .hh .v.RH = q ; 
	  r = q ; 
	  mem [ r ] .hh.b1 = n ; 
	  mem [ r ] .hh.b0 = 0 ; 
	  ensurevbox ( n ) ; 
	  if ( eqtb [ 7578 + n ] .hh .v.RH == 0 ) 
	  mem [ r + 3 ] .cint = 0 ; 
	  else mem [ r + 3 ] .cint = mem [ eqtb [ 7578 + n ] .hh .v.RH + 3 ] 
	  .cint + mem [ eqtb [ 7578 + n ] .hh .v.RH + 2 ] .cint ; 
	  mem [ r + 2 ] .hh .v.LH = 0 ; 
	  q = eqtb [ 6800 + n ] .hh .v.RH ; 
	  if ( eqtb [ 9218 + n ] .cint == 1000 ) 
	  h = mem [ r + 3 ] .cint ; 
	  else h = xovern ( mem [ r + 3 ] .cint , 1000 ) * eqtb [ 9218 + n ] 
	  .cint ; 
	  pagesofar [ 0 ] = pagesofar [ 0 ] - h - mem [ q + 1 ] .cint ; 
	  pagesofar [ 2 + mem [ q ] .hh.b0 ] = pagesofar [ 2 + mem [ q ] 
	  .hh.b0 ] + mem [ q + 2 ] .cint ; 
	  pagesofar [ 6 ] = pagesofar [ 6 ] + mem [ q + 3 ] .cint ; 
	  if ( ( mem [ q ] .hh.b1 != 0 ) && ( mem [ q + 3 ] .cint != 0 ) ) 
	  {
	    {
	      if ( interaction == 3 ) 
	      ; 
	      printnl ( 262 ) ; 
	      print ( 992 ) ; 
	    } 
	    printesc ( 392 ) ; 
	    printint ( n ) ; 
	    {
	      helpptr = 3 ; 
	      helpline [ 2 ] = 993 ; 
	      helpline [ 1 ] = 994 ; 
	      helpline [ 0 ] = 916 ; 
	    } 
	    error () ; 
	  } 
	} 
	if ( mem [ r ] .hh.b0 == 1 ) 
	insertpenalties = insertpenalties + mem [ p + 1 ] .cint ; 
	else {
	    
	  mem [ r + 2 ] .hh .v.RH = p ; 
	  delta = pagesofar [ 0 ] - pagesofar [ 1 ] - pagesofar [ 7 ] + 
	  pagesofar [ 6 ] ; 
	  if ( eqtb [ 9218 + n ] .cint == 1000 ) 
	  h = mem [ p + 3 ] .cint ; 
	  else h = xovern ( mem [ p + 3 ] .cint , 1000 ) * eqtb [ 9218 + n ] 
	  .cint ; 
	  if ( ( ( h <= 0 ) || ( h <= delta ) ) && ( mem [ p + 3 ] .cint + mem 
	  [ r + 3 ] .cint <= eqtb [ 9751 + n ] .cint ) ) 
	  {
	    pagesofar [ 0 ] = pagesofar [ 0 ] - h ; 
	    mem [ r + 3 ] .cint = mem [ r + 3 ] .cint + mem [ p + 3 ] .cint ; 
	  } 
	  else {
	      
	    if ( eqtb [ 9218 + n ] .cint <= 0 ) 
	    w = 1073741823L ; 
	    else {
		
	      w = pagesofar [ 0 ] - pagesofar [ 1 ] - pagesofar [ 7 ] ; 
	      if ( eqtb [ 9218 + n ] .cint != 1000 ) 
	      w = xovern ( w , eqtb [ 9218 + n ] .cint ) * 1000 ; 
	    } 
	    if ( w > eqtb [ 9751 + n ] .cint - mem [ r + 3 ] .cint ) 
	    w = eqtb [ 9751 + n ] .cint - mem [ r + 3 ] .cint ; 
	    q = vertbreak ( mem [ p + 4 ] .hh .v.LH , w , mem [ p + 2 ] .cint 
	    ) ; 
	    mem [ r + 3 ] .cint = mem [ r + 3 ] .cint + bestheightplusdepth ; 
	;
#ifdef STAT
	    if ( eqtb [ 9196 ] .cint > 0 ) 
	    {
	      begindiagnostic () ; 
	      printnl ( 995 ) ; 
	      printint ( n ) ; 
	      print ( 996 ) ; 
	      printscaled ( w ) ; 
	      printchar ( 44 ) ; 
	      printscaled ( bestheightplusdepth ) ; 
	      print ( 925 ) ; 
	      if ( q == 0 ) 
	      printint ( -10000 ) ; 
	      else if ( mem [ q ] .hh.b0 == 12 ) 
	      printint ( mem [ q + 1 ] .cint ) ; 
	      else printchar ( 48 ) ; 
	      enddiagnostic ( false ) ; 
	    } 
#endif /* STAT */
	    if ( eqtb [ 9218 + n ] .cint != 1000 ) 
	    bestheightplusdepth = xovern ( bestheightplusdepth , 1000 ) * eqtb 
	    [ 9218 + n ] .cint ; 
	    pagesofar [ 0 ] = pagesofar [ 0 ] - bestheightplusdepth ; 
	    mem [ r ] .hh.b0 = 1 ; 
	    mem [ r + 1 ] .hh .v.RH = q ; 
	    mem [ r + 1 ] .hh .v.LH = p ; 
	    if ( q == 0 ) 
	    insertpenalties = insertpenalties - 10000 ; 
	    else if ( mem [ q ] .hh.b0 == 12 ) 
	    insertpenalties = insertpenalties + mem [ q + 1 ] .cint ; 
	  } 
	} 
	goto lab80 ; 
      } 
      break ; 
      default: 
      confusion ( 987 ) ; 
      break ; 
    } 
    if ( pi < 10000 ) 
    {
      if ( pagesofar [ 1 ] < pagesofar [ 0 ] ) 
      if ( ( pagesofar [ 3 ] != 0 ) || ( pagesofar [ 4 ] != 0 ) || ( pagesofar 
      [ 5 ] != 0 ) ) 
      b = 0 ; 
      else b = badness ( pagesofar [ 0 ] - pagesofar [ 1 ] , pagesofar [ 2 ] ) 
      ; 
      else if ( pagesofar [ 1 ] - pagesofar [ 0 ] > pagesofar [ 6 ] ) 
      b = 1073741823L ; 
      else b = badness ( pagesofar [ 1 ] - pagesofar [ 0 ] , pagesofar [ 6 ] ) 
      ; 
      if ( b < 1073741823L ) 
      if ( pi <= -10000 ) 
      c = pi ; 
      else if ( b < 10000 ) 
      c = b + pi + insertpenalties ; 
      else c = 100000L ; 
      else c = b ; 
      if ( insertpenalties >= 10000 ) 
      c = 1073741823L ; 
	;
#ifdef STAT
      if ( eqtb [ 9196 ] .cint > 0 ) 
      {
	begindiagnostic () ; 
	printnl ( 37 ) ; 
	print ( 921 ) ; 
	printtotals () ; 
	print ( 990 ) ; 
	printscaled ( pagesofar [ 0 ] ) ; 
	print ( 924 ) ; 
	if ( b == 1073741823L ) 
	printchar ( 42 ) ; 
	else printint ( b ) ; 
	print ( 925 ) ; 
	printint ( pi ) ; 
	print ( 991 ) ; 
	if ( c == 1073741823L ) 
	printchar ( 42 ) ; 
	else printint ( c ) ; 
	if ( c <= leastpagecost ) 
	printchar ( 35 ) ; 
	enddiagnostic ( false ) ; 
      } 
#endif /* STAT */
      if ( c <= leastpagecost ) 
      {
	bestpagebreak = p ; 
	bestsize = pagesofar [ 0 ] ; 
	leastpagecost = c ; 
	r = mem [ memtop ] .hh .v.RH ; 
	while ( r != memtop ) {
	    
	  mem [ r + 2 ] .hh .v.LH = mem [ r + 2 ] .hh .v.RH ; 
	  r = mem [ r ] .hh .v.RH ; 
	} 
      } 
      if ( ( c == 1073741823L ) || ( pi <= -10000 ) ) 
      {
	fireup ( p ) ; 
	if ( outputactive ) 
	return ; 
	goto lab30 ; 
      } 
    } 
    if ( ( mem [ p ] .hh.b0 < 10 ) || ( mem [ p ] .hh.b0 > 11 ) ) 
    goto lab80 ; 
    lab90: if ( mem [ p ] .hh.b0 == 11 ) 
    q = p ; 
    else {
	
      q = mem [ p + 1 ] .hh .v.LH ; 
      pagesofar [ 2 + mem [ q ] .hh.b0 ] = pagesofar [ 2 + mem [ q ] .hh.b0 ] 
      + mem [ q + 2 ] .cint ; 
      pagesofar [ 6 ] = pagesofar [ 6 ] + mem [ q + 3 ] .cint ; 
      if ( ( mem [ q ] .hh.b1 != 0 ) && ( mem [ q + 3 ] .cint != 0 ) ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 988 ) ; 
	} 
	{
	  helpptr = 4 ; 
	  helpline [ 3 ] = 989 ; 
	  helpline [ 2 ] = 957 ; 
	  helpline [ 1 ] = 958 ; 
	  helpline [ 0 ] = 916 ; 
	} 
	error () ; 
	r = newspec ( q ) ; 
	mem [ r ] .hh.b1 = 0 ; 
	deleteglueref ( q ) ; 
	mem [ p + 1 ] .hh .v.LH = r ; 
	q = r ; 
      } 
    } 
    pagesofar [ 1 ] = pagesofar [ 1 ] + pagesofar [ 7 ] + mem [ q + 1 ] .cint 
    ; 
    pagesofar [ 7 ] = 0 ; 
    lab80: if ( pagesofar [ 7 ] > pagemaxdepth ) 
    {
      pagesofar [ 1 ] = pagesofar [ 1 ] + pagesofar [ 7 ] - pagemaxdepth ; 
      pagesofar [ 7 ] = pagemaxdepth ; 
    } 
    mem [ pagetail ] .hh .v.RH = p ; 
    pagetail = p ; 
    mem [ memtop - 1 ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
    mem [ p ] .hh .v.RH = 0 ; 
    goto lab30 ; 
    lab31: mem [ memtop - 1 ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
    mem [ p ] .hh .v.RH = 0 ; 
    flushnodelist ( p ) ; 
    lab30: ; 
  } while ( ! ( mem [ memtop - 1 ] .hh .v.RH == 0 ) ) ; 
  if ( nestptr == 0 ) 
  curlist .tailfield = memtop - 1 ; 
  else nest [ 0 ] .tailfield = memtop - 1 ; 
} 
void appspace ( ) 
{appspace_regmem 
  halfword q  ; 
  if ( ( curlist .auxfield .hh .v.LH >= 2000 ) && ( eqtb [ 6795 ] .hh .v.RH != 
  0 ) ) 
  q = newparamglue ( 13 ) ; 
  else {
      
    if ( eqtb [ 6794 ] .hh .v.RH != 0 ) 
    mainp = eqtb [ 6794 ] .hh .v.RH ; 
    else {
	
      mainp = fontglue [ eqtb [ 7834 ] .hh .v.RH ] ; 
      if ( mainp == 0 ) 
      {
	mainp = newspec ( 0 ) ; 
	maink = parambase [ eqtb [ 7834 ] .hh .v.RH ] + 2 ; 
	mem [ mainp + 1 ] .cint = fontinfo [ maink ] .cint ; 
	mem [ mainp + 2 ] .cint = fontinfo [ maink + 1 ] .cint ; 
	mem [ mainp + 3 ] .cint = fontinfo [ maink + 2 ] .cint ; 
	fontglue [ eqtb [ 7834 ] .hh .v.RH ] = mainp ; 
      } 
    } 
    mainp = newspec ( mainp ) ; 
    if ( curlist .auxfield .hh .v.LH >= 2000 ) 
    mem [ mainp + 1 ] .cint = mem [ mainp + 1 ] .cint + fontinfo [ 7 + 
    parambase [ eqtb [ 7834 ] .hh .v.RH ] ] .cint ; 
    mem [ mainp + 2 ] .cint = xnoverd ( mem [ mainp + 2 ] .cint , curlist 
    .auxfield .hh .v.LH , 1000 ) ; 
    mem [ mainp + 3 ] .cint = xnoverd ( mem [ mainp + 3 ] .cint , 1000 , 
    curlist .auxfield .hh .v.LH ) ; 
    q = newglue ( mainp ) ; 
    mem [ mainp ] .hh .v.RH = 0 ; 
  } 
  mem [ curlist .tailfield ] .hh .v.RH = q ; 
  curlist .tailfield = q ; 
} 
void insertdollarsign ( ) 
{insertdollarsign_regmem 
  backinput () ; 
  curtok = 804 ; 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 1011 ) ; 
  } 
  {
    helpptr = 2 ; 
    helpline [ 1 ] = 1012 ; 
    helpline [ 0 ] = 1013 ; 
  } 
  inserror () ; 
} 
void youcant ( ) 
{youcant_regmem 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 682 ) ; 
  } 
  printcmdchr ( curcmd , curchr ) ; 
  print ( 1014 ) ; 
  printmode ( curlist .modefield ) ; 
} 
void reportillegalcase ( ) 
{reportillegalcase_regmem 
  youcant () ; 
  {
    helpptr = 4 ; 
    helpline [ 3 ] = 1015 ; 
    helpline [ 2 ] = 1016 ; 
    helpline [ 1 ] = 1017 ; 
    helpline [ 0 ] = 1018 ; 
  } 
  error () ; 
} 
boolean privileged ( ) 
{register boolean Result; privileged_regmem 
  if ( curlist .modefield > 0 ) 
  Result = true ; 
  else {
      
    reportillegalcase () ; 
    Result = false ; 
  } 
  return(Result) ; 
} 
boolean itsallover ( ) 
{/* 10 */ register boolean Result; itsallover_regmem 
  if ( privileged () ) 
  {
    if ( ( memtop - 2 == pagetail ) && ( curlist .headfield == curlist 
    .tailfield ) && ( deadcycles == 0 ) ) 
    {
      Result = true ; 
      return(Result) ; 
    } 
    backinput () ; 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newnullbox () ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    mem [ curlist .tailfield + 1 ] .cint = eqtb [ 9733 ] .cint ; 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newglue ( 8 ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( -1073741824L ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    buildpage () ; 
  } 
  Result = false ; 
  return(Result) ; 
} 
void appendglue ( ) 
{appendglue_regmem 
  smallnumber s  ; 
  s = curchr ; 
  switch ( s ) 
  {case 0 : 
    curval = 4 ; 
    break ; 
  case 1 : 
    curval = 8 ; 
    break ; 
  case 2 : 
    curval = 12 ; 
    break ; 
  case 3 : 
    curval = 16 ; 
    break ; 
  case 4 : 
    scanglue ( 2 ) ; 
    break ; 
  case 5 : 
    scanglue ( 3 ) ; 
    break ; 
  } 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newglue ( curval ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  if ( s >= 4 ) 
  {
    decr ( mem [ curval ] .hh .v.RH ) ; 
    if ( s > 4 ) 
    mem [ curlist .tailfield ] .hh.b1 = 99 ; 
  } 
} 
void appendkern ( ) 
{appendkern_regmem 
  quarterword s  ; 
  s = curchr ; 
  scandimen ( s == 99 , false , false ) ; 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newkern ( curval ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  mem [ curlist .tailfield ] .hh.b1 = s ; 
} 
void offsave ( ) 
{offsave_regmem 
  halfword p  ; 
  if ( curgroup == 0 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 773 ) ; 
    } 
    printcmdchr ( curcmd , curchr ) ; 
    {
      helpptr = 1 ; 
      helpline [ 0 ] = 1037 ; 
    } 
    error () ; 
  } 
  else {
      
    backinput () ; 
    p = getavail () ; 
    mem [ memtop - 3 ] .hh .v.RH = p ; 
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 622 ) ; 
    } 
    switch ( curgroup ) 
    {case 14 : 
      {
	mem [ p ] .hh .v.LH = 10611 ; 
	printesc ( 513 ) ; 
      } 
      break ; 
    case 15 : 
      {
	mem [ p ] .hh .v.LH = 804 ; 
	printchar ( 36 ) ; 
      } 
      break ; 
    case 16 : 
      {
	mem [ p ] .hh .v.LH = 10612 ; 
	mem [ p ] .hh .v.RH = getavail () ; 
	p = mem [ p ] .hh .v.RH ; 
	mem [ p ] .hh .v.LH = 3118 ; 
	printesc ( 1036 ) ; 
      } 
      break ; 
      default: 
      {
	mem [ p ] .hh .v.LH = 637 ; 
	printchar ( 125 ) ; 
      } 
      break ; 
    } 
    print ( 623 ) ; 
    begintokenlist ( mem [ memtop - 3 ] .hh .v.RH , 4 ) ; 
    {
      helpptr = 5 ; 
      helpline [ 4 ] = 1031 ; 
      helpline [ 3 ] = 1032 ; 
      helpline [ 2 ] = 1033 ; 
      helpline [ 1 ] = 1034 ; 
      helpline [ 0 ] = 1035 ; 
    } 
    error () ; 
  } 
} 
void extrarightbrace ( ) 
{extrarightbrace_regmem 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 1042 ) ; 
  } 
  switch ( curgroup ) 
  {case 14 : 
    printesc ( 513 ) ; 
    break ; 
  case 15 : 
    printchar ( 36 ) ; 
    break ; 
  case 16 : 
    printesc ( 871 ) ; 
    break ; 
  } 
  {
    helpptr = 5 ; 
    helpline [ 4 ] = 1043 ; 
    helpline [ 3 ] = 1044 ; 
    helpline [ 2 ] = 1045 ; 
    helpline [ 1 ] = 1046 ; 
    helpline [ 0 ] = 1047 ; 
  } 
  error () ; 
  incr ( alignstate ) ; 
} 
void normalparagraph ( ) 
{normalparagraph_regmem 
  if ( eqtb [ 9182 ] .cint != 0 ) 
  eqworddefine ( 9182 , 0 ) ; 
  if ( eqtb [ 9747 ] .cint != 0 ) 
  eqworddefine ( 9747 , 0 ) ; 
  if ( eqtb [ 9204 ] .cint != 1 ) 
  eqworddefine ( 9204 , 1 ) ; 
  if ( eqtb [ 7312 ] .hh .v.RH != 0 ) 
  eqdefine ( 7312 , 118 , 0 ) ; 
} 
void zboxend ( boxcontext ) 
integer boxcontext ; 
{boxend_regmem 
  halfword p  ; 
  if ( boxcontext < 1073741824L ) 
  {
    if ( curbox != 0 ) 
    {
      mem [ curbox + 4 ] .cint = boxcontext ; 
      if ( abs ( curlist .modefield ) == 1 ) 
      {
	appendtovlist ( curbox ) ; 
	if ( adjusttail != 0 ) 
	{
	  if ( memtop - 5 != adjusttail ) 
	  {
	    mem [ curlist .tailfield ] .hh .v.RH = mem [ memtop - 5 ] .hh 
	    .v.RH ; 
	    curlist .tailfield = adjusttail ; 
	  } 
	  adjusttail = 0 ; 
	} 
	if ( curlist .modefield > 0 ) 
	buildpage () ; 
      } 
      else {
	  
	if ( abs ( curlist .modefield ) == 102 ) 
	curlist .auxfield .hh .v.LH = 1000 ; 
	else {
	    
	  p = newnoad () ; 
	  mem [ p + 1 ] .hh .v.RH = 2 ; 
	  mem [ p + 1 ] .hh .v.LH = curbox ; 
	  curbox = p ; 
	} 
	mem [ curlist .tailfield ] .hh .v.RH = curbox ; 
	curlist .tailfield = curbox ; 
      } 
    } 
  } 
  else if ( boxcontext < 1073742336L ) 
  if ( boxcontext < 1073742080L ) 
  eqdefine ( -1073734246L + boxcontext , 119 , curbox ) ; 
  else geqdefine ( -1073734502L + boxcontext , 119 , curbox ) ; 
  else if ( curbox != 0 ) 
  if ( boxcontext > 1073742336L ) 
  {
    do {
	getxtoken () ; 
    } while ( ! ( ( curcmd != 10 ) && ( curcmd != 0 ) ) ) ; 
    if ( ( ( curcmd == 26 ) && ( abs ( curlist .modefield ) != 1 ) ) || ( ( 
    curcmd == 27 ) && ( abs ( curlist .modefield ) == 1 ) ) || ( ( curcmd == 
    28 ) && ( abs ( curlist .modefield ) == 203 ) ) ) 
    {
      appendglue () ; 
      mem [ curlist .tailfield ] .hh.b1 = boxcontext - ( 1073742237L ) ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = curbox ; 
    } 
    else {
	
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1060 ) ; 
      } 
      {
	helpptr = 3 ; 
	helpline [ 2 ] = 1061 ; 
	helpline [ 1 ] = 1062 ; 
	helpline [ 0 ] = 1063 ; 
      } 
      backerror () ; 
      flushnodelist ( curbox ) ; 
    } 
  } 
  else shipout ( curbox ) ; 
} 
void zbeginbox ( boxcontext ) 
integer boxcontext ; 
{/* 10 30 */ beginbox_regmem 
  halfword p, q  ; 
  quarterword m  ; 
  halfword k  ; 
  eightbits n  ; 
  switch ( curchr ) 
  {case 0 : 
    {
      scaneightbitint () ; 
      curbox = eqtb [ 7578 + curval ] .hh .v.RH ; 
      eqtb [ 7578 + curval ] .hh .v.RH = 0 ; 
    } 
    break ; 
  case 1 : 
    {
      scaneightbitint () ; 
      curbox = copynodelist ( eqtb [ 7578 + curval ] .hh .v.RH ) ; 
    } 
    break ; 
  case 2 : 
    {
      curbox = 0 ; 
      if ( abs ( curlist .modefield ) == 203 ) 
      {
	youcant () ; 
	{
	  helpptr = 1 ; 
	  helpline [ 0 ] = 1064 ; 
	} 
	error () ; 
      } 
      else if ( ( curlist .modefield == 1 ) && ( curlist .headfield == curlist 
      .tailfield ) ) 
      {
	youcant () ; 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1065 ; 
	  helpline [ 0 ] = 1066 ; 
	} 
	error () ; 
      } 
      else {
	  
	if ( ! ( curlist .tailfield >= himemmin ) ) 
	if ( ( mem [ curlist .tailfield ] .hh.b0 == 0 ) || ( mem [ curlist 
	.tailfield ] .hh.b0 == 1 ) ) 
	{
	  q = curlist .headfield ; 
	  do {
	      p = q ; 
	    if ( ! ( q >= himemmin ) ) 
	    if ( mem [ q ] .hh.b0 == 7 ) 
	    {
	      {register integer for_end; m = 1 ; for_end = mem [ q ] .hh.b1 
	      ; if ( m <= for_end) do 
		p = mem [ p ] .hh .v.RH ; 
	      while ( m++ < for_end ) ; } 
	      if ( p == curlist .tailfield ) 
	      goto lab30 ; 
	    } 
	    q = mem [ p ] .hh .v.RH ; 
	  } while ( ! ( q == curlist .tailfield ) ) ; 
	  curbox = curlist .tailfield ; 
	  mem [ curbox + 4 ] .cint = 0 ; 
	  curlist .tailfield = p ; 
	  mem [ p ] .hh .v.RH = 0 ; 
	  lab30: ; 
	} 
      } 
    } 
    break ; 
  case 3 : 
    {
      scaneightbitint () ; 
      n = curval ; 
      if ( ! scankeyword ( 836 ) ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1067 ) ; 
	} 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1068 ; 
	  helpline [ 0 ] = 1069 ; 
	} 
	error () ; 
      } 
      scandimen ( false , false , false ) ; 
      curbox = vsplit ( n , curval ) ; 
    } 
    break ; 
    default: 
    {
      k = curchr - 4 ; 
      savestack [ saveptr + 0 ] .cint = boxcontext ; 
      if ( k == 102 ) 
      if ( ( boxcontext < 1073741824L ) && ( abs ( curlist .modefield ) == 1 ) 
      ) 
      scanspec ( 3 , true ) ; 
      else scanspec ( 2 , true ) ; 
      else {
	  
	if ( k == 1 ) 
	scanspec ( 4 , true ) ; 
	else {
	    
	  scanspec ( 5 , true ) ; 
	  k = 1 ; 
	} 
	normalparagraph () ; 
      } 
      pushnest () ; 
      curlist .modefield = - (integer) k ; 
      if ( k == 1 ) 
      {
	curlist .auxfield .cint = -65536000L ; 
	if ( eqtb [ 7318 ] .hh .v.RH != 0 ) 
	begintokenlist ( eqtb [ 7318 ] .hh .v.RH , 11 ) ; 
      } 
      else {
	  
	curlist .auxfield .hh .v.LH = 1000 ; 
	if ( eqtb [ 7317 ] .hh .v.RH != 0 ) 
	begintokenlist ( eqtb [ 7317 ] .hh .v.RH , 10 ) ; 
      } 
      return ; 
    } 
    break ; 
  } 
  boxend ( boxcontext ) ; 
} 
void zscanbox ( boxcontext ) 
integer boxcontext ; 
{scanbox_regmem 
  do {
      getxtoken () ; 
  } while ( ! ( ( curcmd != 10 ) && ( curcmd != 0 ) ) ) ; 
  if ( curcmd == 20 ) 
  beginbox ( boxcontext ) ; 
  else if ( ( boxcontext >= 1073742337L ) && ( ( curcmd == 36 ) || ( curcmd == 
  35 ) ) ) 
  {
    curbox = scanrulespec () ; 
    boxend ( boxcontext ) ; 
  } 
  else {
      
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1070 ) ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1071 ; 
      helpline [ 1 ] = 1072 ; 
      helpline [ 0 ] = 1073 ; 
    } 
    backerror () ; 
  } 
} 
void zpackage ( c ) 
smallnumber c ; 
{package_regmem 
  scaled h  ; 
  halfword p  ; 
  scaled d  ; 
  d = eqtb [ 9737 ] .cint ; 
  unsave () ; 
  saveptr = saveptr - 3 ; 
  if ( curlist .modefield == -102 ) 
  curbox = hpack ( mem [ curlist .headfield ] .hh .v.RH , savestack [ saveptr 
  + 2 ] .cint , savestack [ saveptr + 1 ] .cint ) ; 
  else {
      
    curbox = vpackage ( mem [ curlist .headfield ] .hh .v.RH , savestack [ 
    saveptr + 2 ] .cint , savestack [ saveptr + 1 ] .cint , d ) ; 
    if ( c == 4 ) 
    {
      h = 0 ; 
      p = mem [ curbox + 5 ] .hh .v.RH ; 
      if ( p != 0 ) 
      if ( mem [ p ] .hh.b0 <= 2 ) 
      h = mem [ p + 3 ] .cint ; 
      mem [ curbox + 2 ] .cint = mem [ curbox + 2 ] .cint - h + mem [ curbox + 
      3 ] .cint ; 
      mem [ curbox + 3 ] .cint = h ; 
    } 
  } 
  popnest () ; 
  boxend ( savestack [ saveptr + 0 ] .cint ) ; 
} 
smallnumber znormmin ( h ) 
integer h ; 
{register smallnumber Result; normmin_regmem 
  if ( h <= 0 ) 
  Result = 1 ; 
  else if ( h >= 63 ) 
  Result = 63 ; 
  else Result = h ; 
  return(Result) ; 
} 
void znewgraf ( indented ) 
boolean indented ; 
{newgraf_regmem 
  curlist .pgfield = 0 ; 
  if ( ( curlist .modefield == 1 ) || ( curlist .headfield != curlist 
  .tailfield ) ) 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newparamglue ( 2 ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  pushnest () ; 
  curlist .modefield = 102 ; 
  curlist .auxfield .hh .v.LH = 1000 ; 
  if ( eqtb [ 9213 ] .cint <= 0 ) 
  curlang = 0 ; 
  else if ( eqtb [ 9213 ] .cint > 255 ) 
  curlang = 0 ; 
  else curlang = eqtb [ 9213 ] .cint ; 
  curlist .auxfield .hh .v.RH = curlang ; 
  curlist .pgfield = ( normmin ( eqtb [ 9214 ] .cint ) * 64 + normmin ( eqtb [ 
  9215 ] .cint ) ) * 65536L + curlang ; 
  if ( indented ) 
  {
    curlist .tailfield = newnullbox () ; 
    mem [ curlist .headfield ] .hh .v.RH = curlist .tailfield ; 
    mem [ curlist .tailfield + 1 ] .cint = eqtb [ 9730 ] .cint ; 
  } 
  if ( eqtb [ 7314 ] .hh .v.RH != 0 ) 
  begintokenlist ( eqtb [ 7314 ] .hh .v.RH , 7 ) ; 
  if ( nestptr == 1 ) 
  buildpage () ; 
} 
void indentinhmode ( ) 
{indentinhmode_regmem 
  halfword p, q  ; 
  if ( curchr > 0 ) 
  {
    p = newnullbox () ; 
    mem [ p + 1 ] .cint = eqtb [ 9730 ] .cint ; 
    if ( abs ( curlist .modefield ) == 102 ) 
    curlist .auxfield .hh .v.LH = 1000 ; 
    else {
	
      q = newnoad () ; 
      mem [ q + 1 ] .hh .v.RH = 2 ; 
      mem [ q + 1 ] .hh .v.LH = p ; 
      p = q ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = p ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
  } 
} 
void headforvmode ( ) 
{headforvmode_regmem 
  if ( curlist .modefield < 0 ) 
  if ( curcmd != 36 ) 
  offsave () ; 
  else {
      
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 682 ) ; 
    } 
    printesc ( 518 ) ; 
    print ( 1076 ) ; 
    {
      helpptr = 2 ; 
      helpline [ 1 ] = 1077 ; 
      helpline [ 0 ] = 1078 ; 
    } 
    error () ; 
  } 
  else {
      
    backinput () ; 
    curtok = partoken ; 
    backinput () ; 
    curinput .indexfield = 4 ; 
  } 
} 
void endgraf ( ) 
{endgraf_regmem 
  if ( curlist .modefield == 102 ) 
  {
    if ( curlist .headfield == curlist .tailfield ) 
    popnest () ; 
    else linebreak ( eqtb [ 9169 ] .cint ) ; 
    normalparagraph () ; 
    errorcount = 0 ; 
  } 
} 
void begininsertoradjust ( ) 
{begininsertoradjust_regmem 
  if ( curcmd == 38 ) 
  curval = 255 ; 
  else {
      
    scaneightbitint () ; 
    if ( curval == 255 ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1079 ) ; 
      } 
      printesc ( 327 ) ; 
      printint ( 255 ) ; 
      {
	helpptr = 1 ; 
	helpline [ 0 ] = 1080 ; 
      } 
      error () ; 
      curval = 0 ; 
    } 
  } 
  savestack [ saveptr + 0 ] .cint = curval ; 
  incr ( saveptr ) ; 
  newsavelevel ( 11 ) ; 
  scanleftbrace () ; 
  normalparagraph () ; 
  pushnest () ; 
  curlist .modefield = -1 ; 
  curlist .auxfield .cint = -65536000L ; 
} 
void makemark ( ) 
{makemark_regmem 
  halfword p  ; 
  p = scantoks ( false , true ) ; 
  p = getnode ( 2 ) ; 
  mem [ p ] .hh.b0 = 4 ; 
  mem [ p ] .hh.b1 = 0 ; 
  mem [ p + 1 ] .cint = defref ; 
  mem [ curlist .tailfield ] .hh .v.RH = p ; 
  curlist .tailfield = p ; 
} 
void appendpenalty ( ) 
{appendpenalty_regmem 
  scanint () ; 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( curval ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  if ( curlist .modefield == 1 ) 
  buildpage () ; 
} 
void deletelast ( ) 
{/* 10 */ deletelast_regmem 
  halfword p, q  ; 
  quarterword m  ; 
  if ( ( curlist .modefield == 1 ) && ( curlist .tailfield == curlist 
  .headfield ) ) 
  {
    if ( ( curchr != 10 ) || ( lastglue != 65535L ) ) 
    {
      youcant () ; 
      {
	helpptr = 2 ; 
	helpline [ 1 ] = 1065 ; 
	helpline [ 0 ] = 1081 ; 
      } 
      if ( curchr == 11 ) 
      helpline [ 0 ] = ( 1082 ) ; 
      else if ( curchr != 10 ) 
      helpline [ 0 ] = ( 1083 ) ; 
      error () ; 
    } 
  } 
  else {
      
    if ( ! ( curlist .tailfield >= himemmin ) ) 
    if ( mem [ curlist .tailfield ] .hh.b0 == curchr ) 
    {
      q = curlist .headfield ; 
      do {
	  p = q ; 
	if ( ! ( q >= himemmin ) ) 
	if ( mem [ q ] .hh.b0 == 7 ) 
	{
	  {register integer for_end; m = 1 ; for_end = mem [ q ] .hh.b1 
	  ; if ( m <= for_end) do 
	    p = mem [ p ] .hh .v.RH ; 
	  while ( m++ < for_end ) ; } 
	  if ( p == curlist .tailfield ) 
	  return ; 
	} 
	q = mem [ p ] .hh .v.RH ; 
      } while ( ! ( q == curlist .tailfield ) ) ; 
      mem [ p ] .hh .v.RH = 0 ; 
      flushnodelist ( curlist .tailfield ) ; 
      curlist .tailfield = p ; 
    } 
  } 
} 
void unpackage ( ) 
{/* 10 */ unpackage_regmem 
  halfword p  ; 
  char c  ; 
  c = curchr ; 
  scaneightbitint () ; 
  p = eqtb [ 7578 + curval ] .hh .v.RH ; 
  if ( p == 0 ) 
  return ; 
  if ( ( abs ( curlist .modefield ) == 203 ) || ( ( abs ( curlist .modefield ) 
  == 1 ) && ( mem [ p ] .hh.b0 != 1 ) ) || ( ( abs ( curlist .modefield ) == 
  102 ) && ( mem [ p ] .hh.b0 != 0 ) ) ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1091 ) ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1092 ; 
      helpline [ 1 ] = 1093 ; 
      helpline [ 0 ] = 1094 ; 
    } 
    error () ; 
    return ; 
  } 
  if ( c == 1 ) 
  mem [ curlist .tailfield ] .hh .v.RH = copynodelist ( mem [ p + 5 ] .hh 
  .v.RH ) ; 
  else {
      
    mem [ curlist .tailfield ] .hh .v.RH = mem [ p + 5 ] .hh .v.RH ; 
    eqtb [ 7578 + curval ] .hh .v.RH = 0 ; 
    freenode ( p , 7 ) ; 
  } 
  while ( mem [ curlist .tailfield ] .hh .v.RH != 0 ) curlist .tailfield = mem 
  [ curlist .tailfield ] .hh .v.RH ; 
} 
void appenditaliccorrection ( ) 
{/* 10 */ appenditaliccorrection_regmem 
  halfword p  ; 
  internalfontnumber f  ; 
  if ( curlist .tailfield != curlist .headfield ) 
  {
    if ( ( curlist .tailfield >= himemmin ) ) 
    p = curlist .tailfield ; 
    else if ( mem [ curlist .tailfield ] .hh.b0 == 6 ) 
    p = curlist .tailfield + 1 ; 
    else return ; 
    f = mem [ p ] .hh.b0 ; 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newkern ( fontinfo [ italicbase [ 
      f ] + ( fontinfo [ charbase [ f ] + mem [ p ] .hh.b1 ] .qqqq .b2 ) / 4 ] 
      .cint ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    mem [ curlist .tailfield ] .hh.b1 = 1 ; 
  } 
} 
void appenddiscretionary ( ) 
{appenddiscretionary_regmem 
  integer c  ; 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newdisc () ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  if ( curchr == 1 ) 
  {
    c = hyphenchar [ eqtb [ 7834 ] .hh .v.RH ] ; 
    if ( c >= 0 ) 
    if ( c < 256 ) 
    mem [ curlist .tailfield + 1 ] .hh .v.LH = newcharacter ( eqtb [ 7834 ] 
    .hh .v.RH , c ) ; 
  } 
  else {
      
    incr ( saveptr ) ; 
    savestack [ saveptr - 1 ] .cint = 0 ; 
    newsavelevel ( 10 ) ; 
    scanleftbrace () ; 
    pushnest () ; 
    curlist .modefield = -102 ; 
    curlist .auxfield .hh .v.LH = 1000 ; 
  } 
} 
void builddiscretionary ( ) 
{/* 30 10 */ builddiscretionary_regmem 
  halfword p, q  ; 
  integer n  ; 
  unsave () ; 
  q = curlist .headfield ; 
  p = mem [ q ] .hh .v.RH ; 
  n = 0 ; 
  while ( p != 0 ) {
      
    if ( ! ( p >= himemmin ) ) 
    if ( mem [ p ] .hh.b0 > 2 ) 
    if ( mem [ p ] .hh.b0 != 11 ) 
    if ( mem [ p ] .hh.b0 != 6 ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1101 ) ; 
      } 
      {
	helpptr = 1 ; 
	helpline [ 0 ] = 1102 ; 
      } 
      error () ; 
      begindiagnostic () ; 
      printnl ( 1103 ) ; 
      showbox ( p ) ; 
      enddiagnostic ( true ) ; 
      flushnodelist ( p ) ; 
      mem [ q ] .hh .v.RH = 0 ; 
      goto lab30 ; 
    } 
    q = p ; 
    p = mem [ q ] .hh .v.RH ; 
    incr ( n ) ; 
  } 
  lab30: ; 
  p = mem [ curlist .headfield ] .hh .v.RH ; 
  popnest () ; 
  switch ( savestack [ saveptr - 1 ] .cint ) 
  {case 0 : 
    mem [ curlist .tailfield + 1 ] .hh .v.LH = p ; 
    break ; 
  case 1 : 
    mem [ curlist .tailfield + 1 ] .hh .v.RH = p ; 
    break ; 
  case 2 : 
    {
      if ( ( n > 0 ) && ( abs ( curlist .modefield ) == 203 ) ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1095 ) ; 
	} 
	printesc ( 346 ) ; 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1096 ; 
	  helpline [ 0 ] = 1097 ; 
	} 
	flushnodelist ( p ) ; 
	n = 0 ; 
	error () ; 
      } 
      else mem [ curlist .tailfield ] .hh .v.RH = p ; 
      if ( n <= 255 ) 
      mem [ curlist .tailfield ] .hh.b1 = n ; 
      else {
	  
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1098 ) ; 
	} 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1099 ; 
	  helpline [ 0 ] = 1100 ; 
	} 
	error () ; 
      } 
      if ( n > 0 ) 
      curlist .tailfield = q ; 
      decr ( saveptr ) ; 
      return ; 
    } 
    break ; 
  } 
  incr ( savestack [ saveptr - 1 ] .cint ) ; 
  newsavelevel ( 10 ) ; 
  scanleftbrace () ; 
  pushnest () ; 
  curlist .modefield = -102 ; 
  curlist .auxfield .hh .v.LH = 1000 ; 
} 
void makeaccent ( ) 
{makeaccent_regmem 
  real s, t  ; 
  halfword p, q, r  ; 
  internalfontnumber f  ; 
  scaled a, h, x, w, delta  ; 
  fourquarters i  ; 
  scancharnum () ; 
  f = eqtb [ 7834 ] .hh .v.RH ; 
  p = newcharacter ( f , curval ) ; 
  if ( p != 0 ) 
  {
    x = fontinfo [ 5 + parambase [ f ] ] .cint ; 
    s = fontinfo [ 1 + parambase [ f ] ] .cint / ((double) 65536.0 ) ; 
    a = fontinfo [ widthbase [ f ] + fontinfo [ charbase [ f ] + mem [ p ] 
    .hh.b1 ] .qqqq .b0 ] .cint ; 
    doassignments () ; 
    q = 0 ; 
    f = eqtb [ 7834 ] .hh .v.RH ; 
    if ( ( curcmd == 11 ) || ( curcmd == 12 ) || ( curcmd == 68 ) ) 
    q = newcharacter ( f , curchr ) ; 
    else if ( curcmd == 16 ) 
    {
      scancharnum () ; 
      q = newcharacter ( f , curval ) ; 
    } 
    else backinput () ; 
    if ( q != 0 ) 
    {
      t = fontinfo [ 1 + parambase [ f ] ] .cint / ((double) 65536.0 ) ; 
      i = fontinfo [ charbase [ f ] + mem [ q ] .hh.b1 ] .qqqq ; 
      w = fontinfo [ widthbase [ f ] + i .b0 ] .cint ; 
      h = fontinfo [ heightbase [ f ] + ( i .b1 ) / 16 ] .cint ; 
      if ( h != x ) 
      {
	p = hpack ( p , 0 , 1 ) ; 
	mem [ p + 4 ] .cint = x - h ; 
      } 
      delta = round ( ( w - a ) / ((double) 2.0 ) + h * t - x * s ) ; 
      r = newkern ( delta ) ; 
      mem [ r ] .hh.b1 = 2 ; 
      mem [ curlist .tailfield ] .hh .v.RH = r ; 
      mem [ r ] .hh .v.RH = p ; 
      curlist .tailfield = newkern ( - (integer) a - delta ) ; 
      mem [ curlist .tailfield ] .hh.b1 = 2 ; 
      mem [ p ] .hh .v.RH = curlist .tailfield ; 
      p = q ; 
    } 
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    curlist .tailfield = p ; 
    curlist .auxfield .hh .v.LH = 1000 ; 
  } 
} 
void alignerror ( ) 
{alignerror_regmem 
  if ( abs ( alignstate ) > 2 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1108 ) ; 
    } 
    printcmdchr ( curcmd , curchr ) ; 
    if ( curtok == 1062 ) 
    {
      {
	helpptr = 6 ; 
	helpline [ 5 ] = 1109 ; 
	helpline [ 4 ] = 1110 ; 
	helpline [ 3 ] = 1111 ; 
	helpline [ 2 ] = 1112 ; 
	helpline [ 1 ] = 1113 ; 
	helpline [ 0 ] = 1114 ; 
      } 
    } 
    else {
	
      {
	helpptr = 5 ; 
	helpline [ 4 ] = 1109 ; 
	helpline [ 3 ] = 1115 ; 
	helpline [ 2 ] = 1112 ; 
	helpline [ 1 ] = 1113 ; 
	helpline [ 0 ] = 1114 ; 
      } 
    } 
    error () ; 
  } 
  else {
      
    backinput () ; 
    if ( alignstate < 0 ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 654 ) ; 
      } 
      incr ( alignstate ) ; 
      curtok = 379 ; 
    } 
    else {
	
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1104 ) ; 
      } 
      decr ( alignstate ) ; 
      curtok = 637 ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1105 ; 
      helpline [ 1 ] = 1106 ; 
      helpline [ 0 ] = 1107 ; 
    } 
    inserror () ; 
  } 
} 
void noalignerror ( ) 
{noalignerror_regmem 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 1108 ) ; 
  } 
  printesc ( 524 ) ; 
  {
    helpptr = 2 ; 
    helpline [ 1 ] = 1116 ; 
    helpline [ 0 ] = 1117 ; 
  } 
  error () ; 
} 
void omiterror ( ) 
{omiterror_regmem 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 1108 ) ; 
  } 
  printesc ( 527 ) ; 
  {
    helpptr = 2 ; 
    helpline [ 1 ] = 1118 ; 
    helpline [ 0 ] = 1117 ; 
  } 
  error () ; 
} 
void doendv ( ) 
{doendv_regmem 
  if ( curgroup == 6 ) 
  {
    endgraf () ; 
    if ( fincol () ) 
    finrow () ; 
  } 
  else offsave () ; 
} 
void cserror ( ) 
{cserror_regmem 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 773 ) ; 
  } 
  printesc ( 502 ) ; 
  {
    helpptr = 1 ; 
    helpline [ 0 ] = 1120 ; 
  } 
  error () ; 
} 
void zpushmath ( c ) 
groupcode c ; 
{pushmath_regmem 
  pushnest () ; 
  curlist .modefield = -203 ; 
  curlist .auxfield .cint = 0 ; 
  newsavelevel ( c ) ; 
} 
void initmath ( ) 
{/* 21 40 45 30 */ initmath_regmem 
  scaled w  ; 
  scaled l  ; 
  scaled s  ; 
  halfword p  ; 
  halfword q  ; 
  internalfontnumber f  ; 
  integer n  ; 
  scaled v  ; 
  scaled d  ; 
  gettoken () ; 
  if ( ( curcmd == 3 ) && ( curlist .modefield > 0 ) ) 
  {
    if ( curlist .headfield == curlist .tailfield ) 
    {
      popnest () ; 
      w = -1073741823L ; 
    } 
    else {
	
      linebreak ( eqtb [ 9170 ] .cint ) ; 
      v = mem [ justbox + 4 ] .cint + 2 * fontinfo [ 6 + parambase [ eqtb [ 
      7834 ] .hh .v.RH ] ] .cint ; 
      w = -1073741823L ; 
      p = mem [ justbox + 5 ] .hh .v.RH ; 
      while ( p != 0 ) {
	  
	lab21: if ( ( p >= himemmin ) ) 
	{
	  f = mem [ p ] .hh.b0 ; 
	  d = fontinfo [ widthbase [ f ] + fontinfo [ charbase [ f ] + mem [ p 
	  ] .hh.b1 ] .qqqq .b0 ] .cint ; 
	  goto lab40 ; 
	} 
	switch ( mem [ p ] .hh.b0 ) 
	{case 0 : 
	case 1 : 
	case 2 : 
	  {
	    d = mem [ p + 1 ] .cint ; 
	    goto lab40 ; 
	  } 
	  break ; 
	case 6 : 
	  {
	    mem [ memtop - 12 ] = mem [ p + 1 ] ; 
	    mem [ memtop - 12 ] .hh .v.RH = mem [ p ] .hh .v.RH ; 
	    p = memtop - 12 ; 
	    goto lab21 ; 
	  } 
	  break ; 
	case 11 : 
	case 9 : 
	  d = mem [ p + 1 ] .cint ; 
	  break ; 
	case 10 : 
	  {
	    q = mem [ p + 1 ] .hh .v.LH ; 
	    d = mem [ q + 1 ] .cint ; 
	    if ( mem [ justbox + 5 ] .hh.b0 == 1 ) 
	    {
	      if ( ( mem [ justbox + 5 ] .hh.b1 == mem [ q ] .hh.b0 ) && ( mem 
	      [ q + 2 ] .cint != 0 ) ) 
	      v = 1073741823L ; 
	    } 
	    else if ( mem [ justbox + 5 ] .hh.b0 == 2 ) 
	    {
	      if ( ( mem [ justbox + 5 ] .hh.b1 == mem [ q ] .hh.b1 ) && ( mem 
	      [ q + 3 ] .cint != 0 ) ) 
	      v = 1073741823L ; 
	    } 
	    if ( mem [ p ] .hh.b1 >= 100 ) 
	    goto lab40 ; 
	  } 
	  break ; 
	case 8 : 
	  d = 0 ; 
	  break ; 
	  default: 
	  d = 0 ; 
	  break ; 
	} 
	if ( v < 1073741823L ) 
	v = v + d ; 
	goto lab45 ; 
	lab40: if ( v < 1073741823L ) 
	{
	  v = v + d ; 
	  w = v ; 
	} 
	else {
	    
	  w = 1073741823L ; 
	  goto lab30 ; 
	} 
	lab45: p = mem [ p ] .hh .v.RH ; 
      } 
      lab30: ; 
    } 
    if ( eqtb [ 7312 ] .hh .v.RH == 0 ) 
    if ( ( eqtb [ 9747 ] .cint != 0 ) && ( ( ( eqtb [ 9204 ] .cint >= 0 ) && ( 
    curlist .pgfield + 2 > eqtb [ 9204 ] .cint ) ) || ( curlist .pgfield + 1 < 
    - (integer) eqtb [ 9204 ] .cint ) ) ) 
    {
      l = eqtb [ 9733 ] .cint - abs ( eqtb [ 9747 ] .cint ) ; 
      if ( eqtb [ 9747 ] .cint > 0 ) 
      s = eqtb [ 9747 ] .cint ; 
      else s = 0 ; 
    } 
    else {
	
      l = eqtb [ 9733 ] .cint ; 
      s = 0 ; 
    } 
    else {
	
      n = mem [ eqtb [ 7312 ] .hh .v.RH ] .hh .v.LH ; 
      if ( curlist .pgfield + 2 >= n ) 
      p = eqtb [ 7312 ] .hh .v.RH + 2 * n ; 
      else p = eqtb [ 7312 ] .hh .v.RH + 2 * ( curlist .pgfield + 2 ) ; 
      s = mem [ p - 1 ] .cint ; 
      l = mem [ p ] .cint ; 
    } 
    pushmath ( 15 ) ; 
    curlist .modefield = 203 ; 
    eqworddefine ( 9207 , -1 ) ; 
    eqworddefine ( 9743 , w ) ; 
    eqworddefine ( 9744 , l ) ; 
    eqworddefine ( 9745 , s ) ; 
    if ( eqtb [ 7316 ] .hh .v.RH != 0 ) 
    begintokenlist ( eqtb [ 7316 ] .hh .v.RH , 9 ) ; 
    if ( nestptr == 1 ) 
    buildpage () ; 
  } 
  else {
      
    backinput () ; 
    {
      pushmath ( 15 ) ; 
      eqworddefine ( 9207 , -1 ) ; 
      if ( eqtb [ 7315 ] .hh .v.RH != 0 ) 
      begintokenlist ( eqtb [ 7315 ] .hh .v.RH , 8 ) ; 
    } 
  } 
} 
void starteqno ( ) 
{starteqno_regmem 
  savestack [ saveptr + 0 ] .cint = curchr ; 
  incr ( saveptr ) ; 
  {
    pushmath ( 15 ) ; 
    eqworddefine ( 9207 , -1 ) ; 
    if ( eqtb [ 7315 ] .hh .v.RH != 0 ) 
    begintokenlist ( eqtb [ 7315 ] .hh .v.RH , 8 ) ; 
  } 
} 
void zscanmath ( p ) 
halfword p ; 
{/* 20 21 10 */ scanmath_regmem 
  integer c  ; 
  lab20: do {
      getxtoken () ; 
  } while ( ! ( ( curcmd != 10 ) && ( curcmd != 0 ) ) ) ; 
  lab21: switch ( curcmd ) 
  {case 11 : 
  case 12 : 
  case 68 : 
    {
      c = eqtb [ 8907 + curchr ] .hh .v.RH ; 
      if ( c == 32768L ) 
      {
	{
	  curcs = curchr + 1 ; 
	  curcmd = eqtb [ curcs ] .hh.b0 ; 
	  curchr = eqtb [ curcs ] .hh .v.RH ; 
	  xtoken () ; 
	  backinput () ; 
	} 
	goto lab20 ; 
      } 
    } 
    break ; 
  case 16 : 
    {
      scancharnum () ; 
      curchr = curval ; 
      curcmd = 68 ; 
      goto lab21 ; 
    } 
    break ; 
  case 17 : 
    {
      scanfifteenbitint () ; 
      c = curval ; 
    } 
    break ; 
  case 69 : 
    c = curchr ; 
    break ; 
  case 15 : 
    {
      scantwentysevenbitint () ; 
      c = curval / 4096 ; 
    } 
    break ; 
    default: 
    {
      backinput () ; 
      scanleftbrace () ; 
      savestack [ saveptr + 0 ] .cint = p ; 
      incr ( saveptr ) ; 
      pushmath ( 9 ) ; 
      return ; 
    } 
    break ; 
  } 
  mem [ p ] .hh .v.RH = 1 ; 
  mem [ p ] .hh.b1 = c % 256 ; 
  if ( ( c >= 28672 ) && ( ( eqtb [ 9207 ] .cint >= 0 ) && ( eqtb [ 9207 ] 
  .cint < 16 ) ) ) 
  mem [ p ] .hh.b0 = eqtb [ 9207 ] .cint ; 
  else mem [ p ] .hh.b0 = ( c / 256 ) % 16 ; 
} 
void zsetmathchar ( c ) 
integer c ; 
{setmathchar_regmem 
  halfword p  ; 
  if ( c >= 32768L ) 
  {
    curcs = curchr + 1 ; 
    curcmd = eqtb [ curcs ] .hh.b0 ; 
    curchr = eqtb [ curcs ] .hh .v.RH ; 
    xtoken () ; 
    backinput () ; 
  } 
  else {
      
    p = newnoad () ; 
    mem [ p + 1 ] .hh .v.RH = 1 ; 
    mem [ p + 1 ] .hh.b1 = c % 256 ; 
    mem [ p + 1 ] .hh.b0 = ( c / 256 ) % 16 ; 
    if ( c >= 28672 ) 
    {
      if ( ( ( eqtb [ 9207 ] .cint >= 0 ) && ( eqtb [ 9207 ] .cint < 16 ) ) ) 
      mem [ p + 1 ] .hh.b0 = eqtb [ 9207 ] .cint ; 
      mem [ p ] .hh.b0 = 16 ; 
    } 
    else mem [ p ] .hh.b0 = 16 + ( c / 4096 ) ; 
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    curlist .tailfield = p ; 
  } 
} 
void mathlimitswitch ( ) 
{/* 10 */ mathlimitswitch_regmem 
  if ( curlist .headfield != curlist .tailfield ) 
  if ( mem [ curlist .tailfield ] .hh.b0 == 17 ) 
  {
    mem [ curlist .tailfield ] .hh.b1 = curchr ; 
    return ; 
  } 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 1124 ) ; 
  } 
  {
    helpptr = 1 ; 
    helpline [ 0 ] = 1125 ; 
  } 
  error () ; 
} 
void zscandelimiter ( p , r ) 
halfword p ; 
boolean r ; 
{scandelimiter_regmem 
  if ( r ) 
  scantwentysevenbitint () ; 
  else {
      
    do {
	getxtoken () ; 
    } while ( ! ( ( curcmd != 10 ) && ( curcmd != 0 ) ) ) ; 
    switch ( curcmd ) 
    {case 11 : 
    case 12 : 
      curval = eqtb [ 9474 + curchr ] .cint ; 
      break ; 
    case 15 : 
      scantwentysevenbitint () ; 
      break ; 
      default: 
      curval = -1 ; 
      break ; 
    } 
  } 
  if ( curval < 0 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1126 ) ; 
    } 
    {
      helpptr = 6 ; 
      helpline [ 5 ] = 1127 ; 
      helpline [ 4 ] = 1128 ; 
      helpline [ 3 ] = 1129 ; 
      helpline [ 2 ] = 1130 ; 
      helpline [ 1 ] = 1131 ; 
      helpline [ 0 ] = 1132 ; 
    } 
    backerror () ; 
    curval = 0 ; 
  } 
  mem [ p ] .qqqq .b0 = ( curval / 1048576L ) % 16 ; 
  mem [ p ] .qqqq .b1 = ( curval / 4096 ) % 256 ; 
  mem [ p ] .qqqq .b2 = ( curval / 256 ) % 16 ; 
  mem [ p ] .qqqq .b3 = curval % 256 ; 
} 
void mathradical ( ) 
{mathradical_regmem 
  {
    mem [ curlist .tailfield ] .hh .v.RH = getnode ( 5 ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  mem [ curlist .tailfield ] .hh.b0 = 24 ; 
  mem [ curlist .tailfield ] .hh.b1 = 0 ; 
  mem [ curlist .tailfield + 1 ] .hh = emptyfield ; 
  mem [ curlist .tailfield + 3 ] .hh = emptyfield ; 
  mem [ curlist .tailfield + 2 ] .hh = emptyfield ; 
  scandelimiter ( curlist .tailfield + 4 , true ) ; 
  scanmath ( curlist .tailfield + 1 ) ; 
} 
void mathac ( ) 
{mathac_regmem 
  if ( curcmd == 45 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1133 ) ; 
    } 
    printesc ( 520 ) ; 
    print ( 1134 ) ; 
    {
      helpptr = 2 ; 
      helpline [ 1 ] = 1135 ; 
      helpline [ 0 ] = 1136 ; 
    } 
    error () ; 
  } 
  {
    mem [ curlist .tailfield ] .hh .v.RH = getnode ( 5 ) ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  mem [ curlist .tailfield ] .hh.b0 = 28 ; 
  mem [ curlist .tailfield ] .hh.b1 = 0 ; 
  mem [ curlist .tailfield + 1 ] .hh = emptyfield ; 
  mem [ curlist .tailfield + 3 ] .hh = emptyfield ; 
  mem [ curlist .tailfield + 2 ] .hh = emptyfield ; 
  mem [ curlist .tailfield + 4 ] .hh .v.RH = 1 ; 
  scanfifteenbitint () ; 
  mem [ curlist .tailfield + 4 ] .hh.b1 = curval % 256 ; 
  if ( ( curval >= 28672 ) && ( ( eqtb [ 9207 ] .cint >= 0 ) && ( eqtb [ 9207 
  ] .cint < 16 ) ) ) 
  mem [ curlist .tailfield + 4 ] .hh.b0 = eqtb [ 9207 ] .cint ; 
  else mem [ curlist .tailfield + 4 ] .hh.b0 = ( curval / 256 ) % 16 ; 
  scanmath ( curlist .tailfield + 1 ) ; 
} 
void appendchoices ( ) 
{appendchoices_regmem 
  {
    mem [ curlist .tailfield ] .hh .v.RH = newchoice () ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  incr ( saveptr ) ; 
  savestack [ saveptr - 1 ] .cint = 0 ; 
  pushmath ( 13 ) ; 
  scanleftbrace () ; 
} 
halfword zfinmlist ( p ) 
halfword p ; 
{register halfword Result; finmlist_regmem 
  halfword q  ; 
  if ( curlist .auxfield .cint != 0 ) 
  {
    mem [ curlist .auxfield .cint + 3 ] .hh .v.RH = 3 ; 
    mem [ curlist .auxfield .cint + 3 ] .hh .v.LH = mem [ curlist .headfield ] 
    .hh .v.RH ; 
    if ( p == 0 ) 
    q = curlist .auxfield .cint ; 
    else {
	
      q = mem [ curlist .auxfield .cint + 2 ] .hh .v.LH ; 
      if ( mem [ q ] .hh.b0 != 30 ) 
      confusion ( 871 ) ; 
      mem [ curlist .auxfield .cint + 2 ] .hh .v.LH = mem [ q ] .hh .v.RH ; 
      mem [ q ] .hh .v.RH = curlist .auxfield .cint ; 
      mem [ curlist .auxfield .cint ] .hh .v.RH = p ; 
    } 
  } 
  else {
      
    mem [ curlist .tailfield ] .hh .v.RH = p ; 
    q = mem [ curlist .headfield ] .hh .v.RH ; 
  } 
  popnest () ; 
  Result = q ; 
  return(Result) ; 
} 
void buildchoices ( ) 
{/* 10 */ buildchoices_regmem 
  halfword p  ; 
  unsave () ; 
  p = finmlist ( 0 ) ; 
  switch ( savestack [ saveptr - 1 ] .cint ) 
  {case 0 : 
    mem [ curlist .tailfield + 1 ] .hh .v.LH = p ; 
    break ; 
  case 1 : 
    mem [ curlist .tailfield + 1 ] .hh .v.RH = p ; 
    break ; 
  case 2 : 
    mem [ curlist .tailfield + 2 ] .hh .v.LH = p ; 
    break ; 
  case 3 : 
    {
      mem [ curlist .tailfield + 2 ] .hh .v.RH = p ; 
      decr ( saveptr ) ; 
      return ; 
    } 
    break ; 
  } 
  incr ( savestack [ saveptr - 1 ] .cint ) ; 
  pushmath ( 13 ) ; 
  scanleftbrace () ; 
} 
void subsup ( ) 
{subsup_regmem 
  smallnumber t  ; 
  halfword p  ; 
  t = 0 ; 
  p = 0 ; 
  if ( curlist .tailfield != curlist .headfield ) 
  if ( ( mem [ curlist .tailfield ] .hh.b0 >= 16 ) && ( mem [ curlist 
  .tailfield ] .hh.b0 < 30 ) ) 
  {
    p = curlist .tailfield + 2 + curcmd - 7 ; 
    t = mem [ p ] .hh .v.RH ; 
  } 
  if ( ( p == 0 ) || ( t != 0 ) ) 
  {
    {
      mem [ curlist .tailfield ] .hh .v.RH = newnoad () ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    p = curlist .tailfield + 2 + curcmd - 7 ; 
    if ( t != 0 ) 
    {
      if ( curcmd == 7 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1137 ) ; 
	} 
	{
	  helpptr = 1 ; 
	  helpline [ 0 ] = 1138 ; 
	} 
      } 
      else {
	  
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1139 ) ; 
	} 
	{
	  helpptr = 1 ; 
	  helpline [ 0 ] = 1140 ; 
	} 
      } 
      error () ; 
    } 
  } 
  scanmath ( p ) ; 
} 
void mathfraction ( ) 
{mathfraction_regmem 
  smallnumber c  ; 
  c = curchr ; 
  if ( curlist .auxfield .cint != 0 ) 
  {
    if ( c >= 3 ) 
    {
      scandelimiter ( memtop - 12 , false ) ; 
      scandelimiter ( memtop - 12 , false ) ; 
    } 
    if ( c % 3 == 0 ) 
    scandimen ( false , false , false ) ; 
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1147 ) ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1148 ; 
      helpline [ 1 ] = 1149 ; 
      helpline [ 0 ] = 1150 ; 
    } 
    error () ; 
  } 
  else {
      
    curlist .auxfield .cint = getnode ( 6 ) ; 
    mem [ curlist .auxfield .cint ] .hh.b0 = 25 ; 
    mem [ curlist .auxfield .cint ] .hh.b1 = 0 ; 
    mem [ curlist .auxfield .cint + 2 ] .hh .v.RH = 3 ; 
    mem [ curlist .auxfield .cint + 2 ] .hh .v.LH = mem [ curlist .headfield ] 
    .hh .v.RH ; 
    mem [ curlist .auxfield .cint + 3 ] .hh = emptyfield ; 
    mem [ curlist .auxfield .cint + 4 ] .qqqq = nulldelimiter ; 
    mem [ curlist .auxfield .cint + 5 ] .qqqq = nulldelimiter ; 
    mem [ curlist .headfield ] .hh .v.RH = 0 ; 
    curlist .tailfield = curlist .headfield ; 
    if ( c >= 3 ) 
    {
      scandelimiter ( curlist .auxfield .cint + 4 , false ) ; 
      scandelimiter ( curlist .auxfield .cint + 5 , false ) ; 
    } 
    switch ( c % 3 ) 
    {case 0 : 
      {
	scandimen ( false , false , false ) ; 
	mem [ curlist .auxfield .cint + 1 ] .cint = curval ; 
      } 
      break ; 
    case 1 : 
      mem [ curlist .auxfield .cint + 1 ] .cint = 1073741824L ; 
      break ; 
    case 2 : 
      mem [ curlist .auxfield .cint + 1 ] .cint = 0 ; 
      break ; 
    } 
  } 
} 
void mathleftright ( ) 
{mathleftright_regmem 
  smallnumber t  ; 
  halfword p  ; 
  t = curchr ; 
  if ( ( t == 31 ) && ( curgroup != 16 ) ) 
  {
    if ( curgroup == 15 ) 
    {
      scandelimiter ( memtop - 12 , false ) ; 
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 773 ) ; 
      } 
      printesc ( 871 ) ; 
      {
	helpptr = 1 ; 
	helpline [ 0 ] = 1151 ; 
      } 
      error () ; 
    } 
    else offsave () ; 
  } 
  else {
      
    p = newnoad () ; 
    mem [ p ] .hh.b0 = t ; 
    scandelimiter ( p + 1 , false ) ; 
    if ( t == 30 ) 
    {
      pushmath ( 16 ) ; 
      mem [ curlist .headfield ] .hh .v.RH = p ; 
      curlist .tailfield = p ; 
    } 
    else {
	
      p = finmlist ( p ) ; 
      unsave () ; 
      {
	mem [ curlist .tailfield ] .hh .v.RH = newnoad () ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      mem [ curlist .tailfield ] .hh.b0 = 23 ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = 3 ; 
      mem [ curlist .tailfield + 1 ] .hh .v.LH = p ; 
    } 
  } 
} 
void aftermath ( ) 
{aftermath_regmem 
  boolean l  ; 
  boolean danger  ; 
  integer m  ; 
  halfword p  ; 
  halfword a  ; 
  halfword b  ; 
  scaled w  ; 
  scaled z  ; 
  scaled e  ; 
  scaled q  ; 
  scaled d  ; 
  scaled s  ; 
  smallnumber g1, g2  ; 
  halfword r  ; 
  halfword t  ; 
  danger = false ; 
  if ( ( fontparams [ eqtb [ 7837 ] .hh .v.RH ] < 22 ) || ( fontparams [ eqtb 
  [ 7853 ] .hh .v.RH ] < 22 ) || ( fontparams [ eqtb [ 7869 ] .hh .v.RH ] < 22 
  ) ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1152 ) ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1153 ; 
      helpline [ 1 ] = 1154 ; 
      helpline [ 0 ] = 1155 ; 
    } 
    error () ; 
    flushmath () ; 
    danger = true ; 
  } 
  else if ( ( fontparams [ eqtb [ 7838 ] .hh .v.RH ] < 13 ) || ( fontparams [ 
  eqtb [ 7854 ] .hh .v.RH ] < 13 ) || ( fontparams [ eqtb [ 7870 ] .hh .v.RH ] 
  < 13 ) ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1156 ) ; 
    } 
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1157 ; 
      helpline [ 1 ] = 1158 ; 
      helpline [ 0 ] = 1159 ; 
    } 
    error () ; 
    flushmath () ; 
    danger = true ; 
  } 
  m = curlist .modefield ; 
  l = false ; 
  p = finmlist ( 0 ) ; 
  if ( curlist .modefield == - (integer) m ) 
  {
    {
      getxtoken () ; 
      if ( curcmd != 3 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1160 ) ; 
	} 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1161 ; 
	  helpline [ 0 ] = 1162 ; 
	} 
	backerror () ; 
      } 
    } 
    curmlist = p ; 
    curstyle = 2 ; 
    mlistpenalties = false ; 
    mlisttohlist () ; 
    a = hpack ( mem [ memtop - 3 ] .hh .v.RH , 0 , 1 ) ; 
    unsave () ; 
    decr ( saveptr ) ; 
    if ( savestack [ saveptr + 0 ] .cint == 1 ) 
    l = true ; 
    danger = false ; 
    if ( ( fontparams [ eqtb [ 7837 ] .hh .v.RH ] < 22 ) || ( fontparams [ 
    eqtb [ 7853 ] .hh .v.RH ] < 22 ) || ( fontparams [ eqtb [ 7869 ] .hh .v.RH 
    ] < 22 ) ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1152 ) ; 
      } 
      {
	helpptr = 3 ; 
	helpline [ 2 ] = 1153 ; 
	helpline [ 1 ] = 1154 ; 
	helpline [ 0 ] = 1155 ; 
      } 
      error () ; 
      flushmath () ; 
      danger = true ; 
    } 
    else if ( ( fontparams [ eqtb [ 7838 ] .hh .v.RH ] < 13 ) || ( fontparams 
    [ eqtb [ 7854 ] .hh .v.RH ] < 13 ) || ( fontparams [ eqtb [ 7870 ] .hh 
    .v.RH ] < 13 ) ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1156 ) ; 
      } 
      {
	helpptr = 3 ; 
	helpline [ 2 ] = 1157 ; 
	helpline [ 1 ] = 1158 ; 
	helpline [ 0 ] = 1159 ; 
      } 
      error () ; 
      flushmath () ; 
      danger = true ; 
    } 
    m = curlist .modefield ; 
    p = finmlist ( 0 ) ; 
  } 
  else a = 0 ; 
  if ( m < 0 ) 
  {
    {
      mem [ curlist .tailfield ] .hh .v.RH = newmath ( eqtb [ 9731 ] .cint , 0 
      ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    curmlist = p ; 
    curstyle = 2 ; 
    mlistpenalties = ( curlist .modefield > 0 ) ; 
    mlisttohlist () ; 
    mem [ curlist .tailfield ] .hh .v.RH = mem [ memtop - 3 ] .hh .v.RH ; 
    while ( mem [ curlist .tailfield ] .hh .v.RH != 0 ) curlist .tailfield = 
    mem [ curlist .tailfield ] .hh .v.RH ; 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newmath ( eqtb [ 9731 ] .cint , 1 
      ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    curlist .auxfield .hh .v.LH = 1000 ; 
    unsave () ; 
  } 
  else {
      
    if ( a == 0 ) 
    {
      getxtoken () ; 
      if ( curcmd != 3 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1160 ) ; 
	} 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1161 ; 
	  helpline [ 0 ] = 1162 ; 
	} 
	backerror () ; 
      } 
    } 
    curmlist = p ; 
    curstyle = 0 ; 
    mlistpenalties = false ; 
    mlisttohlist () ; 
    p = mem [ memtop - 3 ] .hh .v.RH ; 
    adjusttail = memtop - 5 ; 
    b = hpack ( p , 0 , 1 ) ; 
    p = mem [ b + 5 ] .hh .v.RH ; 
    t = adjusttail ; 
    adjusttail = 0 ; 
    w = mem [ b + 1 ] .cint ; 
    z = eqtb [ 9744 ] .cint ; 
    s = eqtb [ 9745 ] .cint ; 
    if ( ( a == 0 ) || danger ) 
    {
      e = 0 ; 
      q = 0 ; 
    } 
    else {
	
      e = mem [ a + 1 ] .cint ; 
      q = e + fontinfo [ 6 + parambase [ eqtb [ 7837 ] .hh .v.RH ] ] .cint ; 
    } 
    if ( w + q > z ) 
    {
      if ( ( e != 0 ) && ( ( w - totalshrink [ 0 ] + q <= z ) || ( totalshrink 
      [ 1 ] != 0 ) || ( totalshrink [ 2 ] != 0 ) || ( totalshrink [ 3 ] != 0 ) 
      ) ) 
      {
	freenode ( b , 7 ) ; 
	b = hpack ( p , z - q , 0 ) ; 
      } 
      else {
	  
	e = 0 ; 
	if ( w > z ) 
	{
	  freenode ( b , 7 ) ; 
	  b = hpack ( p , z , 0 ) ; 
	} 
      } 
      w = mem [ b + 1 ] .cint ; 
    } 
    d = half ( z - w ) ; 
    if ( ( e > 0 ) && ( d < 2 * e ) ) 
    {
      d = half ( z - w - e ) ; 
      if ( p != 0 ) 
      if ( ! ( p >= himemmin ) ) 
      if ( mem [ p ] .hh.b0 == 10 ) 
      d = 0 ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( eqtb [ 9174 ] .cint 
      ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    if ( ( d + s <= eqtb [ 9743 ] .cint ) || l ) 
    {
      g1 = 3 ; 
      g2 = 4 ; 
    } 
    else {
	
      g1 = 5 ; 
      g2 = 6 ; 
    } 
    if ( l && ( e == 0 ) ) 
    {
      mem [ a + 4 ] .cint = s ; 
      appendtovlist ( a ) ; 
      {
	mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( 10000 ) ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
    } 
    else {
	
      mem [ curlist .tailfield ] .hh .v.RH = newparamglue ( g1 ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    if ( e != 0 ) 
    {
      r = newkern ( z - w - e - d ) ; 
      if ( l ) 
      {
	mem [ a ] .hh .v.RH = r ; 
	mem [ r ] .hh .v.RH = b ; 
	b = a ; 
	d = 0 ; 
      } 
      else {
	  
	mem [ b ] .hh .v.RH = r ; 
	mem [ r ] .hh .v.RH = a ; 
      } 
      b = hpack ( b , 0 , 1 ) ; 
    } 
    mem [ b + 4 ] .cint = s + d ; 
    appendtovlist ( b ) ; 
    if ( ( a != 0 ) && ( e == 0 ) && ! l ) 
    {
      {
	mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( 10000 ) ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      mem [ a + 4 ] .cint = s + z - mem [ a + 1 ] .cint ; 
      appendtovlist ( a ) ; 
      g2 = 0 ; 
    } 
    if ( t != memtop - 5 ) 
    {
      mem [ curlist .tailfield ] .hh .v.RH = mem [ memtop - 5 ] .hh .v.RH ; 
      curlist .tailfield = t ; 
    } 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newpenalty ( eqtb [ 9175 ] .cint 
      ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    if ( g2 > 0 ) 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newparamglue ( g2 ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    resumeafterdisplay () ; 
  } 
} 
void resumeafterdisplay ( ) 
{resumeafterdisplay_regmem 
  if ( curgroup != 15 ) 
  confusion ( 1163 ) ; 
  unsave () ; 
  curlist .pgfield = curlist .pgfield + 3 ; 
  pushnest () ; 
  curlist .modefield = 102 ; 
  curlist .auxfield .hh .v.LH = 1000 ; 
  if ( eqtb [ 9213 ] .cint <= 0 ) 
  curlang = 0 ; 
  else if ( eqtb [ 9213 ] .cint > 255 ) 
  curlang = 0 ; 
  else curlang = eqtb [ 9213 ] .cint ; 
  curlist .auxfield .hh .v.RH = curlang ; 
  curlist .pgfield = ( normmin ( eqtb [ 9214 ] .cint ) * 64 + normmin ( eqtb [ 
  9215 ] .cint ) ) * 65536L + curlang ; 
  {
    getxtoken () ; 
    if ( curcmd != 10 ) 
    backinput () ; 
  } 
  if ( nestptr == 1 ) 
  buildpage () ; 
} 
void getrtoken ( ) 
{/* 20 */ getrtoken_regmem 
  lab20: do {
      gettoken () ; 
  } while ( ! ( curtok != 2592 ) ) ; 
  if ( ( curcs == 0 ) || ( curcs > 6514 ) ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1178 ) ; 
    } 
    {
      helpptr = 5 ; 
      helpline [ 4 ] = 1179 ; 
      helpline [ 3 ] = 1180 ; 
      helpline [ 2 ] = 1181 ; 
      helpline [ 1 ] = 1182 ; 
      helpline [ 0 ] = 1183 ; 
    } 
    if ( curcs == 0 ) 
    backinput () ; 
    curtok = 10609 ; 
    inserror () ; 
    goto lab20 ; 
  } 
} 
void trapzeroglue ( ) 
{trapzeroglue_regmem 
  if ( ( mem [ curval + 1 ] .cint == 0 ) && ( mem [ curval + 2 ] .cint == 0 ) 
  && ( mem [ curval + 3 ] .cint == 0 ) ) 
  {
    incr ( mem [ 0 ] .hh .v.RH ) ; 
    deleteglueref ( curval ) ; 
    curval = 0 ; 
  } 
} 
void zdoregistercommand ( a ) 
smallnumber a ; 
{/* 40 10 */ doregistercommand_regmem 
  halfword l, q, r, s  ; 
  char p  ; 
  q = curcmd ; 
  {
    if ( q != 89 ) 
    {
      getxtoken () ; 
      if ( ( curcmd >= 73 ) && ( curcmd <= 76 ) ) 
      {
	l = curchr ; 
	p = curcmd - 73 ; 
	goto lab40 ; 
      } 
      if ( curcmd != 89 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 682 ) ; 
	} 
	printcmdchr ( curcmd , curchr ) ; 
	print ( 683 ) ; 
	printcmdchr ( q , 0 ) ; 
	{
	  helpptr = 1 ; 
	  helpline [ 0 ] = 1204 ; 
	} 
	error () ; 
	return ; 
      } 
    } 
    p = curchr ; 
    scaneightbitint () ; 
    switch ( p ) 
    {case 0 : 
      l = curval + 9218 ; 
      break ; 
    case 1 : 
      l = curval + 9751 ; 
      break ; 
    case 2 : 
      l = curval + 6800 ; 
      break ; 
    case 3 : 
      l = curval + 7056 ; 
      break ; 
    } 
  } 
  lab40: ; 
  if ( q == 89 ) 
  scanoptionalequals () ; 
  else if ( scankeyword ( 1200 ) ) 
  ; 
  aritherror = false ; 
  if ( q < 91 ) 
  if ( p < 2 ) 
  {
    if ( p == 0 ) 
    scanint () ; 
    else scandimen ( false , false , false ) ; 
    if ( q == 90 ) 
    curval = curval + eqtb [ l ] .cint ; 
  } 
  else {
      
    scanglue ( p ) ; 
    if ( q == 90 ) 
    {
      q = newspec ( curval ) ; 
      r = eqtb [ l ] .hh .v.RH ; 
      deleteglueref ( curval ) ; 
      mem [ q + 1 ] .cint = mem [ q + 1 ] .cint + mem [ r + 1 ] .cint ; 
      if ( mem [ q + 2 ] .cint == 0 ) 
      mem [ q ] .hh.b0 = 0 ; 
      if ( mem [ q ] .hh.b0 == mem [ r ] .hh.b0 ) 
      mem [ q + 2 ] .cint = mem [ q + 2 ] .cint + mem [ r + 2 ] .cint ; 
      else if ( ( mem [ q ] .hh.b0 < mem [ r ] .hh.b0 ) && ( mem [ r + 2 ] 
      .cint != 0 ) ) 
      {
	mem [ q + 2 ] .cint = mem [ r + 2 ] .cint ; 
	mem [ q ] .hh.b0 = mem [ r ] .hh.b0 ; 
      } 
      if ( mem [ q + 3 ] .cint == 0 ) 
      mem [ q ] .hh.b1 = 0 ; 
      if ( mem [ q ] .hh.b1 == mem [ r ] .hh.b1 ) 
      mem [ q + 3 ] .cint = mem [ q + 3 ] .cint + mem [ r + 3 ] .cint ; 
      else if ( ( mem [ q ] .hh.b1 < mem [ r ] .hh.b1 ) && ( mem [ r + 3 ] 
      .cint != 0 ) ) 
      {
	mem [ q + 3 ] .cint = mem [ r + 3 ] .cint ; 
	mem [ q ] .hh.b1 = mem [ r ] .hh.b1 ; 
      } 
      curval = q ; 
    } 
  } 
  else {
      
    scanint () ; 
    if ( p < 2 ) 
    if ( q == 91 ) 
    if ( p == 0 ) 
    curval = multandadd ( eqtb [ l ] .cint , curval , 0 , 2147483647L ) ; 
    else curval = multandadd ( eqtb [ l ] .cint , curval , 0 , 1073741823L ) ; 
    else curval = xovern ( eqtb [ l ] .cint , curval ) ; 
    else {
	
      s = eqtb [ l ] .hh .v.RH ; 
      r = newspec ( s ) ; 
      if ( q == 91 ) 
      {
	mem [ r + 1 ] .cint = multandadd ( mem [ s + 1 ] .cint , curval , 0 , 
	1073741823L ) ; 
	mem [ r + 2 ] .cint = multandadd ( mem [ s + 2 ] .cint , curval , 0 , 
	1073741823L ) ; 
	mem [ r + 3 ] .cint = multandadd ( mem [ s + 3 ] .cint , curval , 0 , 
	1073741823L ) ; 
      } 
      else {
	  
	mem [ r + 1 ] .cint = xovern ( mem [ s + 1 ] .cint , curval ) ; 
	mem [ r + 2 ] .cint = xovern ( mem [ s + 2 ] .cint , curval ) ; 
	mem [ r + 3 ] .cint = xovern ( mem [ s + 3 ] .cint , curval ) ; 
      } 
      curval = r ; 
    } 
  } 
  if ( aritherror ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 1201 ) ; 
    } 
    {
      helpptr = 2 ; 
      helpline [ 1 ] = 1202 ; 
      helpline [ 0 ] = 1203 ; 
    } 
    error () ; 
    return ; 
  } 
  if ( p < 2 ) 
  if ( ( a >= 4 ) ) 
  geqworddefine ( l , curval ) ; 
  else eqworddefine ( l , curval ) ; 
  else {
      
    trapzeroglue () ; 
    if ( ( a >= 4 ) ) 
    geqdefine ( l , 117 , curval ) ; 
    else eqdefine ( l , 117 , curval ) ; 
  } 
} 
void alteraux ( ) 
{alteraux_regmem 
  halfword c  ; 
  if ( curchr != abs ( curlist .modefield ) ) 
  reportillegalcase () ; 
  else {
      
    c = curchr ; 
    scanoptionalequals () ; 
    if ( c == 1 ) 
    {
      scandimen ( false , false , false ) ; 
      curlist .auxfield .cint = curval ; 
    } 
    else {
	
      scanint () ; 
      if ( ( curval <= 0 ) || ( curval > 32767 ) ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1207 ) ; 
	} 
	{
	  helpptr = 1 ; 
	  helpline [ 0 ] = 1208 ; 
	} 
	interror ( curval ) ; 
      } 
      else curlist .auxfield .hh .v.LH = curval ; 
    } 
  } 
} 
void alterprevgraf ( ) 
{alterprevgraf_regmem 
  integer p  ; 
  nest [ nestptr ] = curlist ; 
  p = nestptr ; 
  while ( abs ( nest [ p ] .modefield ) != 1 ) decr ( p ) ; 
  scanoptionalequals () ; 
  scanint () ; 
  if ( curval < 0 ) 
  {
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 949 ) ; 
    } 
    printesc ( 529 ) ; 
    {
      helpptr = 1 ; 
      helpline [ 0 ] = 1209 ; 
    } 
    interror ( curval ) ; 
  } 
  else {
      
    nest [ p ] .pgfield = curval ; 
    curlist = nest [ nestptr ] ; 
  } 
} 
void alterpagesofar ( ) 
{alterpagesofar_regmem 
  char c  ; 
  c = curchr ; 
  scanoptionalequals () ; 
  scandimen ( false , false , false ) ; 
  pagesofar [ c ] = curval ; 
} 
void alterinteger ( ) 
{alterinteger_regmem 
  char c  ; 
  c = curchr ; 
  scanoptionalequals () ; 
  scanint () ; 
  if ( c == 0 ) 
  deadcycles = curval ; 
  else insertpenalties = curval ; 
} 
void alterboxdimen ( ) 
{alterboxdimen_regmem 
  smallnumber c  ; 
  eightbits b  ; 
  c = curchr ; 
  scaneightbitint () ; 
  b = curval ; 
  scanoptionalequals () ; 
  scandimen ( false , false , false ) ; 
  if ( eqtb [ 7578 + b ] .hh .v.RH != 0 ) 
  mem [ eqtb [ 7578 + b ] .hh .v.RH + c ] .cint = curval ; 
} 
void znewfont ( a ) 
smallnumber a ; 
{/* 50 */ newfont_regmem 
  halfword u  ; 
  scaled s  ; 
  internalfontnumber f  ; 
  strnumber t  ; 
  char oldsetting  ; 
  strnumber flushablestring  ; 
  if ( jobname == 0 ) 
  openlogfile () ; 
  getrtoken () ; 
  u = curcs ; 
  if ( u >= 514 ) 
  t = hash [ u ] .v.RH ; 
  else if ( u >= 257 ) 
  if ( u == 513 ) 
  t = 1213 ; 
  else t = u - 257 ; 
  else {
      
    oldsetting = selector ; 
    selector = 21 ; 
    print ( 1213 ) ; 
    print ( u - 1 ) ; 
    selector = oldsetting ; 
    {
      if ( poolptr + 1 > poolsize ) 
      overflow ( 257 , poolsize - initpoolptr ) ; 
    } 
    t = makestring () ; 
  } 
  if ( ( a >= 4 ) ) 
  geqdefine ( u , 87 , 0 ) ; 
  else eqdefine ( u , 87 , 0 ) ; 
  scanoptionalequals () ; 
  scanfilename () ; 
  nameinprogress = true ; 
  if ( scankeyword ( 1214 ) ) 
  {
    scandimen ( false , false , false ) ; 
    s = curval ; 
    if ( ( s <= 0 ) || ( s >= 134217728L ) ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1216 ) ; 
      } 
      printscaled ( s ) ; 
      print ( 1217 ) ; 
      {
	helpptr = 2 ; 
	helpline [ 1 ] = 1218 ; 
	helpline [ 0 ] = 1219 ; 
      } 
      error () ; 
      s = 10 * 65536L ; 
    } 
  } 
  else if ( scankeyword ( 1215 ) ) 
  {
    scanint () ; 
    s = - (integer) curval ; 
    if ( ( curval <= 0 ) || ( curval > 32768L ) ) 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 549 ) ; 
      } 
      {
	helpptr = 1 ; 
	helpline [ 0 ] = 550 ; 
      } 
      interror ( curval ) ; 
      s = -1000 ; 
    } 
  } 
  else s = -1000 ; 
  nameinprogress = false ; 
  flushablestring = strptr - 1 ; 
  {register integer for_end; f = 1 ; for_end = fontptr ; if ( f <= for_end) 
  do 
    if ( streqstr ( fontname [ f ] , curname ) && streqstr ( fontarea [ f ] , 
    curarea ) ) 
    {
      if ( curname == flushablestring ) 
      {
	{
	  decr ( strptr ) ; 
	  poolptr = strstart [ strptr ] ; 
	} 
	curname = fontname [ f ] ; 
      } 
      if ( s > 0 ) 
      {
	if ( s == fontsize [ f ] ) 
	goto lab50 ; 
      } 
      else if ( fontsize [ f ] == xnoverd ( fontdsize [ f ] , - (integer) s , 
      1000 ) ) 
      goto lab50 ; 
    } 
  while ( f++ < for_end ) ; } 
  f = readfontinfo ( u , curname , curarea , s ) ; 
  lab50: eqtb [ u ] .hh .v.RH = f ; 
  eqtb [ 6524 + f ] = eqtb [ u ] ; 
  hash [ 6524 + f ] .v.RH = t ; 
} 
void newinteraction ( ) 
{newinteraction_regmem 
  println () ; 
  interaction = curchr ; 
  if ( interaction == 0 ) 
  selector = 16 ; 
  else selector = 17 ; 
  if ( logopened ) 
  selector = selector + 2 ; 
} 
void doassignments ( ) 
{/* 10 */ doassignments_regmem 
  while ( true ) {
      
    do {
	getxtoken () ; 
    } while ( ! ( ( curcmd != 10 ) && ( curcmd != 0 ) ) ) ; 
    if ( curcmd <= 70 ) 
    return ; 
    setboxallowed = false ; 
    prefixedcommand () ; 
    setboxallowed = true ; 
  } 
} 
void openorclosein ( ) 
{openorclosein_regmem 
  char c  ; 
  char n  ; 
  c = curchr ; 
  scanfourbitint () ; 
  n = curval ; 
  if ( readopen [ n ] != 2 ) 
  {
    aclose ( readfile [ n ] ) ; 
    readopen [ n ] = 2 ; 
  } 
  if ( c != 0 ) 
  {
    scanoptionalequals () ; 
    scanfilename () ; 
    packfilename ( curname , curarea , curext ) ; 
    if ( ( curext != 335 ) && aopenin ( readfile [ n ] , TEXINPUTPATH ) ) 
    readopen [ n ] = 1 ; 
    else {
	
      if ( namelength + 5 < PATHMAX ) 
      {
	nameoffile [ namelength + 1 ] = 46 ; 
	nameoffile [ namelength + 2 ] = 116 ; 
	nameoffile [ namelength + 3 ] = 101 ; 
	nameoffile [ namelength + 4 ] = 120 ; 
	namelength = namelength + 4 ; 
	if ( aopenin ( readfile [ n ] , TEXINPUTPATH ) ) 
	readopen [ n ] = 1 ; 
	else {
	    
	  namelength = namelength - 4 ; 
	  nameoffile [ namelength + 1 ] = 32 ; 
	} 
      } 
    } 
  } 
} 
void issuemessage ( ) 
{issuemessage_regmem 
  char oldsetting  ; 
  char c  ; 
  strnumber s  ; 
  c = curchr ; 
  mem [ memtop - 12 ] .hh .v.RH = scantoks ( false , true ) ; 
  oldsetting = selector ; 
  selector = 21 ; 
  tokenshow ( defref ) ; 
  selector = oldsetting ; 
  flushlist ( defref ) ; 
  {
    if ( poolptr + 1 > poolsize ) 
    overflow ( 257 , poolsize - initpoolptr ) ; 
  } 
  s = makestring () ; 
  if ( c == 0 ) 
  {
    if ( termoffset + ( strstart [ s + 1 ] - strstart [ s ] ) > maxprintline - 
    2 ) 
    println () ; 
    else if ( ( termoffset > 0 ) || ( fileoffset > 0 ) ) 
    printchar ( 32 ) ; 
    slowprint ( s ) ; 
    flush ( stdout ) ; 
  } 
  else {
      
    {
      if ( interaction == 3 ) 
      ; 
      printnl ( 262 ) ; 
      print ( 335 ) ; 
    } 
    slowprint ( s ) ; 
    if ( eqtb [ 7321 ] .hh .v.RH != 0 ) 
    useerrhelp = true ; 
    else if ( longhelpseen ) 
    {
      helpptr = 1 ; 
      helpline [ 0 ] = 1226 ; 
    } 
    else {
	
      if ( interaction < 3 ) 
      longhelpseen = true ; 
      {
	helpptr = 4 ; 
	helpline [ 3 ] = 1227 ; 
	helpline [ 2 ] = 1228 ; 
	helpline [ 1 ] = 1229 ; 
	helpline [ 0 ] = 1230 ; 
      } 
    } 
    error () ; 
    useerrhelp = false ; 
  } 
  {
    decr ( strptr ) ; 
    poolptr = strstart [ strptr ] ; 
  } 
} 
void shiftcase ( ) 
{shiftcase_regmem 
  halfword b  ; 
  halfword p  ; 
  halfword t  ; 
  eightbits c  ; 
  b = curchr ; 
  p = scantoks ( false , false ) ; 
  p = mem [ defref ] .hh .v.RH ; 
  while ( p != 0 ) {
      
    t = mem [ p ] .hh .v.LH ; 
    if ( t < 4352 ) 
    {
      c = t % 256 ; 
      if ( eqtb [ b + c ] .hh .v.RH != 0 ) 
      mem [ p ] .hh .v.LH = t - c + eqtb [ b + c ] .hh .v.RH ; 
    } 
    p = mem [ p ] .hh .v.RH ; 
  } 
  begintokenlist ( mem [ defref ] .hh .v.RH , 3 ) ; 
  {
    mem [ defref ] .hh .v.RH = avail ; 
    avail = defref ; 
	;
#ifdef STAT
    decr ( dynused ) ; 
#endif /* STAT */
  } 
} 
void showwhatever ( ) 
{/* 50 */ showwhatever_regmem 
  halfword p  ; 
  switch ( curchr ) 
  {case 3 : 
    {
      begindiagnostic () ; 
      showactivities () ; 
    } 
    break ; 
  case 1 : 
    {
      scaneightbitint () ; 
      begindiagnostic () ; 
      printnl ( 1248 ) ; 
      printint ( curval ) ; 
      printchar ( 61 ) ; 
      if ( eqtb [ 7578 + curval ] .hh .v.RH == 0 ) 
      print ( 407 ) ; 
      else showbox ( eqtb [ 7578 + curval ] .hh .v.RH ) ; 
    } 
    break ; 
  case 0 : 
    {
      gettoken () ; 
      if ( interaction == 3 ) 
      ; 
      printnl ( 1242 ) ; 
      if ( curcs != 0 ) 
      {
	sprintcs ( curcs ) ; 
	printchar ( 61 ) ; 
      } 
      printmeaning () ; 
      goto lab50 ; 
    } 
    break ; 
    default: 
    {
      p = thetoks () ; 
      if ( interaction == 3 ) 
      ; 
      printnl ( 1242 ) ; 
      tokenshow ( memtop - 3 ) ; 
      flushlist ( mem [ memtop - 3 ] .hh .v.RH ) ; 
      goto lab50 ; 
    } 
    break ; 
  } 
  enddiagnostic ( true ) ; 
  {
    if ( interaction == 3 ) 
    ; 
    printnl ( 262 ) ; 
    print ( 1249 ) ; 
  } 
  if ( selector == 19 ) 
  if ( eqtb [ 9192 ] .cint <= 0 ) 
  {
    selector = 17 ; 
    print ( 1250 ) ; 
    selector = 19 ; 
  } 
  lab50: if ( interaction < 3 ) 
  {
    helpptr = 0 ; 
    decr ( errorcount ) ; 
  } 
  else if ( eqtb [ 9192 ] .cint > 0 ) 
  {
    {
      helpptr = 3 ; 
      helpline [ 2 ] = 1237 ; 
      helpline [ 1 ] = 1238 ; 
      helpline [ 0 ] = 1239 ; 
    } 
  } 
  else {
      
    {
      helpptr = 5 ; 
      helpline [ 4 ] = 1237 ; 
      helpline [ 3 ] = 1238 ; 
      helpline [ 2 ] = 1239 ; 
      helpline [ 1 ] = 1240 ; 
      helpline [ 0 ] = 1241 ; 
    } 
  } 
  error () ; 
} 
void znewwhatsit ( s , w ) 
smallnumber s ; 
smallnumber w ; 
{newwhatsit_regmem 
  halfword p  ; 
  p = getnode ( w ) ; 
  mem [ p ] .hh.b0 = 8 ; 
  mem [ p ] .hh.b1 = s ; 
  mem [ curlist .tailfield ] .hh .v.RH = p ; 
  curlist .tailfield = p ; 
} 
void znewwritewhatsit ( w ) 
smallnumber w ; 
{newwritewhatsit_regmem 
  newwhatsit ( curchr , w ) ; 
  if ( w != 2 ) 
  scanfourbitint () ; 
  else {
      
    scanint () ; 
    if ( curval < 0 ) 
    curval = 17 ; 
    else if ( curval > 15 ) 
    curval = 16 ; 
  } 
  mem [ curlist .tailfield + 1 ] .hh .v.LH = curval ; 
} 
void doextension ( ) 
{doextension_regmem 
  integer i, j, k  ; 
  halfword p, q, r  ; 
  switch ( curchr ) 
  {case 0 : 
    {
      newwritewhatsit ( 3 ) ; 
      scanoptionalequals () ; 
      scanfilename () ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = curname ; 
      mem [ curlist .tailfield + 2 ] .hh .v.LH = curarea ; 
      mem [ curlist .tailfield + 2 ] .hh .v.RH = curext ; 
    } 
    break ; 
  case 1 : 
    {
      k = curcs ; 
      newwritewhatsit ( 2 ) ; 
      curcs = k ; 
      p = scantoks ( false , false ) ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = defref ; 
    } 
    break ; 
  case 2 : 
    {
      newwritewhatsit ( 2 ) ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = 0 ; 
    } 
    break ; 
  case 3 : 
    {
      newwhatsit ( 3 , 2 ) ; 
      mem [ curlist .tailfield + 1 ] .hh .v.LH = 0 ; 
      p = scantoks ( false , true ) ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = defref ; 
    } 
    break ; 
  case 4 : 
    {
      getxtoken () ; 
      if ( ( curcmd == 59 ) && ( curchr <= 2 ) ) 
      {
	p = curlist .tailfield ; 
	doextension () ; 
	outwhat ( curlist .tailfield ) ; 
	flushnodelist ( curlist .tailfield ) ; 
	curlist .tailfield = p ; 
	mem [ p ] .hh .v.RH = 0 ; 
      } 
      else backinput () ; 
    } 
    break ; 
  case 5 : 
    if ( abs ( curlist .modefield ) != 102 ) 
    reportillegalcase () ; 
    else {
	
      newwhatsit ( 4 , 2 ) ; 
      scanint () ; 
      if ( curval <= 0 ) 
      curlist .auxfield .hh .v.RH = 0 ; 
      else if ( curval > 255 ) 
      curlist .auxfield .hh .v.RH = 0 ; 
      else curlist .auxfield .hh .v.RH = curval ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = curlist .auxfield .hh .v.RH ; 
      mem [ curlist .tailfield + 1 ] .hh.b0 = normmin ( eqtb [ 9214 ] .cint ) 
      ; 
      mem [ curlist .tailfield + 1 ] .hh.b1 = normmin ( eqtb [ 9215 ] .cint ) 
      ; 
    } 
    break ; 
    default: 
    confusion ( 1285 ) ; 
    break ; 
  } 
} 
void fixlanguage ( ) 
{fixlanguage_regmem 
  ASCIIcode l  ; 
  if ( eqtb [ 9213 ] .cint <= 0 ) 
  l = 0 ; 
  else if ( eqtb [ 9213 ] .cint > 255 ) 
  l = 0 ; 
  else l = eqtb [ 9213 ] .cint ; 
  if ( l != curlist .auxfield .hh .v.RH ) 
  {
    newwhatsit ( 4 , 2 ) ; 
    mem [ curlist .tailfield + 1 ] .hh .v.RH = l ; 
    curlist .auxfield .hh .v.RH = l ; 
    mem [ curlist .tailfield + 1 ] .hh.b0 = normmin ( eqtb [ 9214 ] .cint ) ; 
    mem [ curlist .tailfield + 1 ] .hh.b1 = normmin ( eqtb [ 9215 ] .cint ) ; 
  } 
} 
void handlerightbrace ( ) 
{handlerightbrace_regmem 
  halfword p, q  ; 
  scaled d  ; 
  integer f  ; 
  switch ( curgroup ) 
  {case 1 : 
    unsave () ; 
    break ; 
  case 0 : 
    {
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 1038 ) ; 
      } 
      {
	helpptr = 2 ; 
	helpline [ 1 ] = 1039 ; 
	helpline [ 0 ] = 1040 ; 
      } 
      error () ; 
    } 
    break ; 
  case 14 : 
  case 15 : 
  case 16 : 
    extrarightbrace () ; 
    break ; 
  case 2 : 
    package ( 0 ) ; 
    break ; 
  case 3 : 
    {
      adjusttail = memtop - 5 ; 
      package ( 0 ) ; 
    } 
    break ; 
  case 4 : 
    {
      endgraf () ; 
      package ( 0 ) ; 
    } 
    break ; 
  case 5 : 
    {
      endgraf () ; 
      package ( 4 ) ; 
    } 
    break ; 
  case 11 : 
    {
      endgraf () ; 
      q = eqtb [ 6792 ] .hh .v.RH ; 
      incr ( mem [ q ] .hh .v.RH ) ; 
      d = eqtb [ 9736 ] .cint ; 
      f = eqtb [ 9205 ] .cint ; 
      unsave () ; 
      decr ( saveptr ) ; 
      p = vpackage ( mem [ curlist .headfield ] .hh .v.RH , 0 , 1 , 
      1073741823L ) ; 
      popnest () ; 
      if ( savestack [ saveptr + 0 ] .cint < 255 ) 
      {
	{
	  mem [ curlist .tailfield ] .hh .v.RH = getnode ( 5 ) ; 
	  curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
	} 
	mem [ curlist .tailfield ] .hh.b0 = 3 ; 
	mem [ curlist .tailfield ] .hh.b1 = savestack [ saveptr + 0 ] .cint ; 
	mem [ curlist .tailfield + 3 ] .cint = mem [ p + 3 ] .cint + mem [ p + 
	2 ] .cint ; 
	mem [ curlist .tailfield + 4 ] .hh .v.LH = mem [ p + 5 ] .hh .v.RH ; 
	mem [ curlist .tailfield + 4 ] .hh .v.RH = q ; 
	mem [ curlist .tailfield + 2 ] .cint = d ; 
	mem [ curlist .tailfield + 1 ] .cint = f ; 
      } 
      else {
	  
	{
	  mem [ curlist .tailfield ] .hh .v.RH = getnode ( 2 ) ; 
	  curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
	} 
	mem [ curlist .tailfield ] .hh.b0 = 5 ; 
	mem [ curlist .tailfield ] .hh.b1 = 0 ; 
	mem [ curlist .tailfield + 1 ] .cint = mem [ p + 5 ] .hh .v.RH ; 
	deleteglueref ( q ) ; 
      } 
      freenode ( p , 7 ) ; 
      if ( nestptr == 0 ) 
      buildpage () ; 
    } 
    break ; 
  case 8 : 
    {
      if ( ( curinput .locfield != 0 ) || ( ( curinput .indexfield != 6 ) && ( 
      curinput .indexfield != 3 ) ) ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1004 ) ; 
	} 
	{
	  helpptr = 2 ; 
	  helpline [ 1 ] = 1005 ; 
	  helpline [ 0 ] = 1006 ; 
	} 
	error () ; 
	do {
	    gettoken () ; 
	} while ( ! ( curinput .locfield == 0 ) ) ; 
      } 
      endtokenlist () ; 
      endgraf () ; 
      unsave () ; 
      outputactive = false ; 
      insertpenalties = 0 ; 
      if ( eqtb [ 7833 ] .hh .v.RH != 0 ) 
      {
	{
	  if ( interaction == 3 ) 
	  ; 
	  printnl ( 262 ) ; 
	  print ( 1007 ) ; 
	} 
	printesc ( 406 ) ; 
	printint ( 255 ) ; 
	{
	  helpptr = 3 ; 
	  helpline [ 2 ] = 1008 ; 
	  helpline [ 1 ] = 1009 ; 
	  helpline [ 0 ] = 1010 ; 
	} 
	boxerror ( 255 ) ; 
      } 
      if ( curlist .tailfield != curlist .headfield ) 
      {
	mem [ pagetail ] .hh .v.RH = mem [ curlist .headfield ] .hh .v.RH ; 
	pagetail = curlist .tailfield ; 
      } 
      if ( mem [ memtop - 2 ] .hh .v.RH != 0 ) 
      {
	if ( mem [ memtop - 1 ] .hh .v.RH == 0 ) 
	nest [ 0 ] .tailfield = pagetail ; 
	mem [ pagetail ] .hh .v.RH = mem [ memtop - 1 ] .hh .v.RH ; 
	mem [ memtop - 1 ] .hh .v.RH = mem [ memtop - 2 ] .hh .v.RH ; 
	mem [ memtop - 2 ] .hh .v.RH = 0 ; 
	pagetail = memtop - 2 ; 
      } 
      popnest () ; 
      buildpage () ; 
    } 
    break ; 
  case 10 : 
    builddiscretionary () ; 
    break ; 
  case 6 : 
    {
      backinput () ; 
      curtok = 10610 ; 
      {
	if ( interaction == 3 ) 
	; 
	printnl ( 262 ) ; 
	print ( 622 ) ; 
      } 
      printesc ( 893 ) ; 
      print ( 623 ) ; 
      {
	helpptr = 1 ; 
	helpline [ 0 ] = 1119 ; 
      } 
      inserror () ; 
    } 
    break ; 
  case 7 : 
    {
      endgraf () ; 
      unsave () ; 
      alignpeek () ; 
    } 
    break ; 
  case 12 : 
    {
      endgraf () ; 
      unsave () ; 
      saveptr = saveptr - 2 ; 
      p = vpackage ( mem [ curlist .headfield ] .hh .v.RH , savestack [ 
      saveptr + 1 ] .cint , savestack [ saveptr + 0 ] .cint , 1073741823L ) ; 
      popnest () ; 
      {
	mem [ curlist .tailfield ] .hh .v.RH = newnoad () ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      mem [ curlist .tailfield ] .hh.b0 = 29 ; 
      mem [ curlist .tailfield + 1 ] .hh .v.RH = 2 ; 
      mem [ curlist .tailfield + 1 ] .hh .v.LH = p ; 
    } 
    break ; 
  case 13 : 
    buildchoices () ; 
    break ; 
  case 9 : 
    {
      unsave () ; 
      decr ( saveptr ) ; 
      mem [ savestack [ saveptr + 0 ] .cint ] .hh .v.RH = 3 ; 
      p = finmlist ( 0 ) ; 
      mem [ savestack [ saveptr + 0 ] .cint ] .hh .v.LH = p ; 
      if ( p != 0 ) 
      if ( mem [ p ] .hh .v.RH == 0 ) 
      if ( mem [ p ] .hh.b0 == 16 ) 
      {
	if ( mem [ p + 3 ] .hh .v.RH == 0 ) 
	if ( mem [ p + 2 ] .hh .v.RH == 0 ) 
	{
	  mem [ savestack [ saveptr + 0 ] .cint ] .hh = mem [ p + 1 ] .hh ; 
	  freenode ( p , 4 ) ; 
	} 
      } 
      else if ( mem [ p ] .hh.b0 == 28 ) 
      if ( savestack [ saveptr + 0 ] .cint == curlist .tailfield + 1 ) 
      if ( mem [ curlist .tailfield ] .hh.b0 == 16 ) 
      {
	q = curlist .headfield ; 
	while ( mem [ q ] .hh .v.RH != curlist .tailfield ) q = mem [ q ] .hh 
	.v.RH ; 
	mem [ q ] .hh .v.RH = p ; 
	freenode ( curlist .tailfield , 4 ) ; 
	curlist .tailfield = p ; 
      } 
    } 
    break ; 
    default: 
    confusion ( 1041 ) ; 
    break ; 
  } 
} 
void maincontrol ( ) 
{/* 60 21 70 80 90 91 92 95 100 101 110 111 112 120 10 */ maincontrol_regmem 
  integer t  ; 
  if ( eqtb [ 7319 ] .hh .v.RH != 0 ) 
  begintokenlist ( eqtb [ 7319 ] .hh .v.RH , 12 ) ; 
  lab60: getxtoken () ; 
  lab21: if ( interrupt != 0 ) 
  if ( OKtointerrupt ) 
  {
    backinput () ; 
    {
      if ( interrupt != 0 ) 
      pauseforinstructions () ; 
    } 
    goto lab60 ; 
  } 
	;
#ifdef DEBUG
  if ( panicking ) 
  checkmem ( false ) ; 
#endif /* DEBUG */
  if ( eqtb [ 9199 ] .cint > 0 ) 
  showcurcmdchr () ; 
  switch ( abs ( curlist .modefield ) + curcmd ) 
  {case 113 : 
  case 114 : 
  case 170 : 
    goto lab70 ; 
    break ; 
  case 118 : 
    {
      scancharnum () ; 
      curchr = curval ; 
      goto lab70 ; 
    } 
    break ; 
  case 167 : 
    {
      getxtoken () ; 
      if ( ( curcmd == 11 ) || ( curcmd == 12 ) || ( curcmd == 68 ) || ( 
      curcmd == 16 ) ) 
      cancelboundary = true ; 
      goto lab21 ; 
    } 
    break ; 
  case 112 : 
    if ( curlist .auxfield .hh .v.LH == 1000 ) 
    goto lab120 ; 
    else appspace () ; 
    break ; 
  case 166 : 
  case 267 : 
    goto lab120 ; 
    break ; 
  case 1 : 
  case 102 : 
  case 203 : 
  case 11 : 
  case 213 : 
  case 268 : 
    ; 
    break ; 
  case 40 : 
  case 141 : 
  case 242 : 
    {
      do {
	  getxtoken () ; 
      } while ( ! ( curcmd != 10 ) ) ; 
      goto lab21 ; 
    } 
    break ; 
  case 15 : 
    if ( itsallover () ) 
    return ; 
    break ; 
  case 23 : 
  case 123 : 
  case 224 : 
  case 71 : 
  case 172 : 
  case 273 : 
  case 39 : 
  case 45 : 
  case 49 : 
  case 150 : 
  case 7 : 
  case 108 : 
  case 209 : 
    reportillegalcase () ; 
    break ; 
  case 8 : 
  case 109 : 
  case 9 : 
  case 110 : 
  case 18 : 
  case 119 : 
  case 70 : 
  case 171 : 
  case 51 : 
  case 152 : 
  case 16 : 
  case 117 : 
  case 50 : 
  case 151 : 
  case 53 : 
  case 154 : 
  case 67 : 
  case 168 : 
  case 54 : 
  case 155 : 
  case 55 : 
  case 156 : 
  case 57 : 
  case 158 : 
  case 56 : 
  case 157 : 
  case 31 : 
  case 132 : 
  case 52 : 
  case 153 : 
  case 29 : 
  case 130 : 
  case 47 : 
  case 148 : 
  case 212 : 
  case 216 : 
  case 217 : 
  case 230 : 
  case 227 : 
  case 236 : 
  case 239 : 
    insertdollarsign () ; 
    break ; 
  case 37 : 
  case 137 : 
  case 238 : 
    {
      {
	mem [ curlist .tailfield ] .hh .v.RH = scanrulespec () ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      if ( abs ( curlist .modefield ) == 1 ) 
      curlist .auxfield .cint = -65536000L ; 
      else if ( abs ( curlist .modefield ) == 102 ) 
      curlist .auxfield .hh .v.LH = 1000 ; 
    } 
    break ; 
  case 28 : 
  case 128 : 
  case 229 : 
  case 231 : 
    appendglue () ; 
    break ; 
  case 30 : 
  case 131 : 
  case 232 : 
  case 233 : 
    appendkern () ; 
    break ; 
  case 2 : 
  case 103 : 
    newsavelevel ( 1 ) ; 
    break ; 
  case 62 : 
  case 163 : 
  case 264 : 
    newsavelevel ( 14 ) ; 
    break ; 
  case 63 : 
  case 164 : 
  case 265 : 
    if ( curgroup == 14 ) 
    unsave () ; 
    else offsave () ; 
    break ; 
  case 3 : 
  case 104 : 
  case 205 : 
    handlerightbrace () ; 
    break ; 
  case 22 : 
  case 124 : 
  case 225 : 
    {
      t = curchr ; 
      scandimen ( false , false , false ) ; 
      if ( t == 0 ) 
      scanbox ( curval ) ; 
      else scanbox ( - (integer) curval ) ; 
    } 
    break ; 
  case 32 : 
  case 133 : 
  case 234 : 
    scanbox ( 1073742237L + curchr ) ; 
    break ; 
  case 21 : 
  case 122 : 
  case 223 : 
    beginbox ( 0 ) ; 
    break ; 
  case 44 : 
    newgraf ( curchr > 0 ) ; 
    break ; 
  case 12 : 
  case 13 : 
  case 17 : 
  case 69 : 
  case 4 : 
  case 24 : 
  case 36 : 
  case 46 : 
  case 48 : 
  case 27 : 
  case 34 : 
  case 65 : 
  case 66 : 
    {
      backinput () ; 
      newgraf ( true ) ; 
    } 
    break ; 
  case 145 : 
  case 246 : 
    indentinhmode () ; 
    break ; 
  case 14 : 
    {
      normalparagraph () ; 
      if ( curlist .modefield > 0 ) 
      buildpage () ; 
    } 
    break ; 
  case 115 : 
    {
      if ( alignstate < 0 ) 
      offsave () ; 
      endgraf () ; 
      if ( curlist .modefield == 1 ) 
      buildpage () ; 
    } 
    break ; 
  case 116 : 
  case 129 : 
  case 138 : 
  case 126 : 
  case 134 : 
    headforvmode () ; 
    break ; 
  case 38 : 
  case 139 : 
  case 240 : 
  case 140 : 
  case 241 : 
    begininsertoradjust () ; 
    break ; 
  case 19 : 
  case 120 : 
  case 221 : 
    makemark () ; 
    break ; 
  case 43 : 
  case 144 : 
  case 245 : 
    appendpenalty () ; 
    break ; 
  case 26 : 
  case 127 : 
  case 228 : 
    deletelast () ; 
    break ; 
  case 25 : 
  case 125 : 
  case 226 : 
    unpackage () ; 
    break ; 
  case 146 : 
    appenditaliccorrection () ; 
    break ; 
  case 247 : 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newkern ( 0 ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    break ; 
  case 149 : 
  case 250 : 
    appenddiscretionary () ; 
    break ; 
  case 147 : 
    makeaccent () ; 
    break ; 
  case 6 : 
  case 107 : 
  case 208 : 
  case 5 : 
  case 106 : 
  case 207 : 
    alignerror () ; 
    break ; 
  case 35 : 
  case 136 : 
  case 237 : 
    noalignerror () ; 
    break ; 
  case 64 : 
  case 165 : 
  case 266 : 
    omiterror () ; 
    break ; 
  case 33 : 
  case 135 : 
    initalign () ; 
    break ; 
  case 235 : 
    if ( privileged () ) 
    if ( curgroup == 15 ) 
    initalign () ; 
    else offsave () ; 
    break ; 
  case 10 : 
  case 111 : 
    doendv () ; 
    break ; 
  case 68 : 
  case 169 : 
  case 270 : 
    cserror () ; 
    break ; 
  case 105 : 
    initmath () ; 
    break ; 
  case 251 : 
    if ( privileged () ) 
    if ( curgroup == 15 ) 
    starteqno () ; 
    else offsave () ; 
    break ; 
  case 204 : 
    {
      {
	mem [ curlist .tailfield ] .hh .v.RH = newnoad () ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      backinput () ; 
      scanmath ( curlist .tailfield + 1 ) ; 
    } 
    break ; 
  case 214 : 
  case 215 : 
  case 271 : 
    setmathchar ( eqtb [ 8907 + curchr ] .hh .v.RH ) ; 
    break ; 
  case 219 : 
    {
      scancharnum () ; 
      curchr = curval ; 
      setmathchar ( eqtb [ 8907 + curchr ] .hh .v.RH ) ; 
    } 
    break ; 
  case 220 : 
    {
      scanfifteenbitint () ; 
      setmathchar ( curval ) ; 
    } 
    break ; 
  case 272 : 
    setmathchar ( curchr ) ; 
    break ; 
  case 218 : 
    {
      scantwentysevenbitint () ; 
      setmathchar ( curval / 4096 ) ; 
    } 
    break ; 
  case 253 : 
    {
      {
	mem [ curlist .tailfield ] .hh .v.RH = newnoad () ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      mem [ curlist .tailfield ] .hh.b0 = curchr ; 
      scanmath ( curlist .tailfield + 1 ) ; 
    } 
    break ; 
  case 254 : 
    mathlimitswitch () ; 
    break ; 
  case 269 : 
    mathradical () ; 
    break ; 
  case 248 : 
  case 249 : 
    mathac () ; 
    break ; 
  case 259 : 
    {
      scanspec ( 12 , false ) ; 
      normalparagraph () ; 
      pushnest () ; 
      curlist .modefield = -1 ; 
      curlist .auxfield .cint = -65536000L ; 
      if ( eqtb [ 7318 ] .hh .v.RH != 0 ) 
      begintokenlist ( eqtb [ 7318 ] .hh .v.RH , 11 ) ; 
    } 
    break ; 
  case 256 : 
    {
      mem [ curlist .tailfield ] .hh .v.RH = newstyle ( curchr ) ; 
      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
    } 
    break ; 
  case 258 : 
    {
      {
	mem [ curlist .tailfield ] .hh .v.RH = newglue ( 0 ) ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      mem [ curlist .tailfield ] .hh.b1 = 98 ; 
    } 
    break ; 
  case 257 : 
    appendchoices () ; 
    break ; 
  case 211 : 
  case 210 : 
    subsup () ; 
    break ; 
  case 255 : 
    mathfraction () ; 
    break ; 
  case 252 : 
    mathleftright () ; 
    break ; 
  case 206 : 
    if ( curgroup == 15 ) 
    aftermath () ; 
    else offsave () ; 
    break ; 
  case 72 : 
  case 173 : 
  case 274 : 
  case 73 : 
  case 174 : 
  case 275 : 
  case 74 : 
  case 175 : 
  case 276 : 
  case 75 : 
  case 176 : 
  case 277 : 
  case 76 : 
  case 177 : 
  case 278 : 
  case 77 : 
  case 178 : 
  case 279 : 
  case 78 : 
  case 179 : 
  case 280 : 
  case 79 : 
  case 180 : 
  case 281 : 
  case 80 : 
  case 181 : 
  case 282 : 
  case 81 : 
  case 182 : 
  case 283 : 
  case 82 : 
  case 183 : 
  case 284 : 
  case 83 : 
  case 184 : 
  case 285 : 
  case 84 : 
  case 185 : 
  case 286 : 
  case 85 : 
  case 186 : 
  case 287 : 
  case 86 : 
  case 187 : 
  case 288 : 
  case 87 : 
  case 188 : 
  case 289 : 
  case 88 : 
  case 189 : 
  case 290 : 
  case 89 : 
  case 190 : 
  case 291 : 
  case 90 : 
  case 191 : 
  case 292 : 
  case 91 : 
  case 192 : 
  case 293 : 
  case 92 : 
  case 193 : 
  case 294 : 
  case 93 : 
  case 194 : 
  case 295 : 
  case 94 : 
  case 195 : 
  case 296 : 
  case 95 : 
  case 196 : 
  case 297 : 
  case 96 : 
  case 197 : 
  case 298 : 
  case 97 : 
  case 198 : 
  case 299 : 
  case 98 : 
  case 199 : 
  case 300 : 
  case 99 : 
  case 200 : 
  case 301 : 
  case 100 : 
  case 201 : 
  case 302 : 
  case 101 : 
  case 202 : 
  case 303 : 
    prefixedcommand () ; 
    break ; 
  case 41 : 
  case 142 : 
  case 243 : 
    {
      gettoken () ; 
      aftertoken = curtok ; 
    } 
    break ; 
  case 42 : 
  case 143 : 
  case 244 : 
    {
      gettoken () ; 
      saveforafter ( curtok ) ; 
    } 
    break ; 
  case 61 : 
  case 162 : 
  case 263 : 
    openorclosein () ; 
    break ; 
  case 59 : 
  case 160 : 
  case 261 : 
    issuemessage () ; 
    break ; 
  case 58 : 
  case 159 : 
  case 260 : 
    shiftcase () ; 
    break ; 
  case 20 : 
  case 121 : 
  case 222 : 
    showwhatever () ; 
    break ; 
  case 60 : 
  case 161 : 
  case 262 : 
    doextension () ; 
    break ; 
  } 
  goto lab60 ; 
  lab70: mains = eqtb [ 8651 + curchr ] .hh .v.RH ; 
  if ( mains == 1000 ) 
  curlist .auxfield .hh .v.LH = 1000 ; 
  else if ( mains < 1000 ) 
  {
    if ( mains > 0 ) 
    curlist .auxfield .hh .v.LH = mains ; 
  } 
  else if ( curlist .auxfield .hh .v.LH < 1000 ) 
  curlist .auxfield .hh .v.LH = 1000 ; 
  else curlist .auxfield .hh .v.LH = mains ; 
  mainf = eqtb [ 7834 ] .hh .v.RH ; 
  bchar = fontbchar [ mainf ] ; 
  falsebchar = fontfalsebchar [ mainf ] ; 
  if ( curlist .modefield > 0 ) 
  if ( eqtb [ 9213 ] .cint != curlist .auxfield .hh .v.RH ) 
  fixlanguage () ; 
  {
    ligstack = avail ; 
    if ( ligstack == 0 ) 
    ligstack = getavail () ; 
    else {
	
      avail = mem [ ligstack ] .hh .v.RH ; 
      mem [ ligstack ] .hh .v.RH = 0 ; 
	;
#ifdef STAT
      incr ( dynused ) ; 
#endif /* STAT */
    } 
  } 
  mem [ ligstack ] .hh.b0 = mainf ; 
  curl = curchr ; 
  mem [ ligstack ] .hh.b1 = curl ; 
  curq = curlist .tailfield ; 
  if ( cancelboundary ) 
  {
    cancelboundary = false ; 
    maink = 0 ; 
  } 
  else maink = bcharlabel [ mainf ] ; 
  if ( maink == 0 ) 
  goto lab92 ; 
  curr = curl ; 
  curl = 256 ; 
  goto lab111 ; 
  lab80: if ( curl < 256 ) 
  {
    if ( mem [ curlist .tailfield ] .hh.b1 == hyphenchar [ mainf ] ) 
    if ( mem [ curq ] .hh .v.RH > 0 ) 
    insdisc = true ; 
    if ( ligaturepresent ) 
    {
      mainp = newligature ( mainf , curl , mem [ curq ] .hh .v.RH ) ; 
      if ( lfthit ) 
      {
	mem [ mainp ] .hh.b1 = 2 ; 
	lfthit = false ; 
      } 
      if ( rthit ) 
      if ( ligstack == 0 ) 
      {
	incr ( mem [ mainp ] .hh.b1 ) ; 
	rthit = false ; 
      } 
      mem [ curq ] .hh .v.RH = mainp ; 
      curlist .tailfield = mainp ; 
      ligaturepresent = false ; 
    } 
    if ( insdisc ) 
    {
      insdisc = false ; 
      if ( curlist .modefield > 0 ) 
      {
	mem [ curlist .tailfield ] .hh .v.RH = newdisc () ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
    } 
  } 
  lab90: if ( ligstack == 0 ) 
  goto lab21 ; 
  curq = curlist .tailfield ; 
  curl = mem [ ligstack ] .hh.b1 ; 
  lab91: if ( ! ( ligstack >= himemmin ) ) 
  goto lab95 ; 
  lab92: if ( ( curchr < fontbc [ mainf ] ) || ( curchr > fontec [ mainf ] ) ) 
  {
    charwarning ( mainf , curchr ) ; 
    {
      mem [ ligstack ] .hh .v.RH = avail ; 
      avail = ligstack ; 
	;
#ifdef STAT
      decr ( dynused ) ; 
#endif /* STAT */
    } 
    goto lab60 ; 
  } 
  maini = fontinfo [ charbase [ mainf ] + curl ] .qqqq ; 
  if ( ! ( maini .b0 > 0 ) ) 
  {
    charwarning ( mainf , curchr ) ; 
    {
      mem [ ligstack ] .hh .v.RH = avail ; 
      avail = ligstack ; 
	;
#ifdef STAT
      decr ( dynused ) ; 
#endif /* STAT */
    } 
    goto lab60 ; 
  } 
  {
    mem [ curlist .tailfield ] .hh .v.RH = ligstack ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  lab100: getnext () ; 
  if ( curcmd == 11 ) 
  goto lab101 ; 
  if ( curcmd == 12 ) 
  goto lab101 ; 
  if ( curcmd == 68 ) 
  goto lab101 ; 
  xtoken () ; 
  if ( curcmd == 11 ) 
  goto lab101 ; 
  if ( curcmd == 12 ) 
  goto lab101 ; 
  if ( curcmd == 68 ) 
  goto lab101 ; 
  if ( curcmd == 16 ) 
  {
    scancharnum () ; 
    curchr = curval ; 
    goto lab101 ; 
  } 
  if ( curcmd == 65 ) 
  bchar = 256 ; 
  curr = bchar ; 
  ligstack = 0 ; 
  goto lab110 ; 
  lab101: mains = eqtb [ 8651 + curchr ] .hh .v.RH ; 
  if ( mains == 1000 ) 
  curlist .auxfield .hh .v.LH = 1000 ; 
  else if ( mains < 1000 ) 
  {
    if ( mains > 0 ) 
    curlist .auxfield .hh .v.LH = mains ; 
  } 
  else if ( curlist .auxfield .hh .v.LH < 1000 ) 
  curlist .auxfield .hh .v.LH = 1000 ; 
  else curlist .auxfield .hh .v.LH = mains ; 
  {
    ligstack = avail ; 
    if ( ligstack == 0 ) 
    ligstack = getavail () ; 
    else {
	
      avail = mem [ ligstack ] .hh .v.RH ; 
      mem [ ligstack ] .hh .v.RH = 0 ; 
	;
#ifdef STAT
      incr ( dynused ) ; 
#endif /* STAT */
    } 
  } 
  mem [ ligstack ] .hh.b0 = mainf ; 
  curr = curchr ; 
  mem [ ligstack ] .hh.b1 = curr ; 
  if ( curr == falsebchar ) 
  curr = 256 ; 
  lab110: if ( ( ( maini .b2 ) % 4 ) != 1 ) 
  goto lab80 ; 
  maink = ligkernbase [ mainf ] + maini .b3 ; 
  mainj = fontinfo [ maink ] .qqqq ; 
  if ( mainj .b0 <= 128 ) 
  goto lab112 ; 
  maink = ligkernbase [ mainf ] + 256 * mainj .b2 + mainj .b3 + 32768L - 256 * 
  ( 128 ) ; 
  lab111: mainj = fontinfo [ maink ] .qqqq ; 
  lab112: if ( mainj .b1 == curr ) 
  if ( mainj .b0 <= 128 ) 
  {
    if ( mainj .b2 >= 128 ) 
    {
      if ( curl < 256 ) 
      {
	if ( mem [ curlist .tailfield ] .hh.b1 == hyphenchar [ mainf ] ) 
	if ( mem [ curq ] .hh .v.RH > 0 ) 
	insdisc = true ; 
	if ( ligaturepresent ) 
	{
	  mainp = newligature ( mainf , curl , mem [ curq ] .hh .v.RH ) ; 
	  if ( lfthit ) 
	  {
	    mem [ mainp ] .hh.b1 = 2 ; 
	    lfthit = false ; 
	  } 
	  if ( rthit ) 
	  if ( ligstack == 0 ) 
	  {
	    incr ( mem [ mainp ] .hh.b1 ) ; 
	    rthit = false ; 
	  } 
	  mem [ curq ] .hh .v.RH = mainp ; 
	  curlist .tailfield = mainp ; 
	  ligaturepresent = false ; 
	} 
	if ( insdisc ) 
	{
	  insdisc = false ; 
	  if ( curlist .modefield > 0 ) 
	  {
	    mem [ curlist .tailfield ] .hh .v.RH = newdisc () ; 
	    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
	  } 
	} 
      } 
      {
	mem [ curlist .tailfield ] .hh .v.RH = newkern ( fontinfo [ kernbase [ 
	mainf ] + 256 * mainj .b2 + mainj .b3 ] .cint ) ; 
	curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
      } 
      goto lab90 ; 
    } 
    if ( curl == 256 ) 
    lfthit = true ; 
    else if ( ligstack == 0 ) 
    rthit = true ; 
    {
      if ( interrupt != 0 ) 
      pauseforinstructions () ; 
    } 
    switch ( mainj .b2 ) 
    {case 1 : 
    case 5 : 
      {
	curl = mainj .b3 ; 
	maini = fontinfo [ charbase [ mainf ] + curl ] .qqqq ; 
	ligaturepresent = true ; 
      } 
      break ; 
    case 2 : 
    case 6 : 
      {
	curr = mainj .b3 ; 
	if ( ligstack == 0 ) 
	{
	  ligstack = newligitem ( curr ) ; 
	  bchar = 256 ; 
	} 
	else if ( ( ligstack >= himemmin ) ) 
	{
	  mainp = ligstack ; 
	  ligstack = newligitem ( curr ) ; 
	  mem [ ligstack + 1 ] .hh .v.RH = mainp ; 
	} 
	else mem [ ligstack ] .hh.b1 = curr ; 
      } 
      break ; 
    case 3 : 
      {
	curr = mainj .b3 ; 
	mainp = ligstack ; 
	ligstack = newligitem ( curr ) ; 
	mem [ ligstack ] .hh .v.RH = mainp ; 
      } 
      break ; 
    case 7 : 
    case 11 : 
      {
	if ( curl < 256 ) 
	{
	  if ( mem [ curlist .tailfield ] .hh.b1 == hyphenchar [ mainf ] ) 
	  if ( mem [ curq ] .hh .v.RH > 0 ) 
	  insdisc = true ; 
	  if ( ligaturepresent ) 
	  {
	    mainp = newligature ( mainf , curl , mem [ curq ] .hh .v.RH ) ; 
	    if ( lfthit ) 
	    {
	      mem [ mainp ] .hh.b1 = 2 ; 
	      lfthit = false ; 
	    } 
	    if ( false ) 
	    if ( ligstack == 0 ) 
	    {
	      incr ( mem [ mainp ] .hh.b1 ) ; 
	      rthit = false ; 
	    } 
	    mem [ curq ] .hh .v.RH = mainp ; 
	    curlist .tailfield = mainp ; 
	    ligaturepresent = false ; 
	  } 
	  if ( insdisc ) 
	  {
	    insdisc = false ; 
	    if ( curlist .modefield > 0 ) 
	    {
	      mem [ curlist .tailfield ] .hh .v.RH = newdisc () ; 
	      curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
	    } 
	  } 
	} 
	curq = curlist .tailfield ; 
	curl = mainj .b3 ; 
	maini = fontinfo [ charbase [ mainf ] + curl ] .qqqq ; 
	ligaturepresent = true ; 
      } 
      break ; 
      default: 
      {
	curl = mainj .b3 ; 
	ligaturepresent = true ; 
	if ( ligstack == 0 ) 
	goto lab80 ; 
	else goto lab91 ; 
      } 
      break ; 
    } 
    if ( mainj .b2 > 4 ) 
    if ( mainj .b2 != 7 ) 
    goto lab80 ; 
    if ( curl < 256 ) 
    goto lab110 ; 
    maink = bcharlabel [ mainf ] ; 
    goto lab111 ; 
  } 
  if ( mainj .b0 == 0 ) 
  incr ( maink ) ; 
  else {
      
    if ( mainj .b0 >= 128 ) 
    goto lab80 ; 
    maink = maink + mainj .b0 + 1 ; 
  } 
  goto lab111 ; 
  lab95: mainp = mem [ ligstack + 1 ] .hh .v.RH ; 
  if ( mainp > 0 ) 
  {
    mem [ curlist .tailfield ] .hh .v.RH = mainp ; 
    curlist .tailfield = mem [ curlist .tailfield ] .hh .v.RH ; 
  } 
  tempptr = ligstack ; 
  ligstack = mem [ tempptr ] .hh .v.RH ; 
  freenode ( tempptr , 2 ) ; 
  maini = fontinfo [ charbase [ mainf ] + curl ] .qqqq ; 
  ligaturepresent = true ; 
  if ( ligstack == 0 ) 
  if ( mainp > 0 ) 
  goto lab100 ; 
  else curr = bchar ; 
  else curr = mem [ ligstack ] .hh.b1 ; 
  goto lab110 ; 
  lab120: if ( eqtb [ 6794 ] .hh .v.RH == 0 ) 
  {
    {
      mainp = fontglue [ eqtb [ 7834 ] .hh .v.RH ] ; 
      if ( mainp == 0 ) 
      {
	mainp = newspec ( 0 ) ; 
	maink = parambase [ eqtb [ 7834 ] .hh .v.RH ] + 2 ; 
	mem [ mainp + 1 ] .cint = fontinfo [ maink ] .cint ; 
	mem [ mainp + 2 ] .cint = fontinfo [ maink + 1 ] .cint ; 
	mem [ mainp + 3 ] .cint = fontinfo [ maink + 2 ] .cint ; 
	fontglue [ eqtb [ 7834 ] .hh .v.RH ] = mainp ; 
      } 
    } 
    tempptr = newglue ( mainp ) ; 
  } 
  else tempptr = newparamglue ( 12 ) ; 
  mem [ curlist .tailfield ] .hh .v.RH = tempptr ; 
  curlist .tailfield = tempptr ; 
  goto lab60 ; 
} 
void giveerrhelp ( ) 
{giveerrhelp_regmem 
  tokenshow ( eqtb [ 7321 ] .hh .v.RH ) ; 
} 
boolean openfmtfile ( ) 
{/* 40 10 */ register boolean Result; openfmtfile_regmem 
  integer j  ; 
  j = curinput .locfield ; 
  if ( buffer [ curinput .locfield ] == 38 ) 
  {
    incr ( curinput .locfield ) ; 
    j = curinput .locfield ; 
    buffer [ last ] = 32 ; 
    while ( buffer [ j ] != 32 ) incr ( j ) ; 
    packbufferedname ( 0 , curinput .locfield , j - 1 ) ; 
    if ( wopenin ( fmtfile ) ) 
    goto lab40 ; 
    fprintf( stdout , "%s%s\n",  "Sorry, I can't find that format;" ,     " will try the default." ) ; 
    flush ( stdout ) ; 
  } 
  packbufferedname ( formatdefaultlength - 4 , 1 , 0 ) ; 
  if ( ! wopenin ( fmtfile ) ) 
  {
    ; 
    fprintf( stdout , "%s\n",  "I can't find the default format file!" ) ; 
    Result = false ; 
    return(Result) ; 
  } 
  lab40: curinput .locfield = j ; 
  Result = true ; 
  return(Result) ; 
} 
void closefilesandterminate ( ) 
{closefilesandterminate_regmem 
  integer k  ; 
  {register integer for_end; k = 0 ; for_end = 15 ; if ( k <= for_end) do 
    if ( writeopen [ k ] ) 
    aclose ( writefile [ k ] ) ; 
  while ( k++ < for_end ) ; } 
	;
#ifdef STAT
  if ( eqtb [ 9194 ] .cint > 0 ) 
  if ( logopened ) 
  {
    fprintf( logfile , "%c\n",  ' ' ) ; 
    fprintf( logfile , "%s%s\n",  "Here is how much of TeX's memory" , " you used:" ) ; 
    fprintf( logfile , "%c%ld%s",  ' ' , (long)strptr - initstrptr , " string" ) ; 
    if ( strptr != initstrptr + 1 ) 
    putc ( 's' ,  logfile );
    fprintf( logfile , "%s%ld\n",  " out of " , (long)maxstrings - initstrptr ) ; 
    fprintf( logfile , "%c%ld%s%ld\n",  ' ' , (long)poolptr - initpoolptr ,     " string characters out of " , (long)poolsize - initpoolptr ) ; 
    fprintf( logfile , "%c%ld%s%ld\n",  ' ' , (long)lomemmax - memmin + memend - himemmin + 2 ,     " words of memory out of " , (long)memend + 1 - memmin ) ; 
    fprintf( logfile , "%c%ld%s%ld\n",  ' ' , (long)cscount ,     " multiletter control sequences out of " , (long)6000 ) ; 
    fprintf( logfile , "%c%ld%s%ld%s",  ' ' , (long)fmemptr , " words of font info for " , (long)fontptr - 0     , " font" ) ; 
    if ( fontptr != 1 ) 
    putc ( 's' ,  logfile );
    fprintf( logfile , "%s%ld%s%ld\n",  ", out of " , (long)fontmemsize , " for " , (long)fontmax - 0 ) ; 
    fprintf( logfile , "%c%ld%s",  ' ' , (long)hyphcount , " hyphenation exception" ) ; 
    if ( hyphcount != 1 ) 
    putc ( 's' ,  logfile );
    fprintf( logfile , "%s%ld\n",  " out of " , (long)307 ) ; 
    fprintf( logfile , "%c%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%c\n",  ' ' , (long)maxinstack , "i," , (long)maxneststack , "n," ,     (long)maxparamstack , "p," , (long)maxbufstack + 1 , "b," , (long)maxsavestack + 6 ,     "s stack positions out of " , (long)stacksize , "i," , (long)nestsize , "n," ,     (long)paramsize , "p," , (long)bufsize , "b," , (long)savesize , 's' ) ; 
  } 
#endif /* STAT */
  while ( curs > -1 ) {
      
    if ( curs > 0 ) 
    {
      dvibuf [ dviptr ] = 142 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    else {
	
      {
	dvibuf [ dviptr ] = 140 ; 
	incr ( dviptr ) ; 
	if ( dviptr == dvilimit ) 
	dviswap () ; 
      } 
      incr ( totalpages ) ; 
    } 
    decr ( curs ) ; 
  } 
  if ( totalpages == 0 ) 
  printnl ( 831 ) ; 
  else {
      
    {
      dvibuf [ dviptr ] = 248 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    dvifour ( lastbop ) ; 
    lastbop = dvioffset + dviptr - 5 ; 
    dvifour ( 25400000L ) ; 
    dvifour ( 473628672L ) ; 
    preparemag () ; 
    dvifour ( eqtb [ 9180 ] .cint ) ; 
    dvifour ( maxv ) ; 
    dvifour ( maxh ) ; 
    {
      dvibuf [ dviptr ] = maxpush / 256 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    {
      dvibuf [ dviptr ] = maxpush % 256 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    {
      dvibuf [ dviptr ] = ( totalpages / 256 ) % 256 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    {
      dvibuf [ dviptr ] = totalpages % 256 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    while ( fontptr > 0 ) {
	
      if ( fontused [ fontptr ] ) 
      dvifontdef ( fontptr ) ; 
      decr ( fontptr ) ; 
    } 
    {
      dvibuf [ dviptr ] = 249 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    dvifour ( lastbop ) ; 
    {
      dvibuf [ dviptr ] = 2 ; 
      incr ( dviptr ) ; 
      if ( dviptr == dvilimit ) 
      dviswap () ; 
    } 
    k = 4 + ( ( dvibufsize - dviptr ) % 4 ) ; 
    while ( k > 0 ) {
	
      {
	dvibuf [ dviptr ] = 223 ; 
	incr ( dviptr ) ; 
	if ( dviptr == dvilimit ) 
	dviswap () ; 
      } 
      decr ( k ) ; 
    } 
    if ( dvilimit == halfbuf ) 
    writedvi ( halfbuf , dvibufsize - 1 ) ; 
    if ( dviptr > 0 ) 
    writedvi ( 0 , dviptr - 1 ) ; 
    printnl ( 832 ) ; 
    slowprint ( outputfilename ) ; 
    print ( 284 ) ; 
    printint ( totalpages ) ; 
    print ( 833 ) ; 
    if ( totalpages != 1 ) 
    printchar ( 115 ) ; 
    print ( 834 ) ; 
    printint ( dvioffset + dviptr ) ; 
    print ( 835 ) ; 
    bclose ( dvifile ) ; 
  } 
  if ( logopened ) 
  {
    putc ('\n',  logfile );
    aclose ( logfile ) ; 
    selector = selector - 2 ; 
    if ( selector == 17 ) 
    {
      printnl ( 1269 ) ; 
      slowprint ( texmflogname ) ; 
      printchar ( 46 ) ; 
    } 
  } 
  println () ; 
  if ( ( editnamestart != 0 ) && ( interaction > 0 ) ) 
  calledit ( strpool , editnamestart , editnamelength , editline ) ; 
} 
#ifdef DEBUG
void debughelp ( ) 
{/* 888 10 */ debughelp_regmem 
  integer k, l, m, n  ; 
  while ( true ) {
      
    ; 
    printnl ( 1278 ) ; 
    flush ( stdout ) ; 
    read ( stdin , m ) ; 
    if ( m < 0 ) 
    return ; 
    else if ( m == 0 ) 
    dumpcore () ; 
    else {
	
      read ( stdin , n ) ; 
      switch ( m ) 
      {case 1 : 
	printword ( mem [ n ] ) ; 
	break ; 
      case 2 : 
	printint ( mem [ n ] .hh .v.LH ) ; 
	break ; 
      case 3 : 
	printint ( mem [ n ] .hh .v.RH ) ; 
	break ; 
      case 4 : 
	printword ( eqtb [ n ] ) ; 
	break ; 
      case 5 : 
	printword ( fontinfo [ n ] ) ; 
	break ; 
      case 6 : 
	printword ( savestack [ n ] ) ; 
	break ; 
      case 7 : 
	showbox ( n ) ; 
	break ; 
      case 8 : 
	{
	  breadthmax = 10000 ; 
	  depththreshold = poolsize - poolptr - 10 ; 
	  shownodelist ( n ) ; 
	} 
	break ; 
      case 9 : 
	showtokenlist ( n , 0 , 1000 ) ; 
	break ; 
      case 10 : 
	slowprint ( n ) ; 
	break ; 
      case 11 : 
	checkmem ( n > 0 ) ; 
	break ; 
      case 12 : 
	searchmem ( n ) ; 
	break ; 
      case 13 : 
	{
	  read ( stdin , l ) ; 
	  printcmdchr ( n , l ) ; 
	} 
	break ; 
      case 14 : 
	{register integer for_end; k = 0 ; for_end = n ; if ( k <= for_end) 
	do 
	  print ( buffer [ k ] ) ; 
	while ( k++ < for_end ) ; } 
	break ; 
      case 15 : 
	{
	  fontinshortdisplay = 0 ; 
	  shortdisplay ( n ) ; 
	} 
	break ; 
      case 16 : 
	panicking = ! panicking ; 
	break ; 
	default: 
	print ( 63 ) ; 
	break ; 
      } 
    } 
  } 
} 
#endif /* DEBUG */
