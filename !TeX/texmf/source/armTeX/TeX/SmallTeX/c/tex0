#define EXTERN extern
#include "texd.h"

void println ( )
{println_regmem
  switch ( selector )
  {case 19 :
    {
      putc ('\n',  stdout );
      putc ('\n',  logfile );
      termoffset = 0 ;
      fileoffset = 0 ;
    }
    break ;
  case 18 :
    {
      putc ('\n',  logfile );
      fileoffset = 0 ;
    }
    break ;
  case 17 :
    {
      putc ('\n',  stdout );
      termoffset = 0 ;
    }
    break ;
  case 16 :
  case 20 :
  case 21 :
    ;
    break ;
    default:
    putc ('\n',  writefile [ selector ] );
    break ;
  }
}
void zprintchar ( s )
ASCIIcode s ;
{/* 10 */ printchar_regmem
  if ( s == eqtb [ 9212 ] .cint )
  if ( selector < 20 )
  {
    println () ;
    return ;
  }
  switch ( selector )
  {case 19 :
    {
      putc ( Xchr ( s ) ,  stdout );
      putc ( Xchr ( s ) ,  logfile );
      incr ( termoffset ) ;
      incr ( fileoffset ) ;
      if ( termoffset == maxprintline )
      {
	putc ('\n',  stdout );
	termoffset = 0 ;
      }
      if ( fileoffset == maxprintline )
      {
	putc ('\n',  logfile );
	fileoffset = 0 ;
      }
    }
    break ;
  case 18 :
    {
      putc ( Xchr ( s ) ,  logfile );
      incr ( fileoffset ) ;
      if ( fileoffset == maxprintline )
      println () ;
    }
    break ;
  case 17 :
    {
      putc ( Xchr ( s ) ,  stdout );
      incr ( termoffset ) ;
      if ( termoffset == maxprintline )
      println () ;
    }
    break ;
  case 16 :
    ;
    break ;
  case 20 :
    if ( tally < trickcount )
    trickbuf [ tally % errorline ] = s ;
    break ;
  case 21 :
    {
      if ( poolptr < poolsize )
      {
	strpool [ poolptr ] = s ;
	incr ( poolptr ) ;
      }
    }
    break ;
    default:
    putc ( Xchr ( s ) ,  writefile [ selector ] );
    break ;
  }
  incr ( tally ) ;
}
void zprint ( s )
integer s ;
{/* 10 */ print_regmem
  poolpointer j  ;
  integer nl  ;
  if ( s >= strptr )
  s = 259 ;
  else if ( s < 256 )
  if ( s < 0 )
  s = 259 ;
  else {

    if ( selector > 20 )
    {
      printchar ( s ) ;
      return ;
    }
    if ( ( s == eqtb [ 9212 ] .cint ) )
    if ( selector < 20 )
    {
      println () ;
      return ;
    }
    nl = eqtb [ 9212 ] .cint ;
    eqtb [ 9212 ] .cint = -1 ;
    j = strstart [ s ] ;
    while ( j < strstart [ s + 1 ] ) {

      printchar ( strpool [ j ] ) ;
      incr ( j ) ;
    }
    eqtb [ 9212 ] .cint = nl ;
    return ;
  }
  j = strstart [ s ] ;
  while ( j < strstart [ s + 1 ] ) {

    printchar ( strpool [ j ] ) ;
    incr ( j ) ;
  }
}
void zslowprint ( s )
integer s ;
{slowprint_regmem
  poolpointer j  ;
  if ( ( s >= strptr ) || ( s < 256 ) )
  print ( s ) ;
  else {

    j = strstart [ s ] ;
    while ( j < strstart [ s + 1 ] ) {

      print ( strpool [ j ] ) ;
      incr ( j ) ;
    }
  }
}
void zprintnl ( s )
strnumber s ;
{printnl_regmem
  if ( ( ( termoffset > 0 ) && ( odd ( selector ) ) ) || ( ( fileoffset > 0 )
  && ( selector >= 18 ) ) )
  println () ;
  print ( s ) ;
}
void zprintesc ( s )
strnumber s ;
{printesc_regmem
  integer c  ;
  c = eqtb [ 9208 ] .cint ;
  if ( c >= 0 )
  if ( c < 256 )
  print ( c ) ;
  slowprint ( s ) ;
}
void zprintthedigs ( k )
eightbits k ;
{printthedigs_regmem
  while ( k > 0 ) {

    decr ( k ) ;
    if ( dig [ k ] < 10 )
    printchar ( 48 + dig [ k ] ) ;
    else printchar ( 55 + dig [ k ] ) ;
  }
}
void zprintint ( n )
integer n ;
{printint_regmem
  char k  ;
  integer m  ;
  k = 0 ;
  if ( n < 0 )
  {
    printchar ( 45 ) ;
    if ( n > -100000000L )
    n = - (integer) n ;
    else {

      m = -1 - n ;
      n = m / 10 ;
      m = ( m % 10 ) + 1 ;
      k = 1 ;
      if ( m < 10 )
      dig [ 0 ] = m ;
      else {

	dig [ 0 ] = 0 ;
	incr ( n ) ;
      }
    }
  }
  do {
      dig [ k ] = n % 10 ;
    n = n / 10 ;
    incr ( k ) ;
  } while ( ! ( n == 0 ) ) ;
  printthedigs ( k ) ;
}
void zprintcs ( p )
integer p ;
{printcs_regmem
  if ( p < 514 )
  if ( p >= 257 )
  if ( p == 513 )
  {
    printesc ( 501 ) ;
    printesc ( 502 ) ;
  }
  else {

    printesc ( p - 257 ) ;
    if ( eqtb [ 7883 + p - 257 ] .hh .v.RH == 11 )
    printchar ( 32 ) ;
  }
  else if ( p < 1 )
  printesc ( 503 ) ;
  else print ( p - 1 ) ;
  else if ( p >= 6781 )
  printesc ( 503 ) ;
  else if ( ( hash [ p ] .v.RH >= strptr ) )
  printesc ( 504 ) ;
  else {

    printesc ( hash [ p ] .v.RH ) ;
    printchar ( 32 ) ;
  }
}
void zsprintcs ( p )
halfword p ;
{sprintcs_regmem
  if ( p < 514 )
  if ( p < 257 )
  print ( p - 1 ) ;
  else if ( p < 513 )
  printesc ( p - 257 ) ;
  else {

    printesc ( 501 ) ;
    printesc ( 502 ) ;
  }
  else printesc ( hash [ p ] .v.RH ) ;
}
void zprintfilename ( n , a , e )
integer n ;
integer a ;
integer e ;
{printfilename_regmem
  slowprint ( a ) ;
  slowprint ( n ) ;
  slowprint ( e ) ;
}
void zprintsize ( s )
integer s ;
{printsize_regmem
  if ( s == 0 )
  printesc ( 409 ) ;
  else if ( s == 16 )
  printesc ( 410 ) ;
  else printesc ( 411 ) ;
}
void zprintwritewhatsit ( s , p )
strnumber s ;
halfword p ;
{printwritewhatsit_regmem
  printesc ( s ) ;
  if ( mem [ p + 1 ] .hh .v.LH < 16 )
  printint ( mem [ p + 1 ] .hh .v.LH ) ;
  else if ( mem [ p + 1 ] .hh .v.LH == 16 )
  printchar ( 42 ) ;
  else printchar ( 45 ) ;
}
#ifdef DEBUG
#endif /* DEBUG */
void jumpout ( )
{jumpout_regmem
  closefilesandterminate () ;
  {
    flush ( stdout ) ;
    readyalready = 0 ;
    if ( ( history != 0 ) && ( history != 1 ) )
    uexit ( 1 ) ;
    else uexit ( 0 ) ;
  }
}
void error ( )
{/* 22 10 */ error_regmem
  ASCIIcode c  ;
  integer s1, s2, s3, s4  ;
  if ( history < 2 )
  history = 2 ;
  printchar ( 46 ) ;
  showcontext () ;
  if ( interaction == 3 )
  while ( true ) {

    lab22: clearforerrorprompt () ;
    {
      ;
      print ( 264 ) ;
      terminput () ;
    }
    if ( last == first )
    return ;
    c = buffer [ first ] ;
    if ( c >= 97 )
    c = c - 32 ;
    switch ( c )
    {case 48 :
    case 49 :
    case 50 :
    case 51 :
    case 52 :
    case 53 :
    case 54 :
    case 55 :
    case 56 :
    case 57 :
      if ( deletionsallowed )
      {
	s1 = curtok ;
	s2 = curcmd ;
	s3 = curchr ;
	s4 = alignstate ;
	alignstate = 1000000L ;
	OKtointerrupt = false ;
	if ( ( last > first + 1 ) && ( buffer [ first + 1 ] >= 48 ) && (
	buffer [ first + 1 ] <= 57 ) )
	c = c * 10 + buffer [ first + 1 ] - 48 * 11 ;
	else c = c - 48 ;
	while ( c > 0 ) {

	  gettoken () ;
	  decr ( c ) ;
	}
	curtok = s1 ;
	curcmd = s2 ;
	curchr = s3 ;
	alignstate = s4 ;
	OKtointerrupt = true ;
	{
	  helpptr = 2 ;
	  helpline [ 1 ] = 277 ;
	  helpline [ 0 ] = 278 ;
	}
	showcontext () ;
	goto lab22 ;
      }
      break ;
	;
#ifdef DEBUG
    case 68 :
      {
	debughelp () ;
	goto lab22 ;
      }
      break ;
#endif /* DEBUG */
    case 69 :
      if ( baseptr > 0 )
      {
	editnamestart = strstart [ inputstack [ baseptr ] .namefield ] ;
	editnamelength = strstart [ inputstack [ baseptr ] .namefield + 1 ] -
	strstart [ inputstack [ baseptr ] .namefield ] ;
	editline = line ;
	jumpout () ;
      }
      break ;
    case 72 :
      {
	if ( useerrhelp )
	{
	  giveerrhelp () ;
	  useerrhelp = false ;
	}
	else {

	  if ( helpptr == 0 )
	  {
	    helpptr = 2 ;
	    helpline [ 1 ] = 279 ;
	    helpline [ 0 ] = 280 ;
	  }
	  do {
	      decr ( helpptr ) ;
	    print ( helpline [ helpptr ] ) ;
	    println () ;
	  } while ( ! ( helpptr == 0 ) ) ;
	}
	{
	  helpptr = 4 ;
	  helpline [ 3 ] = 281 ;
	  helpline [ 2 ] = 280 ;
	  helpline [ 1 ] = 282 ;
	  helpline [ 0 ] = 283 ;
	}
	goto lab22 ;
      }
      break ;
    case 73 :
      {
	beginfilereading () ;
	if ( last > first + 1 )
	{
	  curinput .locfield = first + 1 ;
	  buffer [ first ] = 32 ;
	}
	else {

	  {
	    ;
	    print ( 276 ) ;
	    terminput () ;
	  }
	  curinput .locfield = first ;
	}
	first = last ;
	curinput .limitfield = last - 1 ;
	return ;
      }
      break ;
    case 81 :
    case 82 :
    case 83 :
      {
	errorcount = 0 ;
	interaction = 0 + c - 81 ;
	print ( 271 ) ;
	switch ( c )
	{case 81 :
	  {
	    printesc ( 272 ) ;
	    decr ( selector ) ;
	  }
	  break ;
	case 82 :
	  printesc ( 273 ) ;
	  break ;
	case 83 :
	  printesc ( 274 ) ;
	  break ;
	}
	print ( 275 ) ;
	println () ;
	flush ( stdout ) ;
	return ;
      }
      break ;
    case 88 :
      {
	interaction = 2 ;
	jumpout () ;
      }
      break ;
      default:
      ;
      break ;
    }
    {
      print ( 265 ) ;
      printnl ( 266 ) ;
      printnl ( 267 ) ;
      if ( baseptr > 0 )
      print ( 268 ) ;
      if ( deletionsallowed )
      printnl ( 269 ) ;
      printnl ( 270 ) ;
    }
  }
  incr ( errorcount ) ;
  if ( errorcount == 100 )
  {
    printnl ( 263 ) ;
    history = 3 ;
    jumpout () ;
  }
  if ( interaction > 0 )
  decr ( selector ) ;
  if ( useerrhelp )
  {
    println () ;
    giveerrhelp () ;
  }
  else while ( helpptr > 0 ) {

    decr ( helpptr ) ;
    printnl ( helpline [ helpptr ] ) ;
  }
  println () ;
  if ( interaction > 0 )
  incr ( selector ) ;
  println () ;
}
void zfatalerror ( s )
strnumber s ;
{fatalerror_regmem
  normalizeselector () ;
  {
    if ( interaction == 3 )
    ;
    printnl ( 262 ) ;
    print ( 285 ) ;
  }
  {
    helpptr = 1 ;
    helpline [ 0 ] = s ;
  }
  {
    if ( interaction == 3 )
    interaction = 2 ;
    if ( logopened )
    error () ;
	;
#ifdef DEBUG
    if ( interaction > 0 )
    debughelp () ;
#endif /* DEBUG */
    history = 3 ;
    jumpout () ;
  }
}
void zoverflow ( s , n )
strnumber s ;
integer n ;
{overflow_regmem
  normalizeselector () ;
  {
    if ( interaction == 3 )
    ;
    printnl ( 262 ) ;
    print ( 286 ) ;
  }
  print ( s ) ;
  printchar ( 61 ) ;
  printint ( n ) ;
  printchar ( 93 ) ;
  {
    helpptr = 2 ;
    helpline [ 1 ] = 287 ;
    helpline [ 0 ] = 288 ;
  }
  {
    if ( interaction == 3 )
    interaction = 2 ;
    if ( logopened )
    error () ;
	;
#ifdef DEBUG
    if ( interaction > 0 )
    debughelp () ;
#endif /* DEBUG */
    history = 3 ;
    jumpout () ;
  }
}
void zconfusion ( s )
strnumber s ;
{confusion_regmem
  normalizeselector () ;
  if ( history < 2 )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 289 ) ;
    }
    print ( s ) ;
    printchar ( 41 ) ;
    {
      helpptr = 1 ;
      helpline [ 0 ] = 290 ;
    }
  }
  else {

    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 291 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 292 ;
      helpline [ 0 ] = 293 ;
    }
  }
  {
    if ( interaction == 3 )
    interaction = 2 ;
    if ( logopened )
    error () ;
	;
#ifdef DEBUG
    if ( interaction > 0 )
    debughelp () ;
#endif /* DEBUG */
    history = 3 ;
    jumpout () ;
  }
}
boolean initterminal ( )
{/* 10 */ register boolean Result; initterminal_regmem
  topenin () ;
  if ( last > first )
  {
    curinput .locfield = first ;
    while ( ( curinput .locfield < last ) && ( buffer [ curinput .locfield ]
    == ' ' ) ) incr ( curinput .locfield ) ;
    if ( curinput .locfield < last )
    {
      Result = true ;
      return(Result) ;
    }
  }
  while ( true ) {

    ;
    Fputs( stdout ,  "**" ) ;
    flush ( stdout ) ;
    if ( ! inputln ( stdin , true ) )
    {
      putc ('\n',  stdout );
      Fputs( stdout ,  "! End of file on the terminal... why?" ) ;
      Result = false ;
      return(Result) ;
    }
    curinput .locfield = first ;
    while ( ( curinput .locfield < last ) && ( buffer [ curinput .locfield ]
    == 32 ) ) incr ( curinput .locfield ) ;
    if ( curinput .locfield < last )
    {
      Result = true ;
      return(Result) ;
    }
    fprintf( stdout , "%s\n",  "Please type the name of your input file." ) ;
  }
  return(Result) ;
}
strnumber makestring ( )
{register strnumber Result; makestring_regmem
  if ( strptr == maxstrings )
  overflow ( 258 , maxstrings - initstrptr ) ;
  incr ( strptr ) ;
  strstart [ strptr ] = poolptr ;
  Result = strptr - 1 ;
  return(Result) ;
}
boolean zstreqbuf ( s , k )
strnumber s ;
integer k ;
{/* 45 */ register boolean Result; streqbuf_regmem
  poolpointer j  ;
  boolean result  ;
  j = strstart [ s ] ;
  while ( j < strstart [ s + 1 ] ) {

    if ( strpool [ j ] != buffer [ k ] )
    {
      result = false ;
      goto lab45 ;
    }
    incr ( j ) ;
    incr ( k ) ;
  }
  result = true ;
  lab45: Result = result ;
  return(Result) ;
}
boolean zstreqstr ( s , t )
strnumber s ;
strnumber t ;
{/* 45 */ register boolean Result; streqstr_regmem
  poolpointer j, k  ;
  boolean result  ;
  result = false ;
  if ( ( strstart [ s + 1 ] - strstart [ s ] ) != ( strstart [ t + 1 ] -
  strstart [ t ] ) )
  goto lab45 ;
  j = strstart [ s ] ;
  k = strstart [ t ] ;
  while ( j < strstart [ s + 1 ] ) {

    if ( strpool [ j ] != strpool [ k ] )
    goto lab45 ;
    incr ( j ) ;
    incr ( k ) ;
  }
  result = true ;
  lab45: Result = result ;
  return(Result) ;
}
void zprinttwo ( n )
integer n ;
{printtwo_regmem
  n = abs ( n ) % 100 ;
  printchar ( 48 + ( n / 10 ) ) ;
  printchar ( 48 + ( n % 10 ) ) ;
}
void zprinthex ( n )
integer n ;
{printhex_regmem
  char k  ;
  k = 0 ;
  printchar ( 34 ) ;
  do {
      dig [ k ] = n % 16 ;
    n = n / 16 ;
    incr ( k ) ;
  } while ( ! ( n == 0 ) ) ;
  printthedigs ( k ) ;
}
void zprintromanint ( n )
integer n ;
{/* 10 */ printromanint_regmem
  poolpointer j, k  ;
  nonnegativeinteger u, v  ;
  j = strstart [ 260 ] ;
  v = 1000 ;
  while ( true ) {

    while ( n >= v ) {

      printchar ( strpool [ j ] ) ;
      n = n - v ;
    }
    if ( n <= 0 )
    return ;
    k = j + 2 ;
    u = v / ( strpool [ k - 1 ] - 48 ) ;
    if ( strpool [ k - 1 ] == 50 )
    {
      k = k + 2 ;
      u = u / ( strpool [ k - 1 ] - 48 ) ;
    }
    if ( n + u >= v )
    {
      printchar ( strpool [ k ] ) ;
      n = n + u ;
    }
    else {

      j = j + 2 ;
      v = v / ( strpool [ j - 1 ] - 48 ) ;
    }
  }
}
void printcurrentstring ( )
{printcurrentstring_regmem
  poolpointer j  ;
  j = strstart [ strptr ] ;
  while ( j < poolptr ) {

    printchar ( strpool [ j ] ) ;
    incr ( j ) ;
  }
}
void terminput ( )
{terminput_regmem
  integer k  ;
  flush ( stdout ) ;
  if ( ! inputln ( stdin , true ) )
  fatalerror ( 261 ) ;
  termoffset = 0 ;
  decr ( selector ) ;
  if ( last != first )
  {register integer for_end; k = first ; for_end = last - 1 ; if ( k <=
  for_end) do
    print ( buffer [ k ] ) ;
  while ( k++ < for_end ) ; }
  println () ;
  incr ( selector ) ;
}
void zinterror ( n )
integer n ;
{interror_regmem
  print ( 284 ) ;
  printint ( n ) ;
  printchar ( 41 ) ;
  error () ;
}
void normalizeselector ( )
{normalizeselector_regmem
  if ( logopened )
  selector = 19 ;
  else selector = 17 ;
  if ( jobname == 0 )
  openlogfile () ;
  if ( interaction == 0 )
  decr ( selector ) ;
}
void pauseforinstructions ( )
{pauseforinstructions_regmem
  if ( OKtointerrupt )
  {
    interaction = 3 ;
    if ( ( selector == 18 ) || ( selector == 16 ) )
    incr ( selector ) ;
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 294 ) ;
    }
    {
      helpptr = 3 ;
      helpline [ 2 ] = 295 ;
      helpline [ 1 ] = 296 ;
      helpline [ 0 ] = 297 ;
    }
    deletionsallowed = false ;
    error () ;
    deletionsallowed = true ;
    interrupt = 0 ;
  }
}
integer zhalf ( x )
integer x ;
{register integer Result; half_regmem
  if ( odd ( x ) )
  Result = ( x + 1 ) / 2 ;
  else Result = x / 2 ;
  return(Result) ;
}
scaled zrounddecimals ( k )
smallnumber k ;
{register scaled Result; rounddecimals_regmem
  integer a  ;
  a = 0 ;
  while ( k > 0 ) {

    decr ( k ) ;
    a = ( a + dig [ k ] * 131072L ) / 10 ;
  }
  Result = ( a + 1 ) / 2 ;
  return(Result) ;
}
void zprintscaled ( s )
scaled s ;
{printscaled_regmem
  scaled delta  ;
  if ( s < 0 )
  {
    printchar ( 45 ) ;
    s = - (integer) s ;
  }
  printint ( s / 65536L ) ;
  printchar ( 46 ) ;
  s = 10 * ( s % 65536L ) + 5 ;
  delta = 10 ;
  do {
      if ( delta > 65536L )
    s = s - 17232 ;
    printchar ( 48 + ( s / 65536L ) ) ;
    s = 10 * ( s % 65536L ) ;
    delta = delta * 10 ;
  } while ( ! ( s <= delta ) ) ;
}
scaled zmultandadd ( n , x , y , maxanswer )
integer n ;
scaled x ;
scaled y ;
scaled maxanswer ;
{register scaled Result; multandadd_regmem
  if ( n < 0 )
  {
    x = - (integer) x ;
    n = - (integer) n ;
  }
  if ( n == 0 )
  Result = y ;
  else if ( ( ( x <= ( maxanswer - y ) / n ) && ( - (integer) x <= ( maxanswer
  + y ) / n ) ) )
  Result = n * x + y ;
  else {

    aritherror = true ;
    Result = 0 ;
  }
  return(Result) ;
}
scaled zxovern ( x , n )
scaled x ;
integer n ;
{register scaled Result; xovern_regmem
  boolean negative  ;
  negative = false ;
  if ( n == 0 )
  {
    aritherror = true ;
    Result = 0 ;
    texremainder = x ;
  }
  else {

    if ( n < 0 )
    {
      x = - (integer) x ;
      n = - (integer) n ;
      negative = true ;
    }
    if ( x >= 0 )
    {
      Result = x / n ;
      texremainder = x % n ;
    }
    else {

      Result = - (integer) ( ( - (integer) x ) / n ) ;
      texremainder = - (integer) ( ( - (integer) x ) % n ) ;
    }
  }
  if ( negative )
  texremainder = - (integer) texremainder ;
  return(Result) ;
}
scaled zxnoverd ( x , n , d )
scaled x ;
integer n ;
integer d ;
{register scaled Result; xnoverd_regmem
  boolean positive  ;
  nonnegativeinteger t, u, v  ;
  if ( x >= 0 )
  positive = true ;
  else {

    x = - (integer) x ;
    positive = false ;
  }
  t = ( x % 32768L ) * n ;
  u = ( x / 32768L ) * n + ( t / 32768L ) ;
  v = ( u % d ) * 32768L + ( t % 32768L ) ;
  if ( u / d >= 32768L )
  aritherror = true ;
  else u = 32768L * ( u / d ) + ( v / d ) ;
  if ( positive )
  {
    Result = u ;
    texremainder = v % d ;
  }
  else {

    Result = - (integer) u ;
    texremainder = - (integer) ( v % d ) ;
  }
  return(Result) ;
}
halfword zbadness ( t , s )
scaled t ;
scaled s ;
{register halfword Result; badness_regmem
  integer r  ;
  if ( t == 0 )
  Result = 0 ;
  else if ( s <= 0 )
  Result = 10000 ;
  else {

    if ( t <= 7230584L )
    r = ( t * 297 ) / s ;
    else if ( s >= 1663497L )
    r = t / ( s / 297 ) ;
    else r = t ;
    if ( r > 1290 )
    Result = 10000 ;
    else Result = ( r * r * r + 131072L ) / 262144L ;
  }
  return(Result) ;
}
#ifdef DEBUG
void zprintword ( w )
memoryword w ;
{printword_regmem
  printint ( w .cint ) ;
  printchar ( 32 ) ;
  printscaled ( w .cint ) ;
  printchar ( 32 ) ;
  printscaled ( round ( 65536L * w .gr ) ) ;
  println () ;
  printint ( w .hh .v.LH ) ;
  printchar ( 61 ) ;
  printint ( w .hh.b0 ) ;
  printchar ( 58 ) ;
  printint ( w .hh.b1 ) ;
  printchar ( 59 ) ;
  printint ( w .hh .v.RH ) ;
  printchar ( 32 ) ;
  printint ( w .qqqq .b0 ) ;
  printchar ( 58 ) ;
  printint ( w .qqqq .b1 ) ;
  printchar ( 58 ) ;
  printint ( w .qqqq .b2 ) ;
  printchar ( 58 ) ;
  printint ( w .qqqq .b3 ) ;
}
#endif /* DEBUG */
void zshowtokenlist ( p , q , l )
integer p ;
integer q ;
integer l ;
{/* 10 */ showtokenlist_regmem
  integer m, c  ;
  ASCIIcode matchchr  ;
  ASCIIcode n  ;
  matchchr = 35 ;
  n = 48 ;
  tally = 0 ;
  while ( ( p != 0 ) && ( tally < l ) ) {

    if ( p == q )
    {
      firstcount = tally ;
      trickcount = tally + 1 + errorline - halferrorline ;
      if ( trickcount < errorline )
      trickcount = errorline ;
    }
    if ( ( p < himemmin ) || ( p > memend ) )
    {
      printesc ( 307 ) ;
      return ;
    }
    if ( mem [ p ] .hh .v.LH >= 4095 )
    printcs ( mem [ p ] .hh .v.LH - 4095 ) ;
    else {

      m = mem [ p ] .hh .v.LH / 256 ;
      c = mem [ p ] .hh .v.LH % 256 ;
//      if ( mem [ p ] .hh .v.LH < 0 )
//      printesc ( 552 ) ;
//      else
      switch ( m )
      {case 1 :
      case 2 :
      case 3 :
      case 4 :
      case 7 :
      case 8 :
      case 10 :
      case 11 :
      case 12 :
	print ( c ) ;
	break ;
      case 6 :
	{
	  print ( c ) ;
	  print ( c ) ;
	}
	break ;
      case 5 :
	{
	  print ( matchchr ) ;
	  if ( c <= 9 )
	  printchar ( c + 48 ) ;
	  else {

	    printchar ( 33 ) ;
	    return ;
	  }
	}
	break ;
      case 13 :
	{
	  matchchr = c ;
	  print ( c ) ;
	  incr ( n ) ;
	  printchar ( n ) ;
	  if ( n > 57 )
	  return ;
	}
	break ;
      case 14 :
	print ( 553 ) ;
	break ;
	default:
	printesc ( 552 ) ;
	break ;
      }
    }
    p = mem [ p ] .hh .v.RH ;
  }
  if ( p != 0 )
  printesc ( 551 ) ;
}
void runaway ( )
{runaway_regmem
  halfword p  ;
  if ( scannerstatus > 1 )
  {
    printnl ( 566 ) ;
    switch ( scannerstatus )
    {case 2 :
      {
	print ( 567 ) ;
	p = defref ;
      }
      break ;
    case 3 :
      {
	print ( 568 ) ;
	p = memtop - 3 ;
      }
      break ;
    case 4 :
      {
	print ( 569 ) ;
	p = memtop - 4 ;
      }
      break ;
    case 5 :
      {
	print ( 570 ) ;
	p = defref ;
      }
      break ;
    }
    printchar ( 63 ) ;
    println () ;
    showtokenlist ( mem [ p ] .hh .v.RH , 0 , errorline - 10 ) ;
  }
}
halfword getavail ( )
{register halfword Result; getavail_regmem
  halfword p  ;
  p = avail ;
  if ( p != 0 )
  avail = mem [ avail ] .hh .v.RH ;
  else if ( memend < memmax )
  {
    incr ( memend ) ;
    p = memend ;
  }
  else {

    decr ( himemmin ) ;
    p = himemmin ;
    if ( himemmin <= lomemmax )
    {
      runaway () ;
      overflow ( 298 , memmax + 1 - memmin ) ;
    }
  }
  mem [ p ] .hh .v.RH = 0 ;
	;
#ifdef STAT
  incr ( dynused ) ;
#endif /* STAT */
  Result = p ;
  return(Result) ;
}
void zflushlist ( p )
halfword p ;
{flushlist_regmem
  halfword q, r  ;
  if ( p != 0 )
  {
    r = p ;
    do {
	q = r ;
      r = mem [ r ] .hh .v.RH ;
	;
#ifdef STAT
      decr ( dynused ) ;
#endif /* STAT */
    } while ( ! ( r == 0 ) ) ;
    mem [ q ] .hh .v.RH = avail ;
    avail = p ;
  }
}
halfword zgetnode ( s )
integer s ;
{/* 40 10 20 */ register halfword Result; getnode_regmem
  halfword p  ;
  halfword q  ;
  integer r  ;
  integer t  ;
  lab20: p = rover ;
  do {
      q = p + mem [ p ] .hh .v.LH ;
    while ( ( mem [ q ] .hh .v.RH == 65535L ) ) {

      t = mem [ q + 1 ] .hh .v.RH ;
      if ( q == rover )
      rover = t ;
      mem [ t + 1 ] .hh .v.LH = mem [ q + 1 ] .hh .v.LH ;
      mem [ mem [ q + 1 ] .hh .v.LH + 1 ] .hh .v.RH = t ;
      q = q + mem [ q ] .hh .v.LH ;
    }
    r = q - s ;
    if ( r > toint ( p + 1 ) )
    {
      mem [ p ] .hh .v.LH = r - p ;
      rover = p ;
      goto lab40 ;
    }
    if ( r == p )
    if ( mem [ p + 1 ] .hh .v.RH != p )
    {
      rover = mem [ p + 1 ] .hh .v.RH ;
      t = mem [ p + 1 ] .hh .v.LH ;
      mem [ rover + 1 ] .hh .v.LH = t ;
      mem [ t + 1 ] .hh .v.RH = rover ;
      goto lab40 ;
    }
    mem [ p ] .hh .v.LH = q - p ;
    p = mem [ p + 1 ] .hh .v.RH ;
  } while ( ! ( p == rover ) ) ;
  if ( s == 1073741824L )
  {
    Result = 65535L ;
    return(Result) ;
  }
  if ( lomemmax + 2 < himemmin )
  if ( lomemmax + 2 <= 65535L )
  {
    if ( himemmin - lomemmax >= 1998 )
    t = lomemmax + 1000 ;
    else t = lomemmax + 1 + ( himemmin - lomemmax ) / 2 ;
    p = mem [ rover + 1 ] .hh .v.LH ;
    q = lomemmax ;
    mem [ p + 1 ] .hh .v.RH = q ;
    mem [ rover + 1 ] .hh .v.LH = q ;
    if ( t > 65535L )
    t = 65535L ;
    mem [ q + 1 ] .hh .v.RH = rover ;
    mem [ q + 1 ] .hh .v.LH = p ;
    mem [ q ] .hh .v.RH = 65535L ;
    mem [ q ] .hh .v.LH = t - lomemmax ;
    lomemmax = t ;
    mem [ lomemmax ] .hh .v.RH = 0 ;
    mem [ lomemmax ] .hh .v.LH = 0 ;
    rover = q ;
    goto lab20 ;
  }
  overflow ( 298 , memmax + 1 - memmin ) ;
  lab40: mem [ r ] .hh .v.RH = 0 ;
	;
#ifdef STAT
  varused = varused + s ;
#endif /* STAT */
  Result = r ;
  return(Result) ;
}
void zfreenode ( p , s )
halfword p ;
halfword s ;
{freenode_regmem
  halfword q  ;
  mem [ p ] .hh .v.LH = s ;
  mem [ p ] .hh .v.RH = 65535L ;
  q = mem [ rover + 1 ] .hh .v.LH ;
  mem [ p + 1 ] .hh .v.LH = q ;
  mem [ p + 1 ] .hh .v.RH = rover ;
  mem [ rover + 1 ] .hh .v.LH = p ;
  mem [ q + 1 ] .hh .v.RH = p ;
	;
#ifdef STAT
  varused = varused - s ;
#endif /* STAT */
}
halfword newnullbox ( )
{register halfword Result; newnullbox_regmem
  halfword p  ;
  p = getnode ( 7 ) ;
  mem [ p ] .hh.b0 = 0 ;
  mem [ p ] .hh.b1 = 0 ;
  mem [ p + 1 ] .cint = 0 ;
  mem [ p + 2 ] .cint = 0 ;
  mem [ p + 3 ] .cint = 0 ;
  mem [ p + 4 ] .cint = 0 ;
  mem [ p + 5 ] .hh .v.RH = 0 ;
  mem [ p + 5 ] .hh.b0 = 0 ;
  mem [ p + 5 ] .hh.b1 = 0 ;
  mem [ p + 6 ] .gr = 0.0 ;
  Result = p ;
  return(Result) ;
}
halfword newrule ( )
{register halfword Result; newrule_regmem
  halfword p  ;
  p = getnode ( 4 ) ;
  mem [ p ] .hh.b0 = 2 ;
  mem [ p ] .hh.b1 = 0 ;
  mem [ p + 1 ] .cint = -1073741824L ;
  mem [ p + 2 ] .cint = -1073741824L ;
  mem [ p + 3 ] .cint = -1073741824L ;
  Result = p ;
  return(Result) ;
}
halfword znewligature ( f , c , q )
quarterword f ;
quarterword c ;
halfword q ;
{register halfword Result; newligature_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 6 ;
  mem [ p + 1 ] .hh.b0 = f ;
  mem [ p + 1 ] .hh.b1 = c ;
  mem [ p + 1 ] .hh .v.RH = q ;
  mem [ p ] .hh.b1 = 0 ;
  Result = p ;
  return(Result) ;
}
halfword znewligitem ( c )
quarterword c ;
{register halfword Result; newligitem_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b1 = c ;
  mem [ p + 1 ] .hh .v.RH = 0 ;
  Result = p ;
  return(Result) ;
}
halfword newdisc ( )
{register halfword Result; newdisc_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 7 ;
  mem [ p ] .hh.b1 = 0 ;
  mem [ p + 1 ] .hh .v.LH = 0 ;
  mem [ p + 1 ] .hh .v.RH = 0 ;
  Result = p ;
  return(Result) ;
}
halfword znewmath ( w , s )
scaled w ;
smallnumber s ;
{register halfword Result; newmath_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 9 ;
  mem [ p ] .hh.b1 = s ;
  mem [ p + 1 ] .cint = w ;
  Result = p ;
  return(Result) ;
}
halfword znewspec ( p )
halfword p ;
{register halfword Result; newspec_regmem
  halfword q  ;
  q = getnode ( 4 ) ;
  mem [ q ] = mem [ p ] ;
  mem [ q ] .hh .v.RH = 0 ;
  mem [ q + 1 ] .cint = mem [ p + 1 ] .cint ;
  mem [ q + 2 ] .cint = mem [ p + 2 ] .cint ;
  mem [ q + 3 ] .cint = mem [ p + 3 ] .cint ;
  Result = q ;
  return(Result) ;
}
halfword znewparamglue ( n )
smallnumber n ;
{register halfword Result; newparamglue_regmem
  halfword p  ;
  halfword q  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 10 ;
  mem [ p ] .hh.b1 = n + 1 ;
  mem [ p + 1 ] .hh .v.RH = 0 ;
  q = eqtb [ 6782 + n ] .hh .v.RH ;
  mem [ p + 1 ] .hh .v.LH = q ;
  incr ( mem [ q ] .hh .v.RH ) ;
  Result = p ;
  return(Result) ;
}
halfword znewglue ( q )
halfword q ;
{register halfword Result; newglue_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 10 ;
  mem [ p ] .hh.b1 = 0 ;
  mem [ p + 1 ] .hh .v.RH = 0 ;
  mem [ p + 1 ] .hh .v.LH = q ;
  incr ( mem [ q ] .hh .v.RH ) ;
  Result = p ;
  return(Result) ;
}
halfword znewskipparam ( n )
smallnumber n ;
{register halfword Result; newskipparam_regmem
  halfword p  ;
  tempptr = newspec ( eqtb [ 6782 + n ] .hh .v.RH ) ;
  p = newglue ( tempptr ) ;
  mem [ tempptr ] .hh .v.RH = 0 ;
  mem [ p ] .hh.b1 = n + 1 ;
  Result = p ;
  return(Result) ;
}
halfword znewkern ( w )
scaled w ;
{register halfword Result; newkern_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 11 ;
  mem [ p ] .hh.b1 = 0 ;
  mem [ p + 1 ] .cint = w ;
  Result = p ;
  return(Result) ;
}
halfword znewpenalty ( m )
integer m ;
{register halfword Result; newpenalty_regmem
  halfword p  ;
  p = getnode ( 2 ) ;
  mem [ p ] .hh.b0 = 12 ;
  mem [ p ] .hh.b1 = 0 ;
  mem [ p + 1 ] .cint = m ;
  Result = p ;
  return(Result) ;
}
#ifdef DEBUG
void zcheckmem ( printlocs )
boolean printlocs ;
{/* 31 32 */ checkmem_regmem
  halfword p, q  ;
  boolean clobbered  ;
  {register integer for_end; p = memmin ; for_end = lomemmax ; if ( p <=
  for_end) do
    freearr [ p ] = false ;
  while ( p++ < for_end ) ; }
  {register integer for_end; p = himemmin ; for_end = memend ; if ( p <=
  for_end) do
    freearr [ p ] = false ;
  while ( p++ < for_end ) ; }
  p = avail ;
  q = 0 ;
  clobbered = false ;
  while ( p != 0 ) {

    if ( ( p > memend ) || ( p < himemmin ) )
    clobbered = true ;
    else if ( freearr [ p ] )
    clobbered = true ;
    if ( clobbered )
    {
      printnl ( 299 ) ;
      printint ( q ) ;
      goto lab31 ;
    }
    freearr [ p ] = true ;
    q = p ;
    p = mem [ q ] .hh .v.RH ;
  }
  lab31: ;
  p = rover ;
  q = 0 ;
  clobbered = false ;
  do {
      if ( ( p >= lomemmax ) || ( p < memmin ) )
    clobbered = true ;
    else if ( ( mem [ p + 1 ] .hh .v.RH >= lomemmax ) || ( mem [ p + 1 ] .hh
    .v.RH < memmin ) )
    clobbered = true ;
    else if ( ! ( ( mem [ p ] .hh .v.RH == 65535L ) ) || ( mem [ p ] .hh .v.LH
    < 2 ) || ( p + mem [ p ] .hh .v.LH > lomemmax ) || ( mem [ mem [ p + 1 ]
    .hh .v.RH + 1 ] .hh .v.LH != p ) )
    clobbered = true ;
    if ( clobbered )
    {
      printnl ( 300 ) ;
      printint ( q ) ;
      goto lab32 ;
    }
    {register integer for_end; q = p ; for_end = p + mem [ p ] .hh .v.LH - 1
    ; if ( q <= for_end) do
      {
	if ( freearr [ q ] )
	{
	  printnl ( 301 ) ;
	  printint ( q ) ;
	  goto lab32 ;
	}
	freearr [ q ] = true ;
      }
    while ( q++ < for_end ) ; }
    q = p ;
    p = mem [ p + 1 ] .hh .v.RH ;
  } while ( ! ( p == rover ) ) ;
  lab32: ;
  p = memmin ;
  while ( p <= lomemmax ) {

    if ( ( mem [ p ] .hh .v.RH == 65535L ) )
    {
      printnl ( 302 ) ;
      printint ( p ) ;
    }
    while ( ( p <= lomemmax ) && ! freearr [ p ] ) incr ( p ) ;
    while ( ( p <= lomemmax ) && freearr [ p ] ) incr ( p ) ;
  }
  if ( printlocs )
  {
    printnl ( 303 ) ;
    {register integer for_end; p = memmin ; for_end = lomemmax ; if ( p <=
    for_end) do
      if ( ! freearr [ p ] && ( ( p > waslomax ) || wasfree [ p ] ) )
      {
	printchar ( 32 ) ;
	printint ( p ) ;
      }
    while ( p++ < for_end ) ; }
    {register integer for_end; p = himemmin ; for_end = memend ; if ( p <=
    for_end) do
      if ( ! freearr [ p ] && ( ( p < washimin ) || ( p > wasmemend ) ||
      wasfree [ p ] ) )
      {
	printchar ( 32 ) ;
	printint ( p ) ;
      }
    while ( p++ < for_end ) ; }
  }
  {register integer for_end; p = memmin ; for_end = lomemmax ; if ( p <=
  for_end) do
    wasfree [ p ] = freearr [ p ] ;
  while ( p++ < for_end ) ; }
  {register integer for_end; p = himemmin ; for_end = memend ; if ( p <=
  for_end) do
    wasfree [ p ] = freearr [ p ] ;
  while ( p++ < for_end ) ; }
  wasmemend = memend ;
  waslomax = lomemmax ;
  washimin = himemmin ;
}
#endif /* DEBUG */
#ifdef DEBUG
void zsearchmem ( p )
halfword p ;
{searchmem_regmem
  integer q  ;
  {register integer for_end; q = memmin ; for_end = lomemmax ; if ( q <=
  for_end) do
    {
      if ( mem [ q ] .hh .v.RH == p )
      {
	printnl ( 304 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
      if ( mem [ q ] .hh .v.LH == p )
      {
	printnl ( 305 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
    }
  while ( q++ < for_end ) ; }
  {register integer for_end; q = himemmin ; for_end = memend ; if ( q <=
  for_end) do
    {
      if ( mem [ q ] .hh .v.RH == p )
      {
	printnl ( 304 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
      if ( mem [ q ] .hh .v.LH == p )
      {
	printnl ( 305 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
    }
  while ( q++ < for_end ) ; }
  {register integer for_end; q = 1 ; for_end = 7833 ; if ( q <= for_end) do
    {
      if ( eqtb [ q ] .hh .v.RH == p )
      {
	printnl ( 498 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
    }
  while ( q++ < for_end ) ; }
  if ( saveptr > 0 )
  {register integer for_end; q = 0 ; for_end = saveptr - 1 ; if ( q <=
  for_end) do
    {
      if ( savestack [ q ] .hh .v.RH == p )
      {
	printnl ( 543 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
    }
  while ( q++ < for_end ) ; }
  {register integer for_end; q = 0 ; for_end = 307 ; if ( q <= for_end) do
    {
      if ( hyphlist [ q ] == p )
      {
	printnl ( 934 ) ;
	printint ( q ) ;
	printchar ( 41 ) ;
      }
    }
  while ( q++ < for_end ) ; }
}
#endif /* DEBUG */
void zshortdisplay ( p )
integer p ;
{shortdisplay_regmem
  integer n  ;
  while ( p > memmin ) {

    if ( ( p >= himemmin ) )
    {
      if ( p <= memend )
      {
	if ( mem [ p ] .hh.b0 != fontinshortdisplay )
	{
	  if ( ( mem [ p ] .hh.b0 > fontmax ) )
	  printchar ( 42 ) ;
	  else printesc ( hash [ 6524 + mem [ p ] .hh.b0 ] .v.RH ) ;
	  printchar ( 32 ) ;
	  fontinshortdisplay = mem [ p ] .hh.b0 ;
	}
	print ( mem [ p ] .hh.b1 ) ;
      }
    }
    else switch ( mem [ p ] .hh.b0 )
    {case 0 :
    case 1 :
    case 3 :
    case 8 :
    case 4 :
    case 5 :
    case 13 :
      print ( 306 ) ;
      break ;
    case 2 :
      printchar ( 124 ) ;
      break ;
    case 10 :
      if ( mem [ p + 1 ] .hh .v.LH != 0 )
      printchar ( 32 ) ;
      break ;
    case 9 :
      printchar ( 36 ) ;
      break ;
    case 6 :
      shortdisplay ( mem [ p + 1 ] .hh .v.RH ) ;
      break ;
    case 7 :
      {
	shortdisplay ( mem [ p + 1 ] .hh .v.LH ) ;
	shortdisplay ( mem [ p + 1 ] .hh .v.RH ) ;
	n = mem [ p ] .hh.b1 ;
	while ( n > 0 ) {

	  if ( mem [ p ] .hh .v.RH != 0 )
	  p = mem [ p ] .hh .v.RH ;
	  decr ( n ) ;
	}
      }
      break ;
      default:
      ;
      break ;
    }
    p = mem [ p ] .hh .v.RH ;
  }
}
void zprintfontandchar ( p )
integer p ;
{printfontandchar_regmem
  if ( p > memend )
  printesc ( 307 ) ;
  else {

    if ( ( mem [ p ] .hh.b0 > fontmax ) )
    printchar ( 42 ) ;
    else printesc ( hash [ 6524 + mem [ p ] .hh.b0 ] .v.RH ) ;
    printchar ( 32 ) ;
    print ( mem [ p ] .hh.b1 ) ;
  }
}
void zprintmark ( p )
integer p ;
{printmark_regmem
  printchar ( 123 ) ;
  if ( ( p < himemmin ) || ( p > memend ) )
  printesc ( 307 ) ;
  else showtokenlist ( mem [ p ] .hh .v.RH , 0 , maxprintline - 10 ) ;
  printchar ( 125 ) ;
}
void zprintruledimen ( d )
scaled d ;
{printruledimen_regmem
  if ( ( d == -1073741824L ) )
  printchar ( 42 ) ;
  else printscaled ( d ) ;
}
void zprintglue ( d , order , s )
scaled d ;
integer order ;
strnumber s ;
{printglue_regmem
  printscaled ( d ) ;
  if ( ( order < 0 ) || ( order > 3 ) )
  print ( 308 ) ;
  else if ( order > 0 )
  {
    print ( 309 ) ;
    while ( order > 1 ) {

      printchar ( 108 ) ;
      decr ( order ) ;
    }
  }
  else if ( s != 0 )
  print ( s ) ;
}
void zprintspec ( p , s )
integer p ;
strnumber s ;
{printspec_regmem
  if ( ( p < memmin ) || ( p >= lomemmax ) )
  printchar ( 42 ) ;
  else {

    printscaled ( mem [ p + 1 ] .cint ) ;
    if ( s != 0 )
    print ( s ) ;
    if ( mem [ p + 2 ] .cint != 0 )
    {
      print ( 310 ) ;
      printglue ( mem [ p + 2 ] .cint , mem [ p ] .hh.b0 , s ) ;
    }
    if ( mem [ p + 3 ] .cint != 0 )
    {
      print ( 311 ) ;
      printglue ( mem [ p + 3 ] .cint , mem [ p ] .hh.b1 , s ) ;
    }
  }
}
void zprintfamandchar ( p )
halfword p ;
{printfamandchar_regmem
  printesc ( 461 ) ;
  printint ( mem [ p ] .hh.b0 ) ;
  printchar ( 32 ) ;
  print ( mem [ p ] .hh.b1 ) ;
}
void zprintdelimiter ( p )
halfword p ;
{printdelimiter_regmem
  integer a  ;
  a = mem [ p ] .qqqq .b0 * 256 + mem [ p ] .qqqq .b1 ;
  a = a * 4096 + mem [ p ] .qqqq .b2 * 256 + mem [ p ] .qqqq .b3 ;
  if ( a < 0 )
  printint ( a ) ;
  else printhex ( a ) ;
}
void zprintsubsidiarydata ( p , c )
halfword p ;
ASCIIcode c ;
{printsubsidiarydata_regmem
  if ( ( poolptr - strstart [ strptr ] ) >= depththreshold )
  {
    if ( mem [ p ] .hh .v.RH != 0 )
    print ( 312 ) ;
  }
  else {

    {
      strpool [ poolptr ] = c ;
      incr ( poolptr ) ;
    }
    tempptr = p ;
    switch ( mem [ p ] .hh .v.RH )
    {case 1 :
      {
	println () ;
	printcurrentstring () ;
	printfamandchar ( p ) ;
      }
      break ;
    case 2 :
      showinfo () ;
      break ;
    case 3 :
      if ( mem [ p ] .hh .v.LH == 0 )
      {
	println () ;
	printcurrentstring () ;
	print ( 854 ) ;
      }
      else showinfo () ;
      break ;
      default:
      ;
      break ;
    }
    decr ( poolptr ) ;
  }
}
void zprintstyle ( c )
integer c ;
{printstyle_regmem
  switch ( c / 2 )
  {case 0 :
    printesc ( 855 ) ;
    break ;
  case 1 :
    printesc ( 856 ) ;
    break ;
  case 2 :
    printesc ( 857 ) ;
    break ;
  case 3 :
    printesc ( 858 ) ;
    break ;
    default:
    print ( 859 ) ;
    break ;
  }
}
void zprintskipparam ( n )
integer n ;
{printskipparam_regmem
  switch ( n )
  {case 0 :
    printesc ( 373 ) ;
    break ;
  case 1 :
    printesc ( 374 ) ;
    break ;
  case 2 :
    printesc ( 375 ) ;
    break ;
  case 3 :
    printesc ( 376 ) ;
    break ;
  case 4 :
    printesc ( 377 ) ;
    break ;
  case 5 :
    printesc ( 378 ) ;
    break ;
  case 6 :
    printesc ( 379 ) ;
    break ;
  case 7 :
    printesc ( 380 ) ;
    break ;
  case 8 :
    printesc ( 381 ) ;
    break ;
  case 9 :
    printesc ( 382 ) ;
    break ;
  case 10 :
    printesc ( 383 ) ;
    break ;
  case 11 :
    printesc ( 384 ) ;
    break ;
  case 12 :
    printesc ( 385 ) ;
    break ;
  case 13 :
    printesc ( 386 ) ;
    break ;
  case 14 :
    printesc ( 387 ) ;
    break ;
  case 15 :
    printesc ( 388 ) ;
    break ;
  case 16 :
    printesc ( 389 ) ;
    break ;
  case 17 :
    printesc ( 390 ) ;
    break ;
    default:
    print ( 391 ) ;
    break ;
  }
}
void zshownodelist ( p )
integer p ;
{/* 10 */ shownodelist_regmem
  integer n  ;
  real g  ;
  if ( ( poolptr - strstart [ strptr ] ) > depththreshold )
  {
    if ( p > 0 )
    print ( 312 ) ;
    return ;
  }
  n = 0 ;
  while ( p > memmin ) {

    println () ;
    printcurrentstring () ;
    if ( p > memend )
    {
      print ( 313 ) ;
      return ;
    }
    incr ( n ) ;
    if ( n > breadthmax )
    {
      print ( 314 ) ;
      return ;
    }
    if ( ( p >= himemmin ) )
    printfontandchar ( p ) ;
    else switch ( mem [ p ] .hh.b0 )
    {case 0 :
    case 1 :
    case 13 :
      {
	if ( mem [ p ] .hh.b0 == 0 )
	printesc ( 104 ) ;
	else if ( mem [ p ] .hh.b0 == 1 )
	printesc ( 118 ) ;
	else printesc ( 316 ) ;
	print ( 317 ) ;
	printscaled ( mem [ p + 3 ] .cint ) ;
	printchar ( 43 ) ;
	printscaled ( mem [ p + 2 ] .cint ) ;
	print ( 318 ) ;
	printscaled ( mem [ p + 1 ] .cint ) ;
	if ( mem [ p ] .hh.b0 == 13 )
	{
	  if ( mem [ p ] .hh.b1 != 0 )
	  {
	    print ( 284 ) ;
	    printint ( mem [ p ] .hh.b1 + 1 ) ;
	    print ( 320 ) ;
	  }
	  if ( mem [ p + 6 ] .cint != 0 )
	  {
	    print ( 321 ) ;
	    printglue ( mem [ p + 6 ] .cint , mem [ p + 5 ] .hh.b1 , 0 ) ;
	  }
	  if ( mem [ p + 4 ] .cint != 0 )
	  {
	    print ( 322 ) ;
	    printglue ( mem [ p + 4 ] .cint , mem [ p + 5 ] .hh.b0 , 0 ) ;
	  }
	}
	else {

	  g = mem [ p + 6 ] .gr ;
	  if ( ( g != 0.0 ) && ( mem [ p + 5 ] .hh.b0 != 0 ) )
	  {
	    print ( 323 ) ;
	    if ( mem [ p + 5 ] .hh.b0 == 2 )
	    print ( 324 ) ;
	    if ( fabs ( g ) > 20000.0 )
	    {
	      if ( g > 0.0 )
	      printchar ( 62 ) ;
	      else print ( 325 ) ;
	      printglue ( 20000 * 65536L , mem [ p + 5 ] .hh.b1 , 0 ) ;
	    }
	    else printglue ( round ( 65536L * g ) , mem [ p + 5 ] .hh.b1 , 0 )
	    ;
	  }
	  if ( mem [ p + 4 ] .cint != 0 )
	  {
	    print ( 319 ) ;
	    printscaled ( mem [ p + 4 ] .cint ) ;
	  }
	}
	{
	  {
	    strpool [ poolptr ] = 46 ;
	    incr ( poolptr ) ;
	  }
	  shownodelist ( mem [ p + 5 ] .hh .v.RH ) ;
	  decr ( poolptr ) ;
	}
      }
      break ;
    case 2 :
      {
	printesc ( 326 ) ;
	printruledimen ( mem [ p + 3 ] .cint ) ;
	printchar ( 43 ) ;
	printruledimen ( mem [ p + 2 ] .cint ) ;
	print ( 318 ) ;
	printruledimen ( mem [ p + 1 ] .cint ) ;
      }
      break ;
    case 3 :
      {
	printesc ( 327 ) ;
	printint ( mem [ p ] .hh.b1 ) ;
	print ( 328 ) ;
	printscaled ( mem [ p + 3 ] .cint ) ;
	print ( 329 ) ;
	printspec ( mem [ p + 4 ] .hh .v.RH , 0 ) ;
	printchar ( 44 ) ;
	printscaled ( mem [ p + 2 ] .cint ) ;
	print ( 330 ) ;
	printint ( mem [ p + 1 ] .cint ) ;
	{
	  {
	    strpool [ poolptr ] = 46 ;
	    incr ( poolptr ) ;
	  }
	  shownodelist ( mem [ p + 4 ] .hh .v.LH ) ;
	  decr ( poolptr ) ;
	}
      }
      break ;
    case 8 :
      switch ( mem [ p ] .hh.b1 )
      {case 0 :
	{
	  printwritewhatsit ( 1279 , p ) ;
	  printchar ( 61 ) ;
	  printfilename ( mem [ p + 1 ] .hh .v.RH , mem [ p + 2 ] .hh .v.LH ,
	  mem [ p + 2 ] .hh .v.RH ) ;
	}
	break ;
      case 1 :
	{
	  printwritewhatsit ( 591 , p ) ;
	  printmark ( mem [ p + 1 ] .hh .v.RH ) ;
	}
	break ;
      case 2 :
	printwritewhatsit ( 1280 , p ) ;
	break ;
      case 3 :
	{
	  printesc ( 1281 ) ;
	  printmark ( mem [ p + 1 ] .hh .v.RH ) ;
	}
	break ;
      case 4 :
	{
	  printesc ( 1283 ) ;
	  printint ( mem [ p + 1 ] .hh .v.RH ) ;
	  print ( 1286 ) ;
	  printint ( mem [ p + 1 ] .hh.b0 ) ;
	  printchar ( 44 ) ;
	  printint ( mem [ p + 1 ] .hh.b1 ) ;
	  printchar ( 41 ) ;
	}
	break ;
	default:
	print ( 1287 ) ;
	break ;
      }
      break ;
    case 10 :
      if ( mem [ p ] .hh.b1 >= 100 )
      {
	printesc ( 335 ) ;
	if ( mem [ p ] .hh.b1 == 101 )
	printchar ( 99 ) ;
	else if ( mem [ p ] .hh.b1 == 102 )
	printchar ( 120 ) ;
	print ( 336 ) ;
	printspec ( mem [ p + 1 ] .hh .v.LH , 0 ) ;
	{
	  {
	    strpool [ poolptr ] = 46 ;
	    incr ( poolptr ) ;
	  }
	  shownodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	  decr ( poolptr ) ;
	}
      }
      else {

	printesc ( 331 ) ;
	if ( mem [ p ] .hh.b1 != 0 )
	{
	  printchar ( 40 ) ;
	  if ( mem [ p ] .hh.b1 < 98 )
	  printskipparam ( mem [ p ] .hh.b1 - 1 ) ;
	  else if ( mem [ p ] .hh.b1 == 98 )
	  printesc ( 332 ) ;
	  else printesc ( 333 ) ;
	  printchar ( 41 ) ;
	}
	if ( mem [ p ] .hh.b1 != 98 )
	{
	  printchar ( 32 ) ;
	  if ( mem [ p ] .hh.b1 < 98 )
	  printspec ( mem [ p + 1 ] .hh .v.LH , 0 ) ;
	  else printspec ( mem [ p + 1 ] .hh .v.LH , 334 ) ;
	}
      }
      break ;
    case 11 :
      if ( mem [ p ] .hh.b1 != 99 )
      {
	printesc ( 337 ) ;
	if ( mem [ p ] .hh.b1 != 0 )
	printchar ( 32 ) ;
	printscaled ( mem [ p + 1 ] .cint ) ;
	if ( mem [ p ] .hh.b1 == 2 )
	print ( 338 ) ;
      }
      else {

	printesc ( 339 ) ;
	printscaled ( mem [ p + 1 ] .cint ) ;
	print ( 334 ) ;
      }
      break ;
    case 9 :
      {
	printesc ( 340 ) ;
	if ( mem [ p ] .hh.b1 == 0 )
	print ( 341 ) ;
	else print ( 342 ) ;
	if ( mem [ p + 1 ] .cint != 0 )
	{
	  print ( 343 ) ;
	  printscaled ( mem [ p + 1 ] .cint ) ;
	}
      }
      break ;
    case 6 :
      {
	printfontandchar ( p + 1 ) ;
	print ( 344 ) ;
	if ( mem [ p ] .hh.b1 > 1 )
	printchar ( 124 ) ;
	fontinshortdisplay = mem [ p + 1 ] .hh.b0 ;
	shortdisplay ( mem [ p + 1 ] .hh .v.RH ) ;
	if ( odd ( mem [ p ] .hh.b1 ) )
	printchar ( 124 ) ;
	printchar ( 41 ) ;
      }
      break ;
    case 12 :
      {
	printesc ( 345 ) ;
	printint ( mem [ p + 1 ] .cint ) ;
      }
      break ;
    case 7 :
      {
	printesc ( 346 ) ;
	if ( mem [ p ] .hh.b1 > 0 )
	{
	  print ( 347 ) ;
	  printint ( mem [ p ] .hh.b1 ) ;
	}
	{
	  {
	    strpool [ poolptr ] = 46 ;
	    incr ( poolptr ) ;
	  }
	  shownodelist ( mem [ p + 1 ] .hh .v.LH ) ;
	  decr ( poolptr ) ;
	}
	{
	  strpool [ poolptr ] = 124 ;
	  incr ( poolptr ) ;
	}
	shownodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	decr ( poolptr ) ;
      }
      break ;
    case 4 :
      {
	printesc ( 348 ) ;
	printmark ( mem [ p + 1 ] .cint ) ;
      }
      break ;
    case 5 :
      {
	printesc ( 349 ) ;
	{
	  {
	    strpool [ poolptr ] = 46 ;
	    incr ( poolptr ) ;
	  }
	  shownodelist ( mem [ p + 1 ] .cint ) ;
	  decr ( poolptr ) ;
	}
      }
      break ;
    case 14 :
      printstyle ( mem [ p ] .hh.b1 ) ;
      break ;
    case 15 :
      {
	printesc ( 522 ) ;
	{
	  strpool [ poolptr ] = 68 ;
	  incr ( poolptr ) ;
	}
	shownodelist ( mem [ p + 1 ] .hh .v.LH ) ;
	decr ( poolptr ) ;
	{
	  strpool [ poolptr ] = 84 ;
	  incr ( poolptr ) ;
	}
	shownodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	decr ( poolptr ) ;
	{
	  strpool [ poolptr ] = 83 ;
	  incr ( poolptr ) ;
	}
	shownodelist ( mem [ p + 2 ] .hh .v.LH ) ;
	decr ( poolptr ) ;
	{
	  strpool [ poolptr ] = 115 ;
	  incr ( poolptr ) ;
	}
	shownodelist ( mem [ p + 2 ] .hh .v.RH ) ;
	decr ( poolptr ) ;
      }
      break ;
    case 16 :
    case 17 :
    case 18 :
    case 19 :
    case 20 :
    case 21 :
    case 22 :
    case 23 :
    case 24 :
    case 27 :
    case 26 :
    case 29 :
    case 28 :
    case 30 :
    case 31 :
      {
	switch ( mem [ p ] .hh.b0 )
	{case 16 :
	  printesc ( 860 ) ;
	  break ;
	case 17 :
	  printesc ( 861 ) ;
	  break ;
	case 18 :
	  printesc ( 862 ) ;
	  break ;
	case 19 :
	  printesc ( 863 ) ;
	  break ;
	case 20 :
	  printesc ( 864 ) ;
	  break ;
	case 21 :
	  printesc ( 865 ) ;
	  break ;
	case 22 :
	  printesc ( 866 ) ;
	  break ;
	case 23 :
	  printesc ( 867 ) ;
	  break ;
	case 27 :
	  printesc ( 868 ) ;
	  break ;
	case 26 :
	  printesc ( 869 ) ;
	  break ;
	case 29 :
	  printesc ( 536 ) ;
	  break ;
	case 24 :
	  {
	    printesc ( 530 ) ;
	    printdelimiter ( p + 4 ) ;
	  }
	  break ;
	case 28 :
	  {
	    printesc ( 505 ) ;
	    printfamandchar ( p + 4 ) ;
	  }
	  break ;
	case 30 :
	  {
	    printesc ( 870 ) ;
	    printdelimiter ( p + 1 ) ;
	  }
	  break ;
	case 31 :
	  {
	    printesc ( 871 ) ;
	    printdelimiter ( p + 1 ) ;
	  }
	  break ;
	}
	if ( mem [ p ] .hh.b1 != 0 )
	if ( mem [ p ] .hh.b1 == 1 )
	printesc ( 872 ) ;
	else printesc ( 873 ) ;
	if ( mem [ p ] .hh.b0 < 30 )
	printsubsidiarydata ( p + 1 , 46 ) ;
	printsubsidiarydata ( p + 2 , 94 ) ;
	printsubsidiarydata ( p + 3 , 95 ) ;
      }
      break ;
    case 25 :
      {
	printesc ( 874 ) ;
	if ( mem [ p + 1 ] .cint == 1073741824L )
	print ( 875 ) ;
	else printscaled ( mem [ p + 1 ] .cint ) ;
	if ( ( mem [ p + 4 ] .qqqq .b0 != 0 ) || ( mem [ p + 4 ] .qqqq .b1 !=
	0 ) || ( mem [ p + 4 ] .qqqq .b2 != 0 ) || ( mem [ p + 4 ] .qqqq .b3
	!= 0 ) )
	{
	  print ( 876 ) ;
	  printdelimiter ( p + 4 ) ;
	}
	if ( ( mem [ p + 5 ] .qqqq .b0 != 0 ) || ( mem [ p + 5 ] .qqqq .b1 !=
	0 ) || ( mem [ p + 5 ] .qqqq .b2 != 0 ) || ( mem [ p + 5 ] .qqqq .b3
	!= 0 ) )
	{
	  print ( 877 ) ;
	  printdelimiter ( p + 5 ) ;
	}
	printsubsidiarydata ( p + 2 , 92 ) ;
	printsubsidiarydata ( p + 3 , 47 ) ;
      }
      break ;
      default:
      print ( 315 ) ;
      break ;
    }
    p = mem [ p ] .hh .v.RH ;
  }
}
void zshowbox ( p )
halfword p ;
{showbox_regmem
  depththreshold = eqtb [ 9188 ] .cint ;
  breadthmax = eqtb [ 9187 ] .cint ;
  if ( breadthmax <= 0 )
  breadthmax = 5 ;
  if ( poolptr + depththreshold >= poolsize )
  depththreshold = poolsize - poolptr - 1 ;
  shownodelist ( p ) ;
  println () ;
}
void zdeletetokenref ( p )
halfword p ;
{deletetokenref_regmem
  if ( mem [ p ] .hh .v.LH == 0 )
  flushlist ( p ) ;
  else decr ( mem [ p ] .hh .v.LH ) ;
}
void zdeleteglueref ( p )
halfword p ;
{deleteglueref_regmem
  if ( mem [ p ] .hh .v.RH == 0 )
  freenode ( p , 4 ) ;
  else decr ( mem [ p ] .hh .v.RH ) ;
}
void zflushnodelist ( p )
halfword p ;
{/* 30 */ flushnodelist_regmem
  halfword q  ;
  while ( p != 0 ) {

    q = mem [ p ] .hh .v.RH ;
    if ( ( p >= himemmin ) )
    {
      mem [ p ] .hh .v.RH = avail ;
      avail = p ;
	;
#ifdef STAT
      decr ( dynused ) ;
#endif /* STAT */
    }
    else {

      switch ( mem [ p ] .hh.b0 )
      {case 0 :
      case 1 :
      case 13 :
	{
	  flushnodelist ( mem [ p + 5 ] .hh .v.RH ) ;
	  freenode ( p , 7 ) ;
	  goto lab30 ;
	}
	break ;
      case 2 :
	{
	  freenode ( p , 4 ) ;
	  goto lab30 ;
	}
	break ;
      case 3 :
	{
	  flushnodelist ( mem [ p + 4 ] .hh .v.LH ) ;
	  deleteglueref ( mem [ p + 4 ] .hh .v.RH ) ;
	  freenode ( p , 5 ) ;
	  goto lab30 ;
	}
	break ;
      case 8 :
	{
	  switch ( mem [ p ] .hh.b1 )
	  {case 0 :
	    freenode ( p , 3 ) ;
	    break ;
	  case 1 :
	  case 3 :
	    {
	      deletetokenref ( mem [ p + 1 ] .hh .v.RH ) ;
	      freenode ( p , 2 ) ;
	      goto lab30 ;
	    }
	    break ;
	  case 2 :
	  case 4 :
	    freenode ( p , 2 ) ;
	    break ;
	    default:
	    confusion ( 1289 ) ;
	    break ;
	  }
	  goto lab30 ;
	}
	break ;
      case 10 :
	{
	  {
	    if ( mem [ mem [ p + 1 ] .hh .v.LH ] .hh .v.RH == 0 )
	    freenode ( mem [ p + 1 ] .hh .v.LH , 4 ) ;
	    else decr ( mem [ mem [ p + 1 ] .hh .v.LH ] .hh .v.RH ) ;
	  }
	  if ( mem [ p + 1 ] .hh .v.RH != 0 )
	  flushnodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	}
	break ;
      case 11 :
      case 9 :
      case 12 :
	;
	break ;
      case 6 :
	flushnodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	break ;
      case 4 :
	deletetokenref ( mem [ p + 1 ] .cint ) ;
	break ;
      case 7 :
	{
	  flushnodelist ( mem [ p + 1 ] .hh .v.LH ) ;
	  flushnodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	}
	break ;
      case 5 :
	flushnodelist ( mem [ p + 1 ] .cint ) ;
	break ;
      case 14 :
	{
	  freenode ( p , 3 ) ;
	  goto lab30 ;
	}
	break ;
      case 15 :
	{
	  flushnodelist ( mem [ p + 1 ] .hh .v.LH ) ;
	  flushnodelist ( mem [ p + 1 ] .hh .v.RH ) ;
	  flushnodelist ( mem [ p + 2 ] .hh .v.LH ) ;
	  flushnodelist ( mem [ p + 2 ] .hh .v.RH ) ;
	  freenode ( p , 3 ) ;
	  goto lab30 ;
	}
	break ;
      case 16 :
      case 17 :
      case 18 :
      case 19 :
      case 20 :
      case 21 :
      case 22 :
      case 23 :
      case 24 :
      case 27 :
      case 26 :
      case 29 :
      case 28 :
	{
	  if ( mem [ p + 1 ] .hh .v.RH >= 2 )
	  flushnodelist ( mem [ p + 1 ] .hh .v.LH ) ;
	  if ( mem [ p + 2 ] .hh .v.RH >= 2 )
	  flushnodelist ( mem [ p + 2 ] .hh .v.LH ) ;
	  if ( mem [ p + 3 ] .hh .v.RH >= 2 )
	  flushnodelist ( mem [ p + 3 ] .hh .v.LH ) ;
	  if ( mem [ p ] .hh.b0 == 24 )
	  freenode ( p , 5 ) ;
	  else if ( mem [ p ] .hh.b0 == 28 )
	  freenode ( p , 5 ) ;
	  else freenode ( p , 4 ) ;
	  goto lab30 ;
	}
	break ;
      case 30 :
      case 31 :
	{
	  freenode ( p , 4 ) ;
	  goto lab30 ;
	}
	break ;
      case 25 :
	{
	  flushnodelist ( mem [ p + 2 ] .hh .v.LH ) ;
	  flushnodelist ( mem [ p + 3 ] .hh .v.LH ) ;
	  freenode ( p , 6 ) ;
	  goto lab30 ;
	}
	break ;
	default:
	confusion ( 350 ) ;
	break ;
      }
      freenode ( p , 2 ) ;
      lab30: ;
    }
    p = q ;
  }
}
halfword zcopynodelist ( p )
halfword p ;
{register halfword Result; copynodelist_regmem
  halfword h  ;
  halfword q  ;
  halfword r  ;
  char words  ;
  h = getavail () ;
  q = h ;
  while ( p != 0 ) {

    words = 1 ;
    if ( ( p >= himemmin ) )
    r = getavail () ;
    else switch ( mem [ p ] .hh.b0 )
    {case 0 :
    case 1 :
    case 13 :
      {
	r = getnode ( 7 ) ;
	mem [ r + 6 ] = mem [ p + 6 ] ;
	mem [ r + 5 ] = mem [ p + 5 ] ;
	mem [ r + 5 ] .hh .v.RH = copynodelist ( mem [ p + 5 ] .hh .v.RH ) ;
	words = 5 ;
      }
      break ;
    case 2 :
      {
	r = getnode ( 4 ) ;
	words = 4 ;
      }
      break ;
    case 3 :
      {
	r = getnode ( 5 ) ;
	mem [ r + 4 ] = mem [ p + 4 ] ;
	incr ( mem [ mem [ p + 4 ] .hh .v.RH ] .hh .v.RH ) ;
	mem [ r + 4 ] .hh .v.LH = copynodelist ( mem [ p + 4 ] .hh .v.LH ) ;
	words = 4 ;
      }
      break ;
    case 8 :
      switch ( mem [ p ] .hh.b1 )
      {case 0 :
	{
	  r = getnode ( 3 ) ;
	  words = 3 ;
	}
	break ;
      case 1 :
      case 3 :
	{
	  r = getnode ( 2 ) ;
	  incr ( mem [ mem [ p + 1 ] .hh .v.RH ] .hh .v.LH ) ;
	  words = 2 ;
	}
	break ;
      case 2 :
      case 4 :
	{
	  r = getnode ( 2 ) ;
	  words = 2 ;
	}
	break ;
	default:
	confusion ( 1288 ) ;
	break ;
      }
      break ;
    case 10 :
      {
	r = getnode ( 2 ) ;
	incr ( mem [ mem [ p + 1 ] .hh .v.LH ] .hh .v.RH ) ;
	mem [ r + 1 ] .hh .v.LH = mem [ p + 1 ] .hh .v.LH ;
	mem [ r + 1 ] .hh .v.RH = copynodelist ( mem [ p + 1 ] .hh .v.RH ) ;
      }
      break ;
    case 11 :
    case 9 :
    case 12 :
      {
	r = getnode ( 2 ) ;
	words = 2 ;
      }
      break ;
    case 6 :
      {
	r = getnode ( 2 ) ;
	mem [ r + 1 ] = mem [ p + 1 ] ;
	mem [ r + 1 ] .hh .v.RH = copynodelist ( mem [ p + 1 ] .hh .v.RH ) ;
      }
      break ;
    case 7 :
      {
	r = getnode ( 2 ) ;
	mem [ r + 1 ] .hh .v.LH = copynodelist ( mem [ p + 1 ] .hh .v.LH ) ;
	mem [ r + 1 ] .hh .v.RH = copynodelist ( mem [ p + 1 ] .hh .v.RH ) ;
      }
      break ;
    case 4 :
      {
	r = getnode ( 2 ) ;
	incr ( mem [ mem [ p + 1 ] .cint ] .hh .v.LH ) ;
	words = 2 ;
      }
      break ;
    case 5 :
      {
	r = getnode ( 2 ) ;
	mem [ r + 1 ] .cint = copynodelist ( mem [ p + 1 ] .cint ) ;
      }
      break ;
      default:
      confusion ( 351 ) ;
      break ;
    }
    while ( words > 0 ) {

      decr ( words ) ;
      mem [ r + words ] = mem [ p + words ] ;
    }
    mem [ q ] .hh .v.RH = r ;
    q = r ;
    p = mem [ p ] .hh .v.RH ;
  }
  mem [ q ] .hh .v.RH = 0 ;
  q = mem [ h ] .hh .v.RH ;
  {
    mem [ h ] .hh .v.RH = avail ;
    avail = h ;
	;
#ifdef STAT
    decr ( dynused ) ;
#endif /* STAT */
  }
  Result = q ;
  return(Result) ;
}
void zprintmode ( m )
integer m ;
{printmode_regmem
  if ( m > 0 )
  switch ( m / ( 101 ) )
  {case 0 :
    print ( 352 ) ;
    break ;
  case 1 :
    print ( 353 ) ;
    break ;
  case 2 :
    print ( 354 ) ;
    break ;
  }
  else if ( m == 0 )
  print ( 355 ) ;
  else switch ( ( - (integer) m ) / ( 101 ) )
  {case 0 :
    print ( 356 ) ;
    break ;
  case 1 :
    print ( 357 ) ;
    break ;
  case 2 :
    print ( 340 ) ;
    break ;
  }
  print ( 358 ) ;
}
void pushnest ( )
{pushnest_regmem
  if ( nestptr > maxneststack )
  {
    maxneststack = nestptr ;
    if ( nestptr == nestsize )
    overflow ( 359 , nestsize ) ;
  }
  nest [ nestptr ] = curlist ;
  incr ( nestptr ) ;
  curlist .headfield = getavail () ;
  curlist .tailfield = curlist .headfield ;
  curlist .pgfield = 0 ;
  curlist .mlfield = line ;
}
void popnest ( )
{popnest_regmem
  {
    mem [ curlist .headfield ] .hh .v.RH = avail ;
    avail = curlist .headfield ;
	;
#ifdef STAT
    decr ( dynused ) ;
#endif /* STAT */
  }
  decr ( nestptr ) ;
  curlist = nest [ nestptr ] ;
}
void showactivities ( )
{showactivities_regmem
  integer p  ;
  integer m  ;
  memoryword a  ;
  halfword q, r  ;
  integer t  ;
  nest [ nestptr ] = curlist ;
  printnl ( 335 ) ;
  println () ;
  {register integer for_end; p = nestptr ; for_end = 0 ; if ( p >= for_end)
  do
    {
      m = nest [ p ] .modefield ;
      a = nest [ p ] .auxfield ;
      printnl ( 360 ) ;
      printmode ( m ) ;
      print ( 361 ) ;
      printint ( abs ( nest [ p ] .mlfield ) ) ;
      if ( m == 102 )
      if ( nest [ p ] .pgfield != 8585216L )
      {
	print ( 362 ) ;
	printint ( nest [ p ] .pgfield % 65536L ) ;
	print ( 363 ) ;
	printint ( nest [ p ] .pgfield / 4194304L ) ;
	printchar ( 44 ) ;
	printint ( ( nest [ p ] .pgfield / 65536L ) % 64 ) ;
	printchar ( 41 ) ;
      }
      if ( nest [ p ] .mlfield < 0 )
      print ( 364 ) ;
      if ( p == 0 )
      {
	if ( memtop - 2 != pagetail )
	{
	  printnl ( 974 ) ;
	  if ( outputactive )
	  print ( 975 ) ;
	  showbox ( mem [ memtop - 2 ] .hh .v.RH ) ;
	  if ( pagecontents > 0 )
	  {
	    printnl ( 976 ) ;
	    printtotals () ;
	    printnl ( 977 ) ;
	    printscaled ( pagesofar [ 0 ] ) ;
	    r = mem [ memtop ] .hh .v.RH ;
	    while ( r != memtop ) {

	      println () ;
	      printesc ( 327 ) ;
	      t = mem [ r ] .hh.b1 ;
	      printint ( t ) ;
	      print ( 978 ) ;
	      t = xovern ( mem [ r + 3 ] .cint , 1000 ) * eqtb [ 9218 + t ]
	      .cint ;
	      printscaled ( t ) ;
	      if ( mem [ r ] .hh.b0 == 1 )
	      {
		q = memtop - 2 ;
		t = 0 ;
		do {
		    q = mem [ q ] .hh .v.RH ;
		  if ( ( mem [ q ] .hh.b0 == 3 ) && ( mem [ q ] .hh.b1 == mem
		  [ r ] .hh.b1 ) )
		  incr ( t ) ;
		} while ( ! ( q == mem [ r + 1 ] .hh .v.LH ) ) ;
		print ( 979 ) ;
		printint ( t ) ;
		print ( 980 ) ;
	      }
	      r = mem [ r ] .hh .v.RH ;
	    }
	  }
	}
	if ( mem [ memtop - 1 ] .hh .v.RH != 0 )
	printnl ( 365 ) ;
      }
      showbox ( mem [ nest [ p ] .headfield ] .hh .v.RH ) ;
      switch ( abs ( m ) / ( 101 ) )
      {case 0 :
	{
	  printnl ( 366 ) ;
	  if ( a .cint <= -65536000L )
	  print ( 367 ) ;
	  else printscaled ( a .cint ) ;
	  if ( nest [ p ] .pgfield != 0 )
	  {
	    print ( 368 ) ;
	    printint ( nest [ p ] .pgfield ) ;
	    print ( 369 ) ;
	    if ( nest [ p ] .pgfield != 1 )
	    printchar ( 115 ) ;
	  }
	}
	break ;
      case 1 :
	{
	  printnl ( 370 ) ;
	  printint ( a .hh .v.LH ) ;
	  if ( m > 0 )
	  if ( a .hh .v.RH > 0 )
	  {
	    print ( 371 ) ;
	    printint ( a .hh .v.RH ) ;
	  }
	}
	break ;
      case 2 :
	if ( a .cint != 0 )
	{
	  print ( 372 ) ;
	  showbox ( a .cint ) ;
	}
	break ;
      }
    }
  while ( p-- > for_end ) ; }
}
void zprintparam ( n )
integer n ;
{printparam_regmem
  switch ( n )
  {case 0 :
    printesc ( 417 ) ;
    break ;
  case 1 :
    printesc ( 418 ) ;
    break ;
  case 2 :
    printesc ( 419 ) ;
    break ;
  case 3 :
    printesc ( 420 ) ;
    break ;
  case 4 :
    printesc ( 421 ) ;
    break ;
  case 5 :
    printesc ( 422 ) ;
    break ;
  case 6 :
    printesc ( 423 ) ;
    break ;
  case 7 :
    printesc ( 424 ) ;
    break ;
  case 8 :
    printesc ( 425 ) ;
    break ;
  case 9 :
    printesc ( 426 ) ;
    break ;
  case 10 :
    printesc ( 427 ) ;
    break ;
  case 11 :
    printesc ( 428 ) ;
    break ;
  case 12 :
    printesc ( 429 ) ;
    break ;
  case 13 :
    printesc ( 430 ) ;
    break ;
  case 14 :
    printesc ( 431 ) ;
    break ;
  case 15 :
    printesc ( 432 ) ;
    break ;
  case 16 :
    printesc ( 433 ) ;
    break ;
  case 17 :
    printesc ( 434 ) ;
    break ;
  case 18 :
    printesc ( 435 ) ;
    break ;
  case 19 :
    printesc ( 436 ) ;
    break ;
  case 20 :
    printesc ( 437 ) ;
    break ;
  case 21 :
    printesc ( 438 ) ;
    break ;
  case 22 :
    printesc ( 439 ) ;
    break ;
  case 23 :
    printesc ( 440 ) ;
    break ;
  case 24 :
    printesc ( 441 ) ;
    break ;
  case 25 :
    printesc ( 442 ) ;
    break ;
  case 26 :
    printesc ( 443 ) ;
    break ;
  case 27 :
    printesc ( 444 ) ;
    break ;
  case 28 :
    printesc ( 445 ) ;
    break ;
  case 29 :
    printesc ( 446 ) ;
    break ;
  case 30 :
    printesc ( 447 ) ;
    break ;
  case 31 :
    printesc ( 448 ) ;
    break ;
  case 32 :
    printesc ( 449 ) ;
    break ;
  case 33 :
    printesc ( 450 ) ;
    break ;
  case 34 :
    printesc ( 451 ) ;
    break ;
  case 35 :
    printesc ( 452 ) ;
    break ;
  case 36 :
    printesc ( 453 ) ;
    break ;
  case 37 :
    printesc ( 454 ) ;
    break ;
  case 38 :
    printesc ( 455 ) ;
    break ;
  case 39 :
    printesc ( 456 ) ;
    break ;
  case 40 :
    printesc ( 457 ) ;
    break ;
  case 41 :
    printesc ( 458 ) ;
    break ;
  case 42 :
    printesc ( 459 ) ;
    break ;
  case 43 :
    printesc ( 460 ) ;
    break ;
  case 44 :
    printesc ( 461 ) ;
    break ;
  case 45 :
    printesc ( 462 ) ;
    break ;
  case 46 :
    printesc ( 463 ) ;
    break ;
  case 47 :
    printesc ( 464 ) ;
    break ;
  case 48 :
    printesc ( 465 ) ;
    break ;
  case 49 :
    printesc ( 466 ) ;
    break ;
  case 50 :
    printesc ( 467 ) ;
    break ;
  case 51 :
    printesc ( 468 ) ;
    break ;
  case 52 :
    printesc ( 469 ) ;
    break ;
  case 53 :
    printesc ( 470 ) ;
    break ;
  case 54 :
    printesc ( 471 ) ;
    break ;
    default:
    print ( 472 ) ;
    break ;
  }
}
void begindiagnostic ( )
{begindiagnostic_regmem
  oldsetting = selector ;
  if ( ( eqtb [ 9192 ] .cint <= 0 ) && ( selector == 19 ) )
  {
    decr ( selector ) ;
    if ( history == 0 )
    history = 1 ;
  }
}
void zenddiagnostic ( blankline )
boolean blankline ;
{enddiagnostic_regmem
  printnl ( 335 ) ;
  if ( blankline )
  println () ;
  selector = oldsetting ;
}
void zprintlengthparam ( n )
integer n ;
{printlengthparam_regmem
  switch ( n )
  {case 0 :
    printesc ( 475 ) ;
    break ;
  case 1 :
    printesc ( 476 ) ;
    break ;
  case 2 :
    printesc ( 477 ) ;
    break ;
  case 3 :
    printesc ( 478 ) ;
    break ;
  case 4 :
    printesc ( 479 ) ;
    break ;
  case 5 :
    printesc ( 480 ) ;
    break ;
  case 6 :
    printesc ( 481 ) ;
    break ;
  case 7 :
    printesc ( 482 ) ;
    break ;
  case 8 :
    printesc ( 483 ) ;
    break ;
  case 9 :
    printesc ( 484 ) ;
    break ;
  case 10 :
    printesc ( 485 ) ;
    break ;
  case 11 :
    printesc ( 486 ) ;
    break ;
  case 12 :
    printesc ( 487 ) ;
    break ;
  case 13 :
    printesc ( 488 ) ;
    break ;
  case 14 :
    printesc ( 489 ) ;
    break ;
  case 15 :
    printesc ( 490 ) ;
    break ;
  case 16 :
    printesc ( 491 ) ;
    break ;
  case 17 :
    printesc ( 492 ) ;
    break ;
  case 18 :
    printesc ( 493 ) ;
    break ;
  case 19 :
    printesc ( 494 ) ;
    break ;
  case 20 :
    printesc ( 495 ) ;
    break ;
    default:
    print ( 496 ) ;
    break ;
  }
}
void zprintcmdchr ( cmd , chrcode )
quarterword cmd ;
halfword chrcode ;
{printcmdchr_regmem
  switch ( cmd )
  {case 1 :
    {
      print ( 554 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 2 :
    {
      print ( 555 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 3 :
    {
      print ( 556 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 6 :
    {
      print ( 557 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 7 :
    {
      print ( 558 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 8 :
    {
      print ( 559 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 9 :
    print ( 560 ) ;
    break ;
  case 10 :
    {
      print ( 561 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 11 :
    {
      print ( 562 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 12 :
    {
      print ( 563 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 75 :
  case 76 :
    if ( chrcode < 6800 )
    printskipparam ( chrcode - 6782 ) ;
    else if ( chrcode < 7056 )
    {
      printesc ( 392 ) ;
      printint ( chrcode - 6800 ) ;
    }
    else {

      printesc ( 393 ) ;
      printint ( chrcode - 7056 ) ;
    }
    break ;
  case 72 :
    if ( chrcode >= 7322 )
    {
      printesc ( 404 ) ;
      printint ( chrcode - 7322 ) ;
    }
    else switch ( chrcode )
    {case 7313 :
      printesc ( 395 ) ;
      break ;
    case 7314 :
      printesc ( 396 ) ;
      break ;
    case 7315 :
      printesc ( 397 ) ;
      break ;
    case 7316 :
      printesc ( 398 ) ;
      break ;
    case 7317 :
      printesc ( 399 ) ;
      break ;
    case 7318 :
      printesc ( 400 ) ;
      break ;
    case 7319 :
      printesc ( 401 ) ;
      break ;
    case 7320 :
      printesc ( 402 ) ;
      break ;
      default:
      printesc ( 403 ) ;
      break ;
    }
    break ;
  case 73 :
    if ( chrcode < 9218 )
    printparam ( chrcode - 9163 ) ;
    else {

      printesc ( 473 ) ;
      printint ( chrcode - 9218 ) ;
    }
    break ;
  case 74 :
    if ( chrcode < 9751 )
    printlengthparam ( chrcode - 9730 ) ;
    else {

      printesc ( 497 ) ;
      printint ( chrcode - 9751 ) ;
    }
    break ;
  case 45 :
    printesc ( 505 ) ;
    break ;
  case 90 :
    printesc ( 506 ) ;
    break ;
  case 40 :
    printesc ( 507 ) ;
    break ;
  case 41 :
    printesc ( 508 ) ;
    break ;
  case 77 :
    printesc ( 516 ) ;
    break ;
  case 61 :
    printesc ( 509 ) ;
    break ;
  case 42 :
    printesc ( 528 ) ;
    break ;
  case 16 :
    printesc ( 510 ) ;
    break ;
  case 107 :
    printesc ( 501 ) ;
    break ;
  case 88 :
    printesc ( 515 ) ;
    break ;
  case 15 :
    printesc ( 511 ) ;
    break ;
  case 92 :
    printesc ( 512 ) ;
    break ;
  case 67 :
    printesc ( 502 ) ;
    break ;
  case 62 :
    printesc ( 513 ) ;
    break ;
  case 64 :
    printesc ( 32 ) ;
    break ;
  case 102 :
    printesc ( 514 ) ;
    break ;
  case 32 :
    printesc ( 517 ) ;
    break ;
  case 36 :
    printesc ( 518 ) ;
    break ;
  case 39 :
    printesc ( 519 ) ;
    break ;
  case 37 :
    printesc ( 327 ) ;
    break ;
  case 44 :
    printesc ( 47 ) ;
    break ;
  case 18 :
    printesc ( 348 ) ;
    break ;
  case 46 :
    printesc ( 520 ) ;
    break ;
  case 17 :
    printesc ( 521 ) ;
    break ;
  case 54 :
    printesc ( 522 ) ;
    break ;
  case 91 :
    printesc ( 523 ) ;
    break ;
  case 34 :
    printesc ( 524 ) ;
    break ;
  case 65 :
    printesc ( 525 ) ;
    break ;
  case 103 :
    printesc ( 526 ) ;
    break ;
  case 55 :
    printesc ( 332 ) ;
    break ;
  case 63 :
    printesc ( 527 ) ;
    break ;
  case 66 :
    printesc ( 530 ) ;
    break ;
  case 96 :
    printesc ( 531 ) ;
    break ;
  case 0 :
    printesc ( 532 ) ;
    break ;
  case 98 :
    printesc ( 533 ) ;
    break ;
  case 80 :
    printesc ( 529 ) ;
    break ;
  case 84 :
    printesc ( 405 ) ;
    break ;
  case 109 :
    printesc ( 534 ) ;
    break ;
  case 71 :
    printesc ( 404 ) ;
    break ;
  case 38 :
    printesc ( 349 ) ;
    break ;
  case 33 :
    printesc ( 535 ) ;
    break ;
  case 56 :
    printesc ( 536 ) ;
    break ;
  case 35 :
    printesc ( 537 ) ;
    break ;
  case 13 :
    printesc ( 594 ) ;
    break ;
  case 104 :
    if ( chrcode == 0 )
    printesc ( 626 ) ;
    else printesc ( 627 ) ;
    break ;
  case 110 :
    switch ( chrcode )
    {case 1 :
      printesc ( 629 ) ;
      break ;
    case 2 :
      printesc ( 630 ) ;
      break ;
    case 3 :
      printesc ( 631 ) ;
      break ;
    case 4 :
      printesc ( 632 ) ;
      break ;
      default:
      printesc ( 628 ) ;
      break ;
    }
    break ;
  case 89 :
    if ( chrcode == 0 )
    printesc ( 473 ) ;
    else if ( chrcode == 1 )
    printesc ( 497 ) ;
    else if ( chrcode == 2 )
    printesc ( 392 ) ;
    else printesc ( 393 ) ;
    break ;
  case 79 :
    if ( chrcode == 1 )
    printesc ( 666 ) ;
    else printesc ( 665 ) ;
    break ;
  case 82 :
    if ( chrcode == 0 )
    printesc ( 667 ) ;
    else printesc ( 668 ) ;
    break ;
  case 83 :
    if ( chrcode == 1 )
    printesc ( 669 ) ;
    else if ( chrcode == 3 )
    printesc ( 670 ) ;
    else printesc ( 671 ) ;
    break ;
  case 70 :
    switch ( chrcode )
    {case 0 :
      printesc ( 672 ) ;
      break ;
    case 1 :
      printesc ( 673 ) ;
      break ;
    case 2 :
      printesc ( 674 ) ;
      break ;
    case 3 :
      printesc ( 675 ) ;
      break ;
      default:
      printesc ( 676 ) ;
      break ;
    }
    break ;
  case 108 :
    switch ( chrcode )
    {case 0 :
      printesc ( 732 ) ;
      break ;
    case 1 :
      printesc ( 733 ) ;
      break ;
    case 2 :
      printesc ( 734 ) ;
      break ;
    case 3 :
      printesc ( 735 ) ;
      break ;
    case 4 :
      printesc ( 736 ) ;
      break ;
      default:
      printesc ( 737 ) ;
      break ;
    }
    break ;
  case 105 :
    switch ( chrcode )
    {case 1 :
      printesc ( 754 ) ;
      break ;
    case 2 :
      printesc ( 755 ) ;
      break ;
    case 3 :
      printesc ( 756 ) ;
      break ;
    case 4 :
      printesc ( 757 ) ;
      break ;
    case 5 :
      printesc ( 758 ) ;
      break ;
    case 6 :
      printesc ( 759 ) ;
      break ;
    case 7 :
      printesc ( 760 ) ;
      break ;
    case 8 :
      printesc ( 761 ) ;
      break ;
    case 9 :
      printesc ( 762 ) ;
      break ;
    case 10 :
      printesc ( 763 ) ;
      break ;
    case 11 :
      printesc ( 764 ) ;
      break ;
    case 12 :
      printesc ( 765 ) ;
      break ;
    case 13 :
      printesc ( 766 ) ;
      break ;
    case 14 :
      printesc ( 767 ) ;
      break ;
    case 15 :
      printesc ( 768 ) ;
      break ;
    case 16 :
      printesc ( 769 ) ;
      break ;
      default:
      printesc ( 753 ) ;
      break ;
    }
    break ;
  case 106 :
    if ( chrcode == 2 )
    printesc ( 770 ) ;
    else if ( chrcode == 4 )
    printesc ( 771 ) ;
    else printesc ( 772 ) ;
    break ;
  case 4 :
    if ( chrcode == 256 )
    printesc ( 892 ) ;
    else {

      print ( 896 ) ;
      print ( chrcode ) ;
    }
    break ;
  case 5 :
    if ( chrcode == 257 )
    printesc ( 893 ) ;
    else printesc ( 894 ) ;
    break ;
  case 81 :
    switch ( chrcode )
    {case 0 :
      printesc ( 964 ) ;
      break ;
    case 1 :
      printesc ( 965 ) ;
      break ;
    case 2 :
      printesc ( 966 ) ;
      break ;
    case 3 :
      printesc ( 967 ) ;
      break ;
    case 4 :
      printesc ( 968 ) ;
      break ;
    case 5 :
      printesc ( 969 ) ;
      break ;
    case 6 :
      printesc ( 970 ) ;
      break ;
      default:
      printesc ( 971 ) ;
      break ;
    }
    break ;
  case 14 :
    if ( chrcode == 1 )
    printesc ( 1020 ) ;
    else printesc ( 1019 ) ;
    break ;
  case 26 :
    switch ( chrcode )
    {case 4 :
      printesc ( 1021 ) ;
      break ;
    case 0 :
      printesc ( 1022 ) ;
      break ;
    case 1 :
      printesc ( 1023 ) ;
      break ;
    case 2 :
      printesc ( 1024 ) ;
      break ;
      default:
      printesc ( 1025 ) ;
      break ;
    }
    break ;
  case 27 :
    switch ( chrcode )
    {case 4 :
      printesc ( 1026 ) ;
      break ;
    case 0 :
      printesc ( 1027 ) ;
      break ;
    case 1 :
      printesc ( 1028 ) ;
      break ;
    case 2 :
      printesc ( 1029 ) ;
      break ;
      default:
      printesc ( 1030 ) ;
      break ;
    }
    break ;
  case 28 :
    printesc ( 333 ) ;
    break ;
  case 29 :
    printesc ( 337 ) ;
    break ;
  case 30 :
    printesc ( 339 ) ;
    break ;
  case 21 :
    if ( chrcode == 1 )
    printesc ( 1048 ) ;
    else printesc ( 1049 ) ;
    break ;
  case 22 :
    if ( chrcode == 1 )
    printesc ( 1050 ) ;
    else printesc ( 1051 ) ;
    break ;
  case 20 :
    switch ( chrcode )
    {case 0 :
      printesc ( 406 ) ;
      break ;
    case 1 :
      printesc ( 1052 ) ;
      break ;
    case 2 :
      printesc ( 1053 ) ;
      break ;
    case 3 :
      printesc ( 959 ) ;
      break ;
    case 4 :
      printesc ( 1054 ) ;
      break ;
    case 5 :
      printesc ( 961 ) ;
      break ;
      default:
      printesc ( 1055 ) ;
      break ;
    }
    break ;
  case 31 :
    if ( chrcode == 100 )
    printesc ( 1057 ) ;
    else if ( chrcode == 101 )
    printesc ( 1058 ) ;
    else if ( chrcode == 102 )
    printesc ( 1059 ) ;
    else printesc ( 1056 ) ;
    break ;
  case 43 :
    if ( chrcode == 0 )
    printesc ( 1075 ) ;
    else printesc ( 1074 ) ;
    break ;
  case 25 :
    if ( chrcode == 10 )
    printesc ( 1086 ) ;
    else if ( chrcode == 11 )
    printesc ( 1085 ) ;
    else printesc ( 1084 ) ;
    break ;
  case 23 :
    if ( chrcode == 1 )
    printesc ( 1088 ) ;
    else printesc ( 1087 ) ;
    break ;
  case 24 :
    if ( chrcode == 1 )
    printesc ( 1090 ) ;
    else printesc ( 1089 ) ;
    break ;
  case 47 :
    if ( chrcode == 1 )
    printesc ( 45 ) ;
    else printesc ( 346 ) ;
    break ;
  case 48 :
    if ( chrcode == 1 )
    printesc ( 1122 ) ;
    else printesc ( 1121 ) ;
    break ;
  case 50 :
    switch ( chrcode )
    {case 16 :
      printesc ( 860 ) ;
      break ;
    case 17 :
      printesc ( 861 ) ;
      break ;
    case 18 :
      printesc ( 862 ) ;
      break ;
    case 19 :
      printesc ( 863 ) ;
      break ;
    case 20 :
      printesc ( 864 ) ;
      break ;
    case 21 :
      printesc ( 865 ) ;
      break ;
    case 22 :
      printesc ( 866 ) ;
      break ;
    case 23 :
      printesc ( 867 ) ;
      break ;
    case 26 :
      printesc ( 869 ) ;
      break ;
      default:
      printesc ( 868 ) ;
      break ;
    }
    break ;
  case 51 :
    if ( chrcode == 1 )
    printesc ( 872 ) ;
    else if ( chrcode == 2 )
    printesc ( 873 ) ;
    else printesc ( 1123 ) ;
    break ;
  case 53 :
    printstyle ( chrcode ) ;
    break ;
  case 52 :
    switch ( chrcode )
    {case 1 :
      printesc ( 1142 ) ;
      break ;
    case 2 :
      printesc ( 1143 ) ;
      break ;
    case 3 :
      printesc ( 1144 ) ;
      break ;
    case 4 :
      printesc ( 1145 ) ;
      break ;
    case 5 :
      printesc ( 1146 ) ;
      break ;
      default:
      printesc ( 1141 ) ;
      break ;
    }
    break ;
  case 49 :
    if ( chrcode == 30 )
    printesc ( 870 ) ;
    else printesc ( 871 ) ;
    break ;
  case 93 :
    if ( chrcode == 1 )
    printesc ( 1165 ) ;
    else if ( chrcode == 2 )
    printesc ( 1166 ) ;
    else printesc ( 1167 ) ;
    break ;
  case 97 :
    if ( chrcode == 0 )
    printesc ( 1168 ) ;
    else if ( chrcode == 1 )
    printesc ( 1169 ) ;
    else if ( chrcode == 2 )
    printesc ( 1170 ) ;
    else printesc ( 1171 ) ;
    break ;
  case 94 :
    if ( chrcode != 0 )
    printesc ( 1186 ) ;
    else printesc ( 1185 ) ;
    break ;
  case 95 :
    switch ( chrcode )
    {case 0 :
      printesc ( 1187 ) ;
      break ;
    case 1 :
      printesc ( 1188 ) ;
      break ;
    case 2 :
      printesc ( 1189 ) ;
      break ;
    case 3 :
      printesc ( 1190 ) ;
      break ;
    case 4 :
      printesc ( 1191 ) ;
      break ;
    case 5 :
      printesc ( 1192 ) ;
      break ;
      default:
      printesc ( 1193 ) ;
      break ;
    }
    break ;
  case 68 :
    {
      printesc ( 510 ) ;
      printhex ( chrcode ) ;
    }
    break ;
  case 69 :
    {
      printesc ( 521 ) ;
      printhex ( chrcode ) ;
    }
    break ;
  case 85 :
    if ( chrcode == 7883 )
    printesc ( 412 ) ;
    else if ( chrcode == 8907 )
    printesc ( 416 ) ;
    else if ( chrcode == 8139 )
    printesc ( 413 ) ;
    else if ( chrcode == 8395 )
    printesc ( 414 ) ;
    else if ( chrcode == 8651 )
    printesc ( 415 ) ;
    else printesc ( 474 ) ;
    break ;
  case 86 :
    printsize ( chrcode - 7835 ) ;
    break ;
  case 99 :
    if ( chrcode == 1 )
    printesc ( 947 ) ;
    else printesc ( 935 ) ;
    break ;
  case 78 :
    if ( chrcode == 0 )
    printesc ( 1211 ) ;
    else printesc ( 1212 ) ;
    break ;
  case 87 :
    {
      print ( 1220 ) ;
      slowprint ( fontname [ chrcode ] ) ;
      if ( fontsize [ chrcode ] != fontdsize [ chrcode ] )
      {
	print ( 738 ) ;
	printscaled ( fontsize [ chrcode ] ) ;
	print ( 394 ) ;
      }
    }
    break ;
  case 100 :
    switch ( chrcode )
    {case 0 :
      printesc ( 272 ) ;
      break ;
    case 1 :
      printesc ( 273 ) ;
      break ;
    case 2 :
      printesc ( 274 ) ;
      break ;
      default:
      printesc ( 1221 ) ;
      break ;
    }
    break ;
  case 60 :
    if ( chrcode == 0 )
    printesc ( 1223 ) ;
    else printesc ( 1222 ) ;
    break ;
  case 58 :
    if ( chrcode == 0 )
    printesc ( 1224 ) ;
    else printesc ( 1225 ) ;
    break ;
  case 57 :
    if ( chrcode == 8139 )
    printesc ( 1231 ) ;
    else printesc ( 1232 ) ;
    break ;
  case 19 :
    switch ( chrcode )
    {case 1 :
      printesc ( 1234 ) ;
      break ;
    case 2 :
      printesc ( 1235 ) ;
      break ;
    case 3 :
      printesc ( 1236 ) ;
      break ;
      default:
      printesc ( 1233 ) ;
      break ;
    }
    break ;
  case 101 :
    print ( 1243 ) ;
    break ;
  case 111 :
    print ( 1244 ) ;
    break ;
  case 112 :
    printesc ( 1245 ) ;
    break ;
  case 113 :
    printesc ( 1246 ) ;
    break ;
  case 114 :
    {
      printesc ( 1165 ) ;
      printesc ( 1246 ) ;
    }
    break ;
  case 115 :
    printesc ( 1247 ) ;
    break ;
  case 59 :
    switch ( chrcode )
    {case 0 :
      printesc ( 1279 ) ;
      break ;
    case 1 :
      printesc ( 591 ) ;
      break ;
    case 2 :
      printesc ( 1280 ) ;
      break ;
    case 3 :
      printesc ( 1281 ) ;
      break ;
    case 4 :
      printesc ( 1282 ) ;
      break ;
    case 5 :
      printesc ( 1283 ) ;
      break ;
      default:
      print ( 1284 ) ;
      break ;
    }
    break ;
    default:
    print ( 564 ) ;
    break ;
  }
}
#ifdef STAT
void zshoweqtb ( n )
halfword n ;
{showeqtb_regmem
  if ( n < 1 )
  printchar ( 63 ) ;
  else if ( n < 6782 )
  {
    sprintcs ( n ) ;
    printchar ( 61 ) ;
    printcmdchr ( eqtb [ n ] .hh.b0 , eqtb [ n ] .hh .v.RH ) ;
    if ( eqtb [ n ] .hh.b0 >= 111 )
    {
      printchar ( 58 ) ;
      showtokenlist ( mem [ eqtb [ n ] .hh .v.RH ] .hh .v.RH , 0 , 32 ) ;
    }
  }
  else if ( n < 7312 )
  if ( n < 6800 )
  {
    printskipparam ( n - 6782 ) ;
    printchar ( 61 ) ;
    if ( n < 6797 )
    printspec ( eqtb [ n ] .hh .v.RH , 394 ) ;
    else printspec ( eqtb [ n ] .hh .v.RH , 334 ) ;
  }
  else if ( n < 7056 )
  {
    printesc ( 392 ) ;
    printint ( n - 6800 ) ;
    printchar ( 61 ) ;
    printspec ( eqtb [ n ] .hh .v.RH , 394 ) ;
  }
  else {

    printesc ( 393 ) ;
    printint ( n - 7056 ) ;
    printchar ( 61 ) ;
    printspec ( eqtb [ n ] .hh .v.RH , 334 ) ;
  }
  else if ( n < 9163 )
  if ( n == 7312 )
  {
    printesc ( 405 ) ;
    printchar ( 61 ) ;
    if ( eqtb [ 7312 ] .hh .v.RH == 0 )
    printchar ( 48 ) ;
    else printint ( mem [ eqtb [ 7312 ] .hh .v.RH ] .hh .v.LH ) ;
  }
  else if ( n < 7322 )
  {
    printcmdchr ( 72 , n ) ;
    printchar ( 61 ) ;
    if ( eqtb [ n ] .hh .v.RH != 0 )
    showtokenlist ( mem [ eqtb [ n ] .hh .v.RH ] .hh .v.RH , 0 , 32 ) ;
  }
  else if ( n < 7578 )
  {
    printesc ( 404 ) ;
    printint ( n - 7322 ) ;
    printchar ( 61 ) ;
    if ( eqtb [ n ] .hh .v.RH != 0 )
    showtokenlist ( mem [ eqtb [ n ] .hh .v.RH ] .hh .v.RH , 0 , 32 ) ;
  }
  else if ( n < 7834 )
  {
    printesc ( 406 ) ;
    printint ( n - 7578 ) ;
    printchar ( 61 ) ;
    if ( eqtb [ n ] .hh .v.RH == 0 )
    print ( 407 ) ;
    else {

      depththreshold = 0 ;
      breadthmax = 1 ;
      shownodelist ( eqtb [ n ] .hh .v.RH ) ;
    }
  }
  else if ( n < 7883 )
  {
    if ( n == 7834 )
    print ( 408 ) ;
    else if ( n < 7851 )
    {
      printesc ( 409 ) ;
      printint ( n - 7835 ) ;
    }
    else if ( n < 7867 )
    {
      printesc ( 410 ) ;
      printint ( n - 7851 ) ;
    }
    else {

      printesc ( 411 ) ;
      printint ( n - 7867 ) ;
    }
    printchar ( 61 ) ;
    printesc ( hash [ 6524 + eqtb [ n ] .hh .v.RH ] .v.RH ) ;
  }
  else if ( n < 8907 )
  {
    if ( n < 8139 )
    {
      printesc ( 412 ) ;
      printint ( n - 7883 ) ;
    }
    else if ( n < 8395 )
    {
      printesc ( 413 ) ;
      printint ( n - 8139 ) ;
    }
    else if ( n < 8651 )
    {
      printesc ( 414 ) ;
      printint ( n - 8395 ) ;
    }
    else {

      printesc ( 415 ) ;
      printint ( n - 8651 ) ;
    }
    printchar ( 61 ) ;
    printint ( eqtb [ n ] .hh .v.RH ) ;
  }
  else {

    printesc ( 416 ) ;
    printint ( n - 8907 ) ;
    printchar ( 61 ) ;
    printint ( eqtb [ n ] .hh .v.RH ) ;
  }
  else if ( n < 9730 )
  {
    if ( n < 9218 )
    printparam ( n - 9163 ) ;
    else if ( n < 9474 )
    {
      printesc ( 473 ) ;
      printint ( n - 9218 ) ;
    }
    else {

      printesc ( 474 ) ;
      printint ( n - 9474 ) ;
    }
    printchar ( 61 ) ;
    printint ( eqtb [ n ] .cint ) ;
  }
  else if ( n <= 10006 )
  {
    if ( n < 9751 )
    printlengthparam ( n - 9730 ) ;
    else {

      printesc ( 497 ) ;
      printint ( n - 9751 ) ;
    }
    printchar ( 61 ) ;
    printscaled ( eqtb [ n ] .cint ) ;
    print ( 394 ) ;
  }
  else printchar ( 63 ) ;
}
#endif /* STAT */
halfword zidlookup ( j , l )
integer j ;
integer l ;
{/* 40 */ register halfword Result; idlookup_regmem
  integer h  ;
  integer d  ;
  halfword p  ;
  halfword k  ;
  h = buffer [ j ] ;
  {register integer for_end; k = j + 1 ; for_end = j + l - 1 ; if ( k <=
  for_end) do
    {
      h = h + h + buffer [ k ] ;
      while ( h >= 5099 ) h = h - 5099 ;
    }
  while ( k++ < for_end ) ; }
  p = h + 514 ;
  while ( true ) {

    if ( hash [ p ] .v.RH > 0 )
    if ( ( strstart [ hash [ p ] .v.RH + 1 ] - strstart [ hash [ p ] .v.RH ] )
    == l )
    if ( streqbuf ( hash [ p ] .v.RH , j ) )
    goto lab40 ;
    if ( hash [ p ] .v.LH == 0 )
    {
      if ( nonewcontrolsequence )
      p = 6781 ;
      else {

	if ( hash [ p ] .v.RH > 0 )
	{
	  do {
	      if ( ( hashused == 514 ) )
	    overflow ( 500 , 6000 ) ;
	    decr ( hashused ) ;
	  } while ( ! ( hash [ hashused ] .v.RH == 0 ) ) ;
	  hash [ p ] .v.LH = hashused ;
	  p = hashused ;
	}
	{
	  if ( poolptr + l > poolsize )
	  overflow ( 257 , poolsize - initpoolptr ) ;
	}
	d = ( poolptr - strstart [ strptr ] ) ;
	while ( poolptr > strstart [ strptr ] ) {

	  decr ( poolptr ) ;
	  strpool [ poolptr + l ] = strpool [ poolptr ] ;
	}
	{register integer for_end; k = j ; for_end = j + l - 1 ; if ( k <=
	for_end) do
	  {
	    strpool [ poolptr ] = buffer [ k ] ;
	    incr ( poolptr ) ;
	  }
	while ( k++ < for_end ) ; }
	hash [ p ] .v.RH = makestring () ;
	poolptr = poolptr + d ;
	;
#ifdef STAT
	incr ( cscount ) ;
#endif /* STAT */
      }
      goto lab40 ;
    }
    p = hash [ p ] .v.LH ;
  }
  lab40: Result = p ;
  return(Result) ;
}
void znewsavelevel ( c )
groupcode c ;
{newsavelevel_regmem
  if ( saveptr > maxsavestack )
  {
    maxsavestack = saveptr ;
    if ( maxsavestack > savesize - 6 )
    overflow ( 538 , savesize ) ;
  }
  savestack [ saveptr ] .hh.b0 = 3 ;
  savestack [ saveptr ] .hh.b1 = curgroup ;
  savestack [ saveptr ] .hh .v.RH = curboundary ;
  if ( curlevel == 255 )
  overflow ( 539 , 255 ) ;
  curboundary = saveptr ;
  incr ( curlevel ) ;
  incr ( saveptr ) ;
  curgroup = c ;
}
void zeqdestroy ( w )
memoryword w ;
{eqdestroy_regmem
  halfword q  ;
  switch ( w .hh.b0 )
  {case 111 :
  case 112 :
  case 113 :
  case 114 :
    deletetokenref ( w .hh .v.RH ) ;
    break ;
  case 117 :
    deleteglueref ( w .hh .v.RH ) ;
    break ;
  case 118 :
    {
      q = w .hh .v.RH ;
      if ( q != 0 )
      freenode ( q , mem [ q ] .hh .v.LH + mem [ q ] .hh .v.LH + 1 ) ;
    }
    break ;
  case 119 :
    flushnodelist ( w .hh .v.RH ) ;
    break ;
    default:
    ;
    break ;
  }
}
void zeqsave ( p , l )
halfword p ;
quarterword l ;
{eqsave_regmem
  if ( saveptr > maxsavestack )
  {
    maxsavestack = saveptr ;
    if ( maxsavestack > savesize - 6 )
    overflow ( 538 , savesize ) ;
  }
  if ( l == 0 )
  savestack [ saveptr ] .hh.b0 = 1 ;
  else {

    savestack [ saveptr ] = eqtb [ p ] ;
    incr ( saveptr ) ;
    savestack [ saveptr ] .hh.b0 = 0 ;
  }
  savestack [ saveptr ] .hh.b1 = l ;
  savestack [ saveptr ] .hh .v.RH = p ;
  incr ( saveptr ) ;
}
void zeqdefine ( p , t , e )
halfword p ;
quarterword t ;
halfword e ;
{eqdefine_regmem
  if ( eqtb [ p ] .hh.b1 == curlevel )
  eqdestroy ( eqtb [ p ] ) ;
  else if ( curlevel > 1 )
  eqsave ( p , eqtb [ p ] .hh.b1 ) ;
  eqtb [ p ] .hh.b1 = curlevel ;
  eqtb [ p ] .hh.b0 = t ;
  eqtb [ p ] .hh .v.RH = e ;
}
void zeqworddefine ( p , w )
halfword p ;
integer w ;
{eqworddefine_regmem
  if ( xeqlevel [ p ] != curlevel )
  {
    eqsave ( p , xeqlevel [ p ] ) ;
    xeqlevel [ p ] = curlevel ;
  }
  eqtb [ p ] .cint = w ;
}
void zgeqdefine ( p , t , e )
halfword p ;
quarterword t ;
halfword e ;
{geqdefine_regmem
  eqdestroy ( eqtb [ p ] ) ;
  eqtb [ p ] .hh.b1 = 1 ;
  eqtb [ p ] .hh.b0 = t ;
  eqtb [ p ] .hh .v.RH = e ;
}
void zgeqworddefine ( p , w )
halfword p ;
integer w ;
{geqworddefine_regmem
  eqtb [ p ] .cint = w ;
  xeqlevel [ p ] = 1 ;
}
void zsaveforafter ( t )
halfword t ;
{saveforafter_regmem
  if ( curlevel > 1 )
  {
    if ( saveptr > maxsavestack )
    {
      maxsavestack = saveptr ;
      if ( maxsavestack > savesize - 6 )
      overflow ( 538 , savesize ) ;
    }
    savestack [ saveptr ] .hh.b0 = 2 ;
    savestack [ saveptr ] .hh.b1 = 0 ;
    savestack [ saveptr ] .hh .v.RH = t ;
    incr ( saveptr ) ;
  }
}
#ifdef STAT
void zrestoretrace ( p , s )
halfword p ;
strnumber s ;
{restoretrace_regmem
  begindiagnostic () ;
  printchar ( 123 ) ;
  print ( s ) ;
  printchar ( 32 ) ;
  showeqtb ( p ) ;
  printchar ( 125 ) ;
  enddiagnostic ( false ) ;
}
#endif /* STAT */
void unsave ( )
{/* 30 */ unsave_regmem
  halfword p  ;
  quarterword l  ;
  halfword t  ;
  if ( curlevel > 1 )
  {
    decr ( curlevel ) ;
    while ( true ) {

      decr ( saveptr ) ;
      if ( savestack [ saveptr ] .hh.b0 == 3 )
      goto lab30 ;
      p = savestack [ saveptr ] .hh .v.RH ;
      if ( savestack [ saveptr ] .hh.b0 == 2 )
      {
	t = curtok ;
	curtok = p ;
	backinput () ;
	curtok = t ;
      }
      else {

	if ( savestack [ saveptr ] .hh.b0 == 0 )
	{
	  l = savestack [ saveptr ] .hh.b1 ;
	  decr ( saveptr ) ;
	}
	else savestack [ saveptr ] = eqtb [ 6781 ] ;
	if ( p < 9163 )
	if ( eqtb [ p ] .hh.b1 == 1 )
	{
	  eqdestroy ( savestack [ saveptr ] ) ;
	;
#ifdef STAT
	  if ( eqtb [ 9200 ] .cint > 0 )
	  restoretrace ( p , 541 ) ;
#endif /* STAT */
	}
	else {

	  eqdestroy ( eqtb [ p ] ) ;
	  eqtb [ p ] = savestack [ saveptr ] ;
	;
#ifdef STAT
	  if ( eqtb [ 9200 ] .cint > 0 )
	  restoretrace ( p , 542 ) ;
#endif /* STAT */
	}
	else if ( xeqlevel [ p ] != 1 )
	{
	  eqtb [ p ] = savestack [ saveptr ] ;
	  xeqlevel [ p ] = l ;
	;
#ifdef STAT
	  if ( eqtb [ 9200 ] .cint > 0 )
	  restoretrace ( p , 542 ) ;
#endif /* STAT */
	}
	else {

	;
#ifdef STAT
	  if ( eqtb [ 9200 ] .cint > 0 )
	  restoretrace ( p , 541 ) ;
#endif /* STAT */
	}
      }
    }
    lab30: curgroup = savestack [ saveptr ] .hh.b1 ;
    curboundary = savestack [ saveptr ] .hh .v.RH ;
  }
  else confusion ( 540 ) ;
}
void preparemag ( )
{preparemag_regmem
  if ( ( magset > 0 ) && ( eqtb [ 9180 ] .cint != magset ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 544 ) ;
    }
    printint ( eqtb [ 9180 ] .cint ) ;
    print ( 545 ) ;
    printnl ( 546 ) ;
    {
      helpptr = 2 ;
      helpline [ 1 ] = 547 ;
      helpline [ 0 ] = 548 ;
    }
    interror ( magset ) ;
    geqworddefine ( 9180 , magset ) ;
  }
  if ( ( eqtb [ 9180 ] .cint <= 0 ) || ( eqtb [ 9180 ] .cint > 32768L ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 549 ) ;
    }
    {
      helpptr = 1 ;
      helpline [ 0 ] = 550 ;
    }
    interror ( eqtb [ 9180 ] .cint ) ;
    geqworddefine ( 9180 , 1000 ) ;
  }
  magset = eqtb [ 9180 ] .cint ;
}
void ztokenshow ( p )
halfword p ;
{tokenshow_regmem
  if ( p != 0 )
  showtokenlist ( mem [ p ] .hh .v.RH , 0 , 10000000L ) ;
}
void printmeaning ( )
{printmeaning_regmem
  printcmdchr ( curcmd , curchr ) ;
  if ( curcmd >= 111 )
  {
    printchar ( 58 ) ;
    println () ;
    tokenshow ( curchr ) ;
  }
  else if ( curcmd == 110 )
  {
    printchar ( 58 ) ;
    println () ;
    tokenshow ( curmark [ curchr ] ) ;
  }
}
void showcurcmdchr ( )
{showcurcmdchr_regmem
  begindiagnostic () ;
  printnl ( 123 ) ;
  if ( curlist .modefield != shownmode )
  {
    printmode ( curlist .modefield ) ;
    print ( 565 ) ;
    shownmode = curlist .modefield ;
  }
  printcmdchr ( curcmd , curchr ) ;
  printchar ( 125 ) ;
  enddiagnostic ( false ) ;
}
void showcontext ( )
{/* 30 */ showcontext_regmem
  char oldsetting  ;
  integer nn  ;
  boolean bottomline  ;
  integer i  ;
  integer j  ;
  integer l  ;
  integer m  ;
  integer n  ;
  integer p  ;
  integer q  ;
  baseptr = inputptr ;
  inputstack [ baseptr ] = curinput ;
  nn = -1 ;
  bottomline = false ;
  while ( true ) {

    curinput = inputstack [ baseptr ] ;
    if ( ( curinput .statefield != 0 ) )
    if ( ( curinput .namefield > 17 ) || ( baseptr == 0 ) )
    bottomline = true ;
    if ( ( baseptr == inputptr ) || bottomline || ( nn < eqtb [ 9217 ] .cint )
    )
    {
      if ( ( baseptr == inputptr ) || ( curinput .statefield != 0 ) || (
      curinput .indexfield != 3 ) || ( curinput .locfield != 0 ) )
      {
	tally = 0 ;
	oldsetting = selector ;
	if ( curinput .statefield != 0 )
	{
	  if ( curinput .namefield <= 17 )
	  if ( ( curinput .namefield == 0 ) )
	  if ( baseptr == 0 )
	  printnl ( 571 ) ;
	  else printnl ( 572 ) ;
	  else {

	    printnl ( 573 ) ;
	    if ( curinput .namefield == 17 )
	    printchar ( 42 ) ;
	    else printint ( curinput .namefield - 1 ) ;
	    printchar ( 62 ) ;
	  }
	  else {

	    printnl ( 574 ) ;
	    printint ( line ) ;
	  }
	  printchar ( 32 ) ;
	  {
	    l = tally ;
	    tally = 0 ;
	    selector = 20 ;
	    trickcount = 1000000L ;
	  }
	  if ( buffer [ curinput .limitfield ] == eqtb [ 9211 ] .cint )
	  j = curinput .limitfield ;
	  else j = curinput .limitfield + 1 ;
	  if ( j > 0 )
	  {register integer for_end; i = curinput .startfield ; for_end = j -
	  1 ; if ( i <= for_end) do
	    {
	      if ( i == curinput .locfield )
	      {
		firstcount = tally ;
		trickcount = tally + 1 + errorline - halferrorline ;
		if ( trickcount < errorline )
		trickcount = errorline ;
	      }
	      print ( buffer [ i ] ) ;
	    }
	  while ( i++ < for_end ) ; }
	}
	else {

	  switch ( curinput .indexfield )
	  {case 0 :
	    printnl ( 575 ) ;
	    break ;
	  case 1 :
	  case 2 :
	    printnl ( 576 ) ;
	    break ;
	  case 3 :
	    if ( curinput .locfield == 0 )
	    printnl ( 577 ) ;
	    else printnl ( 578 ) ;
	    break ;
	  case 4 :
	    printnl ( 579 ) ;
	    break ;
	  case 5 :
	    {
	      println () ;
	      printcs ( curinput .namefield ) ;
	    }
	    break ;
	  case 6 :
	    printnl ( 580 ) ;
	    break ;
	  case 7 :
	    printnl ( 581 ) ;
	    break ;
	  case 8 :
	    printnl ( 582 ) ;
	    break ;
	  case 9 :
	    printnl ( 583 ) ;
	    break ;
	  case 10 :
	    printnl ( 584 ) ;
	    break ;
	  case 11 :
	    printnl ( 585 ) ;
	    break ;
	  case 12 :
	    printnl ( 586 ) ;
	    break ;
	  case 13 :
	    printnl ( 587 ) ;
	    break ;
	  case 14 :
	    printnl ( 588 ) ;
	    break ;
	  case 15 :
	    printnl ( 589 ) ;
	    break ;
	    default:
	    printnl ( 63 ) ;
	    break ;
	  }
	  {
	    l = tally ;
	    tally = 0 ;
	    selector = 20 ;
	    trickcount = 1000000L ;
	  }
	  if ( curinput .indexfield < 5 )
	  showtokenlist ( curinput .startfield , curinput .locfield , 100000L
	  ) ;
	  else showtokenlist ( mem [ curinput .startfield ] .hh .v.RH ,
	  curinput .locfield , 100000L ) ;
	}
	selector = oldsetting ;
	if ( trickcount == 1000000L )
	{
	  firstcount = tally ;
	  trickcount = tally + 1 + errorline - halferrorline ;
	  if ( trickcount < errorline )
	  trickcount = errorline ;
	}
	if ( tally < trickcount )
	m = tally - firstcount ;
	else m = trickcount - firstcount ;
	if ( l + firstcount <= halferrorline )
	{
	  p = 0 ;
	  n = l + firstcount ;
	}
	else {

	  print ( 275 ) ;
	  p = l + firstcount - halferrorline + 3 ;
	  n = halferrorline ;
	}
	{register integer for_end; q = p ; for_end = firstcount - 1 ; if ( q
	<= for_end) do
	  printchar ( trickbuf [ q % errorline ] ) ;
	while ( q++ < for_end ) ; }
	println () ;
	{register integer for_end; q = 1 ; for_end = n ; if ( q <= for_end)
	do
	  printchar ( 32 ) ;
	while ( q++ < for_end ) ; }
	if ( m + n <= errorline )
	p = firstcount + m ;
	else p = firstcount + ( errorline - n - 3 ) ;
	{register integer for_end; q = firstcount ; for_end = p - 1 ; if ( q
	<= for_end) do
	  printchar ( trickbuf [ q % errorline ] ) ;
	while ( q++ < for_end ) ; }
	if ( m + n > errorline )
	print ( 275 ) ;
	incr ( nn ) ;
      }
    }
    else if ( nn == eqtb [ 9217 ] .cint )
    {
      printnl ( 275 ) ;
      incr ( nn ) ;
    }
    if ( bottomline )
    goto lab30 ;
    decr ( baseptr ) ;
  }
  lab30: curinput = inputstack [ inputptr ] ;
}
void zbegintokenlist ( p , t )
halfword p ;
quarterword t ;
{begintokenlist_regmem
  {
    if ( inputptr > maxinstack )
    {
      maxinstack = inputptr ;
      if ( inputptr == stacksize )
      overflow ( 590 , stacksize ) ;
    }
    inputstack [ inputptr ] = curinput ;
    incr ( inputptr ) ;
  }
  curinput .statefield = 0 ;
  curinput .startfield = p ;
  curinput .indexfield = t ;
  if ( t >= 5 )
  {
    incr ( mem [ p ] .hh .v.LH ) ;
    if ( t == 5 )
    curinput .limitfield = paramptr ;
    else {

      curinput .locfield = mem [ p ] .hh .v.RH ;
      if ( eqtb [ 9193 ] .cint > 1 )
      {
	begindiagnostic () ;
	printnl ( 335 ) ;
	switch ( t )
	{case 14 :
	  printesc ( 348 ) ;
	  break ;
	case 15 :
	  printesc ( 591 ) ;
	  break ;
	  default:
	  printcmdchr ( 72 , t + 7307 ) ;
	  break ;
	}
	print ( 553 ) ;
	tokenshow ( p ) ;
	enddiagnostic ( false ) ;
      }
    }
  }
  else curinput .locfield = p ;
}
void endtokenlist ( )
{endtokenlist_regmem
  if ( curinput .indexfield >= 3 )
  {
    if ( curinput .indexfield <= 4 )
    flushlist ( curinput .startfield ) ;
    else {

      deletetokenref ( curinput .startfield ) ;
      if ( curinput .indexfield == 5 )
      while ( paramptr > curinput .limitfield ) {

	decr ( paramptr ) ;
	flushlist ( paramstack [ paramptr ] ) ;
      }
    }
  }
  else if ( curinput .indexfield == 1 )
  if ( alignstate > 500000L )
  alignstate = 0 ;
  else fatalerror ( 592 ) ;
  {
    decr ( inputptr ) ;
    curinput = inputstack [ inputptr ] ;
  }
  {
    if ( interrupt != 0 )
    pauseforinstructions () ;
  }
}
void backinput ( )
{backinput_regmem
  halfword p  ;
  while ( ( curinput .statefield == 0 ) && ( curinput .locfield == 0 ) )
  endtokenlist () ;
  p = getavail () ;
  mem [ p ] .hh .v.LH = curtok ;
  if ( curtok < 768 )
  if ( curtok < 512 )
  decr ( alignstate ) ;
  else incr ( alignstate ) ;
  {
    if ( inputptr > maxinstack )
    {
      maxinstack = inputptr ;
      if ( inputptr == stacksize )
      overflow ( 590 , stacksize ) ;
    }
    inputstack [ inputptr ] = curinput ;
    incr ( inputptr ) ;
  }
  curinput .statefield = 0 ;
  curinput .startfield = p ;
  curinput .indexfield = 3 ;
  curinput .locfield = p ;
}
void backerror ( )
{backerror_regmem
  OKtointerrupt = false ;
  backinput () ;
  OKtointerrupt = true ;
  error () ;
}
void inserror ( )
{inserror_regmem
  OKtointerrupt = false ;
  backinput () ;
  curinput .indexfield = 4 ;
  OKtointerrupt = true ;
  error () ;
}
void beginfilereading ( )
{beginfilereading_regmem
  if ( inopen == maxinopen )
  overflow ( 593 , maxinopen ) ;
  if ( first == bufsize )
  overflow ( 256 , bufsize ) ;
  incr ( inopen ) ;
  {
    if ( inputptr > maxinstack )
    {
      maxinstack = inputptr ;
      if ( inputptr == stacksize )
      overflow ( 590 , stacksize ) ;
    }
    inputstack [ inputptr ] = curinput ;
    incr ( inputptr ) ;
  }
  curinput .indexfield = inopen ;
  linestack [ curinput .indexfield ] = line ;
  curinput .startfield = first ;
  curinput .statefield = 1 ;
  curinput .namefield = 0 ;
}
void endfilereading ( )
{endfilereading_regmem
  first = curinput .startfield ;
  line = linestack [ curinput .indexfield ] ;
  if ( curinput .namefield > 17 )
  aclose ( inputfile [ curinput .indexfield ] ) ;
  {
    decr ( inputptr ) ;
    curinput = inputstack [ inputptr ] ;
  }
  decr ( inopen ) ;
}
void clearforerrorprompt ( )
{clearforerrorprompt_regmem
  while ( ( curinput .statefield != 0 ) && ( curinput .namefield == 0 ) && (
  inputptr > 0 ) && ( curinput .locfield > curinput .limitfield ) )
  endfilereading () ;
  println () ;
}
void checkoutervalidity ( )
{checkoutervalidity_regmem
  halfword p  ;
  halfword q  ;
  if ( scannerstatus != 0 )
  {
    deletionsallowed = false ;
    if ( curcs != 0 )
    {
      if ( ( curinput .statefield == 0 ) || ( curinput .namefield < 1 ) || (
      curinput .namefield > 17 ) )
      {
	p = getavail () ;
	mem [ p ] .hh .v.LH = 4095 + curcs ;
	begintokenlist ( p , 3 ) ;
      }
      curcmd = 10 ;
      curchr = 32 ;
    }
    if ( scannerstatus > 1 )
    {
      runaway () ;
      if ( curcs == 0 )
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 601 ) ;
      }
      else {

	curcs = 0 ;
	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 602 ) ;
	}
      }
      print ( 603 ) ;
      p = getavail () ;
      switch ( scannerstatus )
      {case 2 :
	{
	  print ( 567 ) ;
	  mem [ p ] .hh .v.LH = 637 ;
	}
	break ;
      case 3 :
	{
	  print ( 609 ) ;
	  mem [ p ] .hh .v.LH = partoken ;
	  longstate = 113 ;
	}
	break ;
      case 4 :
	{
	  print ( 569 ) ;
	  mem [ p ] .hh .v.LH = 637 ;
	  q = p ;
	  p = getavail () ;
	  mem [ p ] .hh .v.RH = q ;
	  mem [ p ] .hh .v.LH = 10610 ;
	  alignstate = -1000000L ;
	}
	break ;
      case 5 :
	{
	  print ( 570 ) ;
	  mem [ p ] .hh .v.LH = 637 ;
	}
	break ;
      }
      begintokenlist ( p , 4 ) ;
      print ( 604 ) ;
      sprintcs ( warningindex ) ;
      {
	helpptr = 4 ;
	helpline [ 3 ] = 605 ;
	helpline [ 2 ] = 606 ;
	helpline [ 1 ] = 607 ;
	helpline [ 0 ] = 608 ;
      }
      error () ;
    }
    else {

      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 595 ) ;
      }
      printcmdchr ( 105 , curif ) ;
      print ( 596 ) ;
      printint ( skipline ) ;
      {
	helpptr = 3 ;
	helpline [ 2 ] = 597 ;
	helpline [ 1 ] = 598 ;
	helpline [ 0 ] = 599 ;
      }
      if ( curcs != 0 )
      curcs = 0 ;
      else helpline [ 2 ] = 600 ;
      curtok = 10613 ;
      inserror () ;
    }
    deletionsallowed = true ;
  }
}
void getnext ( )
{/* 20 25 21 26 40 10 */ getnext_regmem
  integer k  ;
  halfword t  ;
  char cat  ;
  ASCIIcode c, cc  ;
  char d  ;
  lab20: curcs = 0 ;
  if ( curinput .statefield != 0 )
  {
    lab25: if ( curinput .locfield <= curinput .limitfield )
    {
      curchr = buffer [ curinput .locfield ] ;
      incr ( curinput .locfield ) ;
      lab21: curcmd = eqtb [ 7883 + curchr ] .hh .v.RH ;
      switch ( curinput .statefield + curcmd )
      {case 10 :
      case 26 :
      case 42 :
      case 27 :
      case 43 :
	goto lab25 ;
	break ;
      case 1 :
      case 17 :
      case 33 :
	{
	  if ( curinput .locfield > curinput .limitfield )
	  curcs = 513 ;
	  else {

	    lab26: k = curinput .locfield ;
	    curchr = buffer [ k ] ;
	    cat = eqtb [ 7883 + curchr ] .hh .v.RH ;
	    incr ( k ) ;
	    if ( cat == 11 )
	    curinput .statefield = 17 ;
	    else if ( cat == 10 )
	    curinput .statefield = 17 ;
	    else curinput .statefield = 1 ;
	    if ( ( cat == 11 ) && ( k <= curinput .limitfield ) )
	    {
	      do {
		  curchr = buffer [ k ] ;
		cat = eqtb [ 7883 + curchr ] .hh .v.RH ;
		incr ( k ) ;
	      } while ( ! ( ( cat != 11 ) || ( k > curinput .limitfield ) ) )
	      ;
	      {
		if ( buffer [ k ] == curchr )
		if ( cat == 7 )
		if ( k < curinput .limitfield )
		{
		  c = buffer [ k + 1 ] ;
		  if ( c < 128 )
		  {
		    d = 2 ;
		    if ( ( ( ( c >= 48 ) && ( c <= 57 ) ) || ( ( c >= 97 ) &&
		    ( c <= 102 ) ) ) )
		    if ( k + 2 <= curinput .limitfield )
		    {
		      cc = buffer [ k + 2 ] ;
		      if ( ( ( ( cc >= 48 ) && ( cc <= 57 ) ) || ( ( cc >= 97
		      ) && ( cc <= 102 ) ) ) )
		      incr ( d ) ;
		    }
		    if ( d > 2 )
		    {
		      if ( c <= 57 )
		      curchr = c - 48 ;
		      else curchr = c - 87 ;
		      if ( cc <= 57 )
		      curchr = 16 * curchr + cc - 48 ;
		      else curchr = 16 * curchr + cc - 87 ;
		      buffer [ k - 1 ] = curchr ;
		    }
		    else if ( c < 64 )
		    buffer [ k - 1 ] = c + 64 ;
		    else buffer [ k - 1 ] = c - 64 ;
		    curinput .limitfield = curinput .limitfield - d ;
		    first = first - d ;
		    while ( k <= curinput .limitfield ) {

		      buffer [ k ] = buffer [ k + d ] ;
		      incr ( k ) ;
		    }
		    goto lab26 ;
		  }
		}
	      }
	      if ( cat != 11 )
	      decr ( k ) ;
	      if ( k > curinput .locfield + 1 )
	      {
		curcs = idlookup ( curinput .locfield , k - curinput .locfield
		) ;
		curinput .locfield = k ;
		goto lab40 ;
	      }
	    }
	    else {

	      if ( buffer [ k ] == curchr )
	      if ( cat == 7 )
	      if ( k < curinput .limitfield )
	      {
		c = buffer [ k + 1 ] ;
		if ( c < 128 )
		{
		  d = 2 ;
		  if ( ( ( ( c >= 48 ) && ( c <= 57 ) ) || ( ( c >= 97 ) && (
		  c <= 102 ) ) ) )
		  if ( k + 2 <= curinput .limitfield )
		  {
		    cc = buffer [ k + 2 ] ;
		    if ( ( ( ( cc >= 48 ) && ( cc <= 57 ) ) || ( ( cc >= 97 )
		    && ( cc <= 102 ) ) ) )
		    incr ( d ) ;
		  }
		  if ( d > 2 )
		  {
		    if ( c <= 57 )
		    curchr = c - 48 ;
		    else curchr = c - 87 ;
		    if ( cc <= 57 )
		    curchr = 16 * curchr + cc - 48 ;
		    else curchr = 16 * curchr + cc - 87 ;
		    buffer [ k - 1 ] = curchr ;
		  }
		  else if ( c < 64 )
		  buffer [ k - 1 ] = c + 64 ;
		  else buffer [ k - 1 ] = c - 64 ;
		  curinput .limitfield = curinput .limitfield - d ;
		  first = first - d ;
		  while ( k <= curinput .limitfield ) {

		    buffer [ k ] = buffer [ k + d ] ;
		    incr ( k ) ;
		  }
		  goto lab26 ;
		}
	      }
	    }
	    curcs = 257 + buffer [ curinput .locfield ] ;
	    incr ( curinput .locfield ) ;
	  }
	  lab40: curcmd = eqtb [ curcs ] .hh.b0 ;
	  curchr = eqtb [ curcs ] .hh .v.RH ;
	  if ( curcmd >= 113 )
	  checkoutervalidity () ;
	}
	break ;
      case 14 :
      case 30 :
      case 46 :
	{
	  curcs = curchr + 1 ;
	  curcmd = eqtb [ curcs ] .hh.b0 ;
	  curchr = eqtb [ curcs ] .hh .v.RH ;
	  curinput .statefield = 1 ;
	  if ( curcmd >= 113 )
	  checkoutervalidity () ;
	}
	break ;
      case 8 :
      case 24 :
      case 40 :
	{
	  if ( curchr == buffer [ curinput .locfield ] )
	  if ( curinput .locfield < curinput .limitfield )
	  {
	    c = buffer [ curinput .locfield + 1 ] ;
	    if ( c < 128 )
	    {
	      curinput .locfield = curinput .locfield + 2 ;
	      if ( ( ( ( c >= 48 ) && ( c <= 57 ) ) || ( ( c >= 97 ) && ( c <=
	      102 ) ) ) )
	      if ( curinput .locfield <= curinput .limitfield )
	      {
		cc = buffer [ curinput .locfield ] ;
		if ( ( ( ( cc >= 48 ) && ( cc <= 57 ) ) || ( ( cc >= 97 ) && (
		cc <= 102 ) ) ) )
		{
		  incr ( curinput .locfield ) ;
		  if ( c <= 57 )
		  curchr = c - 48 ;
		  else curchr = c - 87 ;
		  if ( cc <= 57 )
		  curchr = 16 * curchr + cc - 48 ;
		  else curchr = 16 * curchr + cc - 87 ;
		  goto lab21 ;
		}
	      }
	      if ( c < 64 )
	      curchr = c + 64 ;
	      else curchr = c - 64 ;
	      goto lab21 ;
	    }
	  }
	  curinput .statefield = 1 ;
	}
	break ;
      case 16 :
      case 32 :
      case 48 :
	{
	  {
	    if ( interaction == 3 )
	    ;
	    printnl ( 262 ) ;
	    print ( 610 ) ;
	  }
	  {
	    helpptr = 2 ;
	    helpline [ 1 ] = 611 ;
	    helpline [ 0 ] = 612 ;
	  }
	  deletionsallowed = false ;
	  error () ;
	  deletionsallowed = true ;
	  goto lab20 ;
	}
	break ;
      case 11 :
	{
	  curinput .statefield = 17 ;
	  curchr = 32 ;
	}
	break ;
      case 6 :
	{
	  curinput .locfield = curinput .limitfield + 1 ;
	  curcmd = 10 ;
	  curchr = 32 ;
	}
	break ;
      case 22 :
      case 15 :
      case 31 :
      case 47 :
	{
	  curinput .locfield = curinput .limitfield + 1 ;
	  goto lab25 ;
	}
	break ;
      case 38 :
	{
	  curinput .locfield = curinput .limitfield + 1 ;
	  curcs = parloc ;
	  curcmd = eqtb [ curcs ] .hh.b0 ;
	  curchr = eqtb [ curcs ] .hh .v.RH ;
	  if ( curcmd >= 113 )
	  checkoutervalidity () ;
	}
	break ;
      case 2 :
	incr ( alignstate ) ;
	break ;
      case 18 :
      case 34 :
	{
	  curinput .statefield = 1 ;
	  incr ( alignstate ) ;
	}
	break ;
      case 3 :
	decr ( alignstate ) ;
	break ;
      case 19 :
      case 35 :
	{
	  curinput .statefield = 1 ;
	  decr ( alignstate ) ;
	}
	break ;
      case 20 :
      case 21 :
      case 23 :
      case 25 :
      case 28 :
      case 29 :
      case 36 :
      case 37 :
      case 39 :
      case 41 :
      case 44 :
      case 45 :
	curinput .statefield = 1 ;
	break ;
	default:
	;
	break ;
      }
    }
    else {

      curinput .statefield = 33 ;
      if ( curinput .namefield > 17 )
      {
	incr ( line ) ;
	first = curinput .startfield ;
	if ( ! forceeof )
	{
	  if ( inputln ( inputfile [ curinput .indexfield ] , true ) )
	  firmuptheline () ;
	  else forceeof = true ;
	}
	if ( forceeof )
	{
	  printchar ( 41 ) ;
	  decr ( openparens ) ;
	  flush ( stdout ) ;
	  forceeof = false ;
	  endfilereading () ;
	  checkoutervalidity () ;
	  goto lab20 ;
	}
	if ( ( eqtb [ 9211 ] .cint < 0 ) || ( eqtb [ 9211 ] .cint > 255 ) )
	decr ( curinput .limitfield ) ;
	else buffer [ curinput .limitfield ] = eqtb [ 9211 ] .cint ;
	first = curinput .limitfield + 1 ;
	curinput .locfield = curinput .startfield ;
      }
      else {

	if ( ! ( curinput .namefield == 0 ) )
	{
	  curcmd = 0 ;
	  curchr = 0 ;
	  return ;
	}
	if ( inputptr > 0 )
	{
	  endfilereading () ;
	  goto lab20 ;
	}
	if ( selector < 18 )
	openlogfile () ;
	if ( interaction > 1 )
	{
	  if ( ( eqtb [ 9211 ] .cint < 0 ) || ( eqtb [ 9211 ] .cint > 255 ) )
	  incr ( curinput .limitfield ) ;
	  if ( curinput .limitfield == curinput .startfield )
	  printnl ( 613 ) ;
	  println () ;
	  first = curinput .startfield ;
	  {
	    ;
	    print ( 42 ) ;
	    terminput () ;
	  }
	  curinput .limitfield = last ;
	  if ( ( eqtb [ 9211 ] .cint < 0 ) || ( eqtb [ 9211 ] .cint > 255 ) )
	  decr ( curinput .limitfield ) ;
	  else buffer [ curinput .limitfield ] = eqtb [ 9211 ] .cint ;
	  first = curinput .limitfield + 1 ;
	  curinput .locfield = curinput .startfield ;
	}
	else fatalerror ( 614 ) ;
      }
      {
	if ( interrupt != 0 )
	pauseforinstructions () ;
      }
      goto lab25 ;
    }
  }
  else if ( curinput .locfield != 0 )
  {
    t = mem [ curinput .locfield ] .hh .v.LH ;
    curinput .locfield = mem [ curinput .locfield ] .hh .v.RH ;
    if ( t >= 4095 )
    {
      curcs = t - 4095 ;
      curcmd = eqtb [ curcs ] .hh.b0 ;
      curchr = eqtb [ curcs ] .hh .v.RH ;
      if ( curcmd >= 113 )
      if ( curcmd == 116 )
      {
	curcs = mem [ curinput .locfield ] .hh .v.LH - 4095 ;
	curinput .locfield = 0 ;
	curcmd = eqtb [ curcs ] .hh.b0 ;
	curchr = eqtb [ curcs ] .hh .v.RH ;
	if ( curcmd > 100 )
	{
	  curcmd = 0 ;
	  curchr = 257 ;
	}
      }
      else checkoutervalidity () ;
    }
    else {

      curcmd = t / 256 ;
      curchr = t % 256 ;
      switch ( curcmd )
      {case 1 :
	incr ( alignstate ) ;
	break ;
      case 2 :
	decr ( alignstate ) ;
	break ;
      case 5 :
	{
	  begintokenlist ( paramstack [ curinput .limitfield + curchr - 1 ] ,
	  0 ) ;
	  goto lab20 ;
	}
	break ;
	default:
	;
	break ;
      }
    }
  }
  else {

    endtokenlist () ;
    goto lab20 ;
  }
  if ( curcmd <= 5 )
  if ( curcmd >= 4 )
  if ( alignstate == 0 )
  {
    if ( scannerstatus == 4 )
    fatalerror ( 592 ) ;
    curcmd = mem [ curalign + 5 ] .hh .v.LH ;
    mem [ curalign + 5 ] .hh .v.LH = curchr ;
    if ( curcmd == 63 )
    begintokenlist ( memtop - 10 , 2 ) ;
    else begintokenlist ( mem [ curalign + 2 ] .cint , 2 ) ;
    alignstate = 1000000L ;
    goto lab20 ;
  }
}
void firmuptheline ( )
{firmuptheline_regmem
  integer k  ;
  curinput .limitfield = last ;
  if ( eqtb [ 9191 ] .cint > 0 )
  if ( interaction > 1 )
  {
    ;
    println () ;
    if ( curinput .startfield < curinput .limitfield )
    {register integer for_end; k = curinput .startfield ; for_end = curinput
    .limitfield - 1 ; if ( k <= for_end) do
      print ( buffer [ k ] ) ;
    while ( k++ < for_end ) ; }
    first = curinput .limitfield ;
    {
      ;
      print ( 615 ) ;
      terminput () ;
    }
    if ( last > first )
    {
      {register integer for_end; k = first ; for_end = last - 1 ; if ( k <=
      for_end) do
	buffer [ k + curinput .startfield - first ] = buffer [ k ] ;
      while ( k++ < for_end ) ; }
      curinput .limitfield = curinput .startfield + last - first ;
    }
  }
}
void gettoken ( )
{gettoken_regmem
  nonewcontrolsequence = false ;
  getnext () ;
  nonewcontrolsequence = true ;
  if ( curcs == 0 )
  curtok = ( curcmd * 256 ) + curchr ;
  else curtok = 4095 + curcs ;
}
void macrocall ( )
{/* 10 22 30 31 40 */ macrocall_regmem
  halfword r  ;
  halfword p  ;
  halfword q  ;
  halfword s  ;
  halfword t  ;
  halfword u, v  ;
  halfword rbraceptr  ;
  smallnumber n  ;
  halfword unbalance  ;
  halfword m  ;
  halfword refcount  ;
  smallnumber savescannerstatus  ;
  halfword savewarningindex  ;
  ASCIIcode matchchr  ;
  savescannerstatus = scannerstatus ;
  savewarningindex = warningindex ;
  warningindex = curcs ;
  refcount = curchr ;
  r = mem [ refcount ] .hh .v.RH ;
  n = 0 ;
  if ( eqtb [ 9193 ] .cint > 0 )
  {
    begindiagnostic () ;
    println () ;
    printcs ( warningindex ) ;
    tokenshow ( refcount ) ;
    enddiagnostic ( false ) ;
  }
  if ( mem [ r ] .hh .v.LH != 3584 )
  {
    scannerstatus = 3 ;
    unbalance = 0 ;
    longstate = eqtb [ curcs ] .hh.b0 ;
    if ( longstate >= 113 )
    longstate = longstate - 2 ;
    do {
	mem [ memtop - 3 ] .hh .v.RH = 0 ;
      if ( ( mem [ r ] .hh .v.LH > 3583 ) || ( mem [ r ] .hh .v.LH < 3328 ) )
      s = 0 ;
      else {

	matchchr = mem [ r ] .hh .v.LH - 3328 ;
	s = mem [ r ] .hh .v.RH ;
	r = s ;
	p = memtop - 3 ;
	m = 0 ;
      }
      lab22: gettoken () ;
      if ( curtok == mem [ r ] .hh .v.LH )
      {
	r = mem [ r ] .hh .v.RH ;
	if ( ( mem [ r ] .hh .v.LH >= 3328 ) && ( mem [ r ] .hh .v.LH <= 3584
	) )
	{
	  if ( curtok < 512 )
	  decr ( alignstate ) ;
	  goto lab40 ;
	}
	else goto lab22 ;
      }
      if ( s != r )
      if ( s == 0 )
      {
	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 647 ) ;
	}
	sprintcs ( warningindex ) ;
	print ( 648 ) ;
	{
	  helpptr = 4 ;
	  helpline [ 3 ] = 649 ;
	  helpline [ 2 ] = 650 ;
	  helpline [ 1 ] = 651 ;
	  helpline [ 0 ] = 652 ;
	}
	error () ;
	goto lab10 ;
      }
      else {

	t = s ;
	do {
	    {
	    q = getavail () ;
	    mem [ p ] .hh .v.RH = q ;
	    mem [ q ] .hh .v.LH = mem [ t ] .hh .v.LH ;
	    p = q ;
	  }
	  incr ( m ) ;
	  u = mem [ t ] .hh .v.RH ;
	  v = s ;
	  while ( true ) {

	    if ( u == r )
	    if ( curtok != mem [ v ] .hh .v.LH )
	    goto lab30 ;
	    else {

	      r = mem [ v ] .hh .v.RH ;
	      goto lab22 ;
	    }
	    if ( mem [ u ] .hh .v.LH != mem [ v ] .hh .v.LH )
	    goto lab30 ;
	    u = mem [ u ] .hh .v.RH ;
	    v = mem [ v ] .hh .v.RH ;
	  }
	  lab30: t = mem [ t ] .hh .v.RH ;
	} while ( ! ( t == r ) ) ;
	r = s ;
      }
      if ( curtok == partoken )
      if ( longstate != 112 )
      {
	if ( longstate == 111 )
	{
	  runaway () ;
	  {
	    if ( interaction == 3 )
	    ;
	    printnl ( 262 ) ;
	    print ( 642 ) ;
	  }
	  sprintcs ( warningindex ) ;
	  print ( 643 ) ;
	  {
	    helpptr = 3 ;
	    helpline [ 2 ] = 644 ;
	    helpline [ 1 ] = 645 ;
	    helpline [ 0 ] = 646 ;
	  }
	  backerror () ;
	}
	pstack [ n ] = mem [ memtop - 3 ] .hh .v.RH ;
	alignstate = alignstate - unbalance ;
	{register integer for_end; m = 0 ; for_end = n ; if ( m <= for_end)
	do
	  flushlist ( pstack [ m ] ) ;
	while ( m++ < for_end ) ; }
	goto lab10 ;
      }
      if ( curtok < 768 )
      if ( curtok < 512 )
      {
	unbalance = 1 ;
	while ( true ) {

	  {
	    {
	      q = avail ;
	      if ( q == 0 )
	      q = getavail () ;
	      else {

		avail = mem [ q ] .hh .v.RH ;
		mem [ q ] .hh .v.RH = 0 ;
	;
#ifdef STAT
		incr ( dynused ) ;
#endif /* STAT */
	      }
	    }
	    mem [ p ] .hh .v.RH = q ;
	    mem [ q ] .hh .v.LH = curtok ;
	    p = q ;
	  }
	  gettoken () ;
	  if ( curtok == partoken )
	  if ( longstate != 112 )
	  {
	    if ( longstate == 111 )
	    {
	      runaway () ;
	      {
		if ( interaction == 3 )
		;
		printnl ( 262 ) ;
		print ( 642 ) ;
	      }
	      sprintcs ( warningindex ) ;
	      print ( 643 ) ;
	      {
		helpptr = 3 ;
		helpline [ 2 ] = 644 ;
		helpline [ 1 ] = 645 ;
		helpline [ 0 ] = 646 ;
	      }
	      backerror () ;
	    }
	    pstack [ n ] = mem [ memtop - 3 ] .hh .v.RH ;
	    alignstate = alignstate - unbalance ;
	    {register integer for_end; m = 0 ; for_end = n ; if ( m <=
	    for_end) do
	      flushlist ( pstack [ m ] ) ;
	    while ( m++ < for_end ) ; }
	    goto lab10 ;
	  }
	  if ( curtok < 768 )
	  if ( curtok < 512 )
	  incr ( unbalance ) ;
	  else {

	    decr ( unbalance ) ;
	    if ( unbalance == 0 )
	    goto lab31 ;
	  }
	}
	lab31: rbraceptr = p ;
	{
	  q = getavail () ;
	  mem [ p ] .hh .v.RH = q ;
	  mem [ q ] .hh .v.LH = curtok ;
	  p = q ;
	}
      }
      else {

	backinput () ;
	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 634 ) ;
	}
	sprintcs ( warningindex ) ;
	print ( 635 ) ;
	{
	  helpptr = 6 ;
	  helpline [ 5 ] = 636 ;
	  helpline [ 4 ] = 637 ;
	  helpline [ 3 ] = 638 ;
	  helpline [ 2 ] = 639 ;
	  helpline [ 1 ] = 640 ;
	  helpline [ 0 ] = 641 ;
	}
	incr ( alignstate ) ;
	longstate = 111 ;
	curtok = partoken ;
	inserror () ;
      }
      else {

	if ( curtok == 2592 )
	if ( mem [ r ] .hh .v.LH <= 3584 )
	if ( mem [ r ] .hh .v.LH >= 3328 )
	goto lab22 ;
	{
	  q = getavail () ;
	  mem [ p ] .hh .v.RH = q ;
	  mem [ q ] .hh .v.LH = curtok ;
	  p = q ;
	}
      }
      incr ( m ) ;
      if ( mem [ r ] .hh .v.LH > 3584 )
      goto lab22 ;
      if ( mem [ r ] .hh .v.LH < 3328 )
      goto lab22 ;
      lab40: if ( s != 0 )
      {
	if ( ( m == 1 ) && ( mem [ p ] .hh .v.LH < 768 ) && ( p != memtop - 3
	) )
	{
	  mem [ rbraceptr ] .hh .v.RH = 0 ;
	  {
	    mem [ p ] .hh .v.RH = avail ;
	    avail = p ;
	;
#ifdef STAT
	    decr ( dynused ) ;
#endif /* STAT */
	  }
	  p = mem [ memtop - 3 ] .hh .v.RH ;
	  pstack [ n ] = mem [ p ] .hh .v.RH ;
	  {
	    mem [ p ] .hh .v.RH = avail ;
	    avail = p ;
	;
#ifdef STAT
	    decr ( dynused ) ;
#endif /* STAT */
	  }
	}
	else pstack [ n ] = mem [ memtop - 3 ] .hh .v.RH ;
	incr ( n ) ;
	if ( eqtb [ 9193 ] .cint > 0 )
	{
	  begindiagnostic () ;
	  printnl ( matchchr ) ;
	  printint ( n ) ;
	  print ( 653 ) ;
	  showtokenlist ( pstack [ n - 1 ] , 0 , 1000 ) ;
	  enddiagnostic ( false ) ;
	}
      }
    } while ( ! ( mem [ r ] .hh .v.LH == 3584 ) ) ;
  }
  while ( ( curinput .statefield == 0 ) && ( curinput .locfield == 0 ) )
  endtokenlist () ;
  begintokenlist ( refcount , 5 ) ;
  curinput .namefield = warningindex ;
  curinput .locfield = mem [ r ] .hh .v.RH ;
  if ( n > 0 )
  {
    if ( paramptr + n > maxparamstack )
    {
      maxparamstack = paramptr + n ;
      if ( maxparamstack > paramsize )
      overflow ( 633 , paramsize ) ;
    }
    {register integer for_end; m = 0 ; for_end = n - 1 ; if ( m <= for_end)
    do
      paramstack [ paramptr + m ] = pstack [ m ] ;
    while ( m++ < for_end ) ; }
    paramptr = paramptr + n ;
  }
  lab10: scannerstatus = savescannerstatus ;
  warningindex = savewarningindex ;
}
void insertrelax ( )
{insertrelax_regmem
  curtok = 4095 + curcs ;
  backinput () ;
  curtok = 10616 ;
  backinput () ;
  curinput .indexfield = 4 ;
}
void expand ( )
{expand_regmem
  halfword t  ;
  halfword p, q, r  ;
  integer j  ;
  integer cvbackup  ;
  smallnumber cvlbackup, radixbackup, cobackup  ;
  halfword backupbackup  ;
  smallnumber savescannerstatus  ;
  cvbackup = curval ;
  cvlbackup = curvallevel ;
  radixbackup = radix ;
  cobackup = curorder ;
  backupbackup = mem [ memtop - 13 ] .hh .v.RH ;
  if ( curcmd < 111 )
  {
    if ( eqtb [ 9199 ] .cint > 1 )
    showcurcmdchr () ;
    switch ( curcmd )
    {case 110 :
      {
	if ( curmark [ curchr ] != 0 )
	begintokenlist ( curmark [ curchr ] , 14 ) ;
      }
      break ;
    case 102 :
      {
	gettoken () ;
	t = curtok ;
	gettoken () ;
	if ( curcmd > 100 )
	expand () ;
	else backinput () ;
	curtok = t ;
	backinput () ;
      }
      break ;
    case 103 :
      {
	savescannerstatus = scannerstatus ;
	scannerstatus = 0 ;
	gettoken () ;
	scannerstatus = savescannerstatus ;
	t = curtok ;
	backinput () ;
	if ( t >= 4095 )
	{
	  p = getavail () ;
	  mem [ p ] .hh .v.LH = 10618 ;
	  mem [ p ] .hh .v.RH = curinput .locfield ;
	  curinput .startfield = p ;
	  curinput .locfield = p ;
	}
      }
      break ;
    case 107 :
      {
	r = getavail () ;
	p = r ;
	do {
	    getxtoken () ;
	  if ( curcs == 0 )
	  {
	    q = getavail () ;
	    mem [ p ] .hh .v.RH = q ;
	    mem [ q ] .hh .v.LH = curtok ;
	    p = q ;
	  }
	} while ( ! ( curcs != 0 ) ) ;
	if ( curcmd != 67 )
	{
	  {
	    if ( interaction == 3 )
	    ;
	    printnl ( 262 ) ;
	    print ( 622 ) ;
	  }
	  printesc ( 502 ) ;
	  print ( 623 ) ;
	  {
	    helpptr = 2 ;
	    helpline [ 1 ] = 624 ;
	    helpline [ 0 ] = 625 ;
	  }
	  backerror () ;
	}
	j = first ;
	p = mem [ r ] .hh .v.RH ;
	while ( p != 0 ) {

	  if ( j >= maxbufstack )
	  {
	    maxbufstack = j + 1 ;
	    if ( maxbufstack == bufsize )
	    overflow ( 256 , bufsize ) ;
	  }
	  buffer [ j ] = mem [ p ] .hh .v.LH % 256 ;
	  incr ( j ) ;
	  p = mem [ p ] .hh .v.RH ;
	}
	if ( j > first + 1 )
	{
	  nonewcontrolsequence = false ;
	  curcs = idlookup ( first , j - first ) ;
	  nonewcontrolsequence = true ;
	}
	else if ( j == first )
	curcs = 513 ;
	else curcs = 257 + buffer [ first ] ;
	flushlist ( r ) ;
	if ( eqtb [ curcs ] .hh.b0 == 101 )
	{
	  eqdefine ( curcs , 0 , 256 ) ;
	}
	curtok = curcs + 4095 ;
	backinput () ;
      }
      break ;
    case 108 :
      convtoks () ;
      break ;
    case 109 :
      insthetoks () ;
      break ;
    case 105 :
      conditional () ;
      break ;
    case 106 :
      if ( curchr > iflimit )
      if ( iflimit == 1 )
      insertrelax () ;
      else {

	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 773 ) ;
	}
	printcmdchr ( 106 , curchr ) ;
	{
	  helpptr = 1 ;
	  helpline [ 0 ] = 774 ;
	}
	error () ;
      }
      else {

	while ( curchr != 2 ) passtext () ;
	{
	  p = condptr ;
	  ifline = mem [ p + 1 ] .cint ;
	  curif = mem [ p ] .hh.b1 ;
	  iflimit = mem [ p ] .hh.b0 ;
	  condptr = mem [ p ] .hh .v.RH ;
	  freenode ( p , 2 ) ;
	}
      }
      break ;
    case 104 :
      if ( curchr > 0 )
      forceeof = true ;
      else if ( nameinprogress )
      insertrelax () ;
      else startinput () ;
      break ;
      default:
      {
	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 616 ) ;
	}
	{
	  helpptr = 5 ;
	  helpline [ 4 ] = 617 ;
	  helpline [ 3 ] = 618 ;
	  helpline [ 2 ] = 619 ;
	  helpline [ 1 ] = 620 ;
	  helpline [ 0 ] = 621 ;
	}
	error () ;
      }
      break ;
    }
  }
  else if ( curcmd < 115 )
  macrocall () ;
  else {

    curtok = 10615 ;
    backinput () ;
  }
  curval = cvbackup ;
  curvallevel = cvlbackup ;
  radix = radixbackup ;
  curorder = cobackup ;
  mem [ memtop - 13 ] .hh .v.RH = backupbackup ;
}
void getxtoken ( )
{/* 20 30 */ getxtoken_regmem
  lab20: getnext () ;
  if ( curcmd <= 100 )
  goto lab30 ;
  if ( curcmd >= 111 )
  if ( curcmd < 115 )
  macrocall () ;
  else {

    curcs = 6520 ;
    curcmd = 9 ;
    goto lab30 ;
  }
  else expand () ;
  goto lab20 ;
  lab30: if ( curcs == 0 )
  curtok = ( curcmd * 256 ) + curchr ;
  else curtok = 4095 + curcs ;
}
void xtoken ( )
{xtoken_regmem
  while ( curcmd > 100 ) {

    expand () ;
    getnext () ;
  }
  if ( curcs == 0 )
  curtok = ( curcmd * 256 ) + curchr ;
  else curtok = 4095 + curcs ;
}
void scanleftbrace ( )
{scanleftbrace_regmem
  do {
      getxtoken () ;
  } while ( ! ( ( curcmd != 10 ) && ( curcmd != 0 ) ) ) ;
  if ( curcmd != 1 )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 654 ) ;
    }
    {
      helpptr = 4 ;
      helpline [ 3 ] = 655 ;
      helpline [ 2 ] = 656 ;
      helpline [ 1 ] = 657 ;
      helpline [ 0 ] = 658 ;
    }
    backerror () ;
    curtok = 379 ;
    curcmd = 1 ;
    curchr = 123 ;
    incr ( alignstate ) ;
  }
}
void scanoptionalequals ( )
{scanoptionalequals_regmem
  do {
      getxtoken () ;
  } while ( ! ( curcmd != 10 ) ) ;
  if ( curtok != 3133 )
  backinput () ;
}
boolean zscankeyword ( s )
strnumber s ;
{/* 10 */ register boolean Result; scankeyword_regmem
  halfword p  ;
  halfword q  ;
  poolpointer k  ;
  p = memtop - 13 ;
  mem [ p ] .hh .v.RH = 0 ;
  k = strstart [ s ] ;
  while ( k < strstart [ s + 1 ] ) {

    getxtoken () ;
    if ( ( curcs == 0 ) && ( ( curchr == strpool [ k ] ) || ( curchr ==
    strpool [ k ] - 32 ) ) )
    {
      {
	q = getavail () ;
	mem [ p ] .hh .v.RH = q ;
	mem [ q ] .hh .v.LH = curtok ;
	p = q ;
      }
      incr ( k ) ;
    }
    else if ( ( curcmd != 10 ) || ( p != memtop - 13 ) )
    {
      backinput () ;
      if ( p != memtop - 13 )
      begintokenlist ( mem [ memtop - 13 ] .hh .v.RH , 3 ) ;
      Result = false ;
      return(Result) ;
    }
  }
  flushlist ( mem [ memtop - 13 ] .hh .v.RH ) ;
  Result = true ;
  return(Result) ;
}
void muerror ( )
{muerror_regmem
  {
    if ( interaction == 3 )
    ;
    printnl ( 262 ) ;
    print ( 659 ) ;
  }
  {
    helpptr = 1 ;
    helpline [ 0 ] = 660 ;
  }
  error () ;
}
void scaneightbitint ( )
{scaneightbitint_regmem
  scanint () ;
  if ( ( curval < 0 ) || ( curval > 255 ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 684 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 685 ;
      helpline [ 0 ] = 686 ;
    }
    interror ( curval ) ;
    curval = 0 ;
  }
}
void scancharnum ( )
{scancharnum_regmem
  scanint () ;
  if ( ( curval < 0 ) || ( curval > 255 ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 687 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 688 ;
      helpline [ 0 ] = 686 ;
    }
    interror ( curval ) ;
    curval = 0 ;
  }
}
void scanfourbitint ( )
{scanfourbitint_regmem
  scanint () ;
  if ( ( curval < 0 ) || ( curval > 15 ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 689 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 690 ;
      helpline [ 0 ] = 686 ;
    }
    interror ( curval ) ;
    curval = 0 ;
  }
}
void scanfifteenbitint ( )
{scanfifteenbitint_regmem
  scanint () ;
  if ( ( curval < 0 ) || ( curval > 32767 ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 691 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 692 ;
      helpline [ 0 ] = 686 ;
    }
    interror ( curval ) ;
    curval = 0 ;
  }
}
void scantwentysevenbitint ( )
{scantwentysevenbitint_regmem
  scanint () ;
  if ( ( curval < 0 ) || ( curval > 134217727L ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 693 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 694 ;
      helpline [ 0 ] = 686 ;
    }
    interror ( curval ) ;
    curval = 0 ;
  }
}
void scanfontident ( )
{scanfontident_regmem
  internalfontnumber f  ;
  halfword m  ;
  do {
      getxtoken () ;
  } while ( ! ( curcmd != 10 ) ) ;
  if ( curcmd == 88 )
  f = eqtb [ 7834 ] .hh .v.RH ;
  else if ( curcmd == 87 )
  f = curchr ;
  else if ( curcmd == 86 )
  {
    m = curchr ;
    scanfourbitint () ;
    f = eqtb [ m + curval ] .hh .v.RH ;
  }
  else {

    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 811 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 812 ;
      helpline [ 0 ] = 813 ;
    }
    backerror () ;
    f = 0 ;
  }
  curval = f ;
}
void zfindfontdimen ( writing )
boolean writing ;
{findfontdimen_regmem
  internalfontnumber f  ;
  integer n  ;
  scanint () ;
  n = curval ;
  scanfontident () ;
  f = curval ;
  if ( n <= 0 )
  curval = fmemptr ;
  else {

    if ( writing && ( n <= 4 ) && ( n >= 2 ) && ( fontglue [ f ] != 0 ) )
    {
      deleteglueref ( fontglue [ f ] ) ;
      fontglue [ f ] = 0 ;
    }
    if ( n > fontparams [ f ] )
    if ( f < fontptr )
    curval = fmemptr ;
    else {

      do {
	  if ( fmemptr == fontmemsize )
	overflow ( 818 , fontmemsize ) ;
	fontinfo [ fmemptr ] .cint = 0 ;
	incr ( fmemptr ) ;
	incr ( fontparams [ f ] ) ;
      } while ( ! ( n == fontparams [ f ] ) ) ;
      curval = fmemptr - 1 ;
    }
    else curval = n + parambase [ f ] ;
  }
  if ( curval == fmemptr )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 796 ) ;
    }
    printesc ( hash [ 6524 + f ] .v.RH ) ;
    print ( 814 ) ;
    printint ( fontparams [ f ] ) ;
    print ( 815 ) ;
    {
      helpptr = 2 ;
      helpline [ 1 ] = 816 ;
      helpline [ 0 ] = 817 ;
    }
    error () ;
  }
}
void zscansomethinginternal ( level , negative )
smallnumber level ;
boolean negative ;
{scansomethinginternal_regmem
  halfword m  ;
  integer p  ;
  m = curchr ;
  switch ( curcmd )
  {case 85 :
    {
      scancharnum () ;
      if ( m == 8907 )
      {
	curval = eqtb [ 8907 + curval ] .hh .v.RH ;
	curvallevel = 0 ;
      }
      else if ( m < 8907 )
      {
	curval = eqtb [ m + curval ] .hh .v.RH ;
	curvallevel = 0 ;
      }
      else {

	curval = eqtb [ m + curval ] .cint ;
	curvallevel = 0 ;
      }
    }
    break ;
  case 71 :
  case 72 :
  case 86 :
  case 87 :
  case 88 :
    if ( level != 5 )
    {
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 661 ) ;
      }
      {
	helpptr = 3 ;
	helpline [ 2 ] = 662 ;
	helpline [ 1 ] = 663 ;
	helpline [ 0 ] = 664 ;
      }
      backerror () ;
      {
	curval = 0 ;
	curvallevel = 1 ;
      }
    }
    else if ( curcmd <= 72 )
    {
      if ( curcmd < 72 )
      {
	scaneightbitint () ;
	m = 7322 + curval ;
      }
      {
	curval = eqtb [ m ] .hh .v.RH ;
	curvallevel = 5 ;
      }
    }
    else {

      backinput () ;
      scanfontident () ;
      {
	curval = 6524 + curval ;
	curvallevel = 4 ;
      }
    }
    break ;
  case 73 :
    {
      curval = eqtb [ m ] .cint ;
      curvallevel = 0 ;
    }
    break ;
  case 74 :
    {
      curval = eqtb [ m ] .cint ;
      curvallevel = 1 ;
    }
    break ;
  case 75 :
    {
      curval = eqtb [ m ] .hh .v.RH ;
      curvallevel = 2 ;
    }
    break ;
  case 76 :
    {
      curval = eqtb [ m ] .hh .v.RH ;
      curvallevel = 3 ;
    }
    break ;
  case 79 :
    if ( abs ( curlist .modefield ) != m )
    {
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 677 ) ;
      }
      printcmdchr ( 79 , m ) ;
      {
	helpptr = 4 ;
	helpline [ 3 ] = 678 ;
	helpline [ 2 ] = 679 ;
	helpline [ 1 ] = 680 ;
	helpline [ 0 ] = 681 ;
      }
      error () ;
      if ( level != 5 )
      {
	curval = 0 ;
	curvallevel = 1 ;
      }
      else {

	curval = 0 ;
	curvallevel = 0 ;
      }
    }
    else if ( m == 1 )
    {
      curval = curlist .auxfield .cint ;
      curvallevel = 1 ;
    }
    else {

      curval = curlist .auxfield .hh .v.LH ;
      curvallevel = 0 ;
    }
    break ;
  case 80 :
    if ( curlist .modefield == 0 )
    {
      curval = 0 ;
      curvallevel = 0 ;
    }
    else {

      nest [ nestptr ] = curlist ;
      p = nestptr ;
      while ( abs ( nest [ p ] .modefield ) != 1 ) decr ( p ) ;
      {
	curval = nest [ p ] .pgfield ;
	curvallevel = 0 ;
      }
    }
    break ;
  case 82 :
    {
      if ( m == 0 )
      curval = deadcycles ;
      else curval = insertpenalties ;
      curvallevel = 0 ;
    }
    break ;
  case 81 :
    {
      if ( ( pagecontents == 0 ) && ( ! outputactive ) )
      if ( m == 0 )
      curval = 1073741823L ;
      else curval = 0 ;
      else curval = pagesofar [ m ] ;
      curvallevel = 1 ;
    }
    break ;
  case 84 :
    {
      if ( eqtb [ 7312 ] .hh .v.RH == 0 )
      curval = 0 ;
      else curval = mem [ eqtb [ 7312 ] .hh .v.RH ] .hh .v.LH ;
      curvallevel = 0 ;
    }
    break ;
  case 83 :
    {
      scaneightbitint () ;
      if ( eqtb [ 7578 + curval ] .hh .v.RH == 0 )
      curval = 0 ;
      else curval = mem [ eqtb [ 7578 + curval ] .hh .v.RH + m ] .cint ;
      curvallevel = 1 ;
    }
    break ;
  case 68 :
  case 69 :
    {
      curval = curchr ;
      curvallevel = 0 ;
    }
    break ;
  case 77 :
    {
      findfontdimen ( false ) ;
      fontinfo [ fmemptr ] .cint = 0 ;
      {
	curval = fontinfo [ curval ] .cint ;
	curvallevel = 1 ;
      }
    }
    break ;
  case 78 :
    {
      scanfontident () ;
      if ( m == 0 )
      {
	curval = hyphenchar [ curval ] ;
	curvallevel = 0 ;
      }
      else {

	curval = skewchar [ curval ] ;
	curvallevel = 0 ;
      }
    }
    break ;
  case 89 :
    {
      scaneightbitint () ;
      switch ( m )
      {case 0 :
	curval = eqtb [ 9218 + curval ] .cint ;
	break ;
      case 1 :
	curval = eqtb [ 9751 + curval ] .cint ;
	break ;
      case 2 :
	curval = eqtb [ 6800 + curval ] .hh .v.RH ;
	break ;
      case 3 :
	curval = eqtb [ 7056 + curval ] .hh .v.RH ;
	break ;
      }
      curvallevel = m ;
    }
    break ;
  case 70 :
    if ( curchr > 2 )
    {
      if ( curchr == 3 )
      curval = line ;
      else curval = lastbadness ;
      curvallevel = 0 ;
    }
    else {

      if ( curchr == 2 )
      curval = 0 ;
      else curval = 0 ;
      curvallevel = curchr ;
      if ( ! ( curlist .tailfield >= himemmin ) && ( curlist .modefield != 0 )
      )
      switch ( curchr )
      {case 0 :
	if ( mem [ curlist .tailfield ] .hh.b0 == 12 )
	curval = mem [ curlist .tailfield + 1 ] .cint ;
	break ;
      case 1 :
	if ( mem [ curlist .tailfield ] .hh.b0 == 11 )
	curval = mem [ curlist .tailfield + 1 ] .cint ;
	break ;
      case 2 :
	if ( mem [ curlist .tailfield ] .hh.b0 == 10 )
	{
	  curval = mem [ curlist .tailfield + 1 ] .hh .v.LH ;
	  if ( mem [ curlist .tailfield ] .hh.b1 == 99 )
	  curvallevel = 3 ;
	}
	break ;
      }
      else if ( ( curlist .modefield == 1 ) && ( curlist .tailfield == curlist
      .headfield ) )
      switch ( curchr )
      {case 0 :
	curval = lastpenalty ;
	break ;
      case 1 :
	curval = lastkern ;
	break ;
      case 2 :
	if ( lastglue != 65535L )
	curval = lastglue ;
	break ;
      }
    }
    break ;
    default:
    {
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 682 ) ;
      }
      printcmdchr ( curcmd , curchr ) ;
      print ( 683 ) ;
      printesc ( 534 ) ;
      {
	helpptr = 1 ;
	helpline [ 0 ] = 681 ;
      }
      error () ;
      if ( level != 5 )
      {
	curval = 0 ;
	curvallevel = 1 ;
      }
      else {

	curval = 0 ;
	curvallevel = 0 ;
      }
    }
    break ;
  }
  while ( curvallevel > level ) {

    if ( curvallevel == 2 )
    curval = mem [ curval + 1 ] .cint ;
    else if ( curvallevel == 3 )
    muerror () ;
    decr ( curvallevel ) ;
  }
  if ( negative )
  if ( curvallevel >= 2 )
  {
    curval = newspec ( curval ) ;
    {
      mem [ curval + 1 ] .cint = - (integer) mem [ curval + 1 ] .cint ;
      mem [ curval + 2 ] .cint = - (integer) mem [ curval + 2 ] .cint ;
      mem [ curval + 3 ] .cint = - (integer) mem [ curval + 3 ] .cint ;
    }
  }
  else curval = - (integer) curval ;
  else if ( ( curvallevel >= 2 ) && ( curvallevel <= 3 ) )
  incr ( mem [ curval ] .hh .v.RH ) ;
}
void scanint ( )
{/* 30 */ scanint_regmem
  boolean negative  ;
  integer m  ;
  smallnumber d  ;
  boolean vacuous  ;
  boolean OKsofar  ;
  radix = 0 ;
  OKsofar = true ;
  negative = false ;
  do {
      do { getxtoken () ;
    } while ( ! ( curcmd != 10 ) ) ;
    if ( curtok == 3117 )
    {
      negative = ! negative ;
      curtok = 3115 ;
    }
  } while ( ! ( curtok != 3115 ) ) ;
  if ( curtok == 3168 )
  {
    gettoken () ;
    if ( curtok < 4095 )
    {
      curval = curchr ;
      if ( curcmd <= 2 )
      if ( curcmd == 2 )
      incr ( alignstate ) ;
      else decr ( alignstate ) ;
    }
    else if ( curtok < 4352 )
    curval = curtok - 4096 ;
    else curval = curtok - 4352 ;
    if ( curval > 255 )
    {
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 695 ) ;
      }
      {
	helpptr = 2 ;
	helpline [ 1 ] = 696 ;
	helpline [ 0 ] = 697 ;
      }
      curval = 48 ;
      backerror () ;
    }
    else {

      getxtoken () ;
      if ( curcmd != 10 )
      backinput () ;
    }
  }
  else if ( ( curcmd >= 68 ) && ( curcmd <= 89 ) )
  scansomethinginternal ( 0 , false ) ;
  else {

    radix = 10 ;
    m = 214748364L ;
    if ( curtok == 3111 )
    {
      radix = 8 ;
      m = 268435456L ;
      getxtoken () ;
    }
    else if ( curtok == 3106 )
    {
      radix = 16 ;
      m = 134217728L ;
      getxtoken () ;
    }
    vacuous = true ;
    curval = 0 ;
    while ( true ) {

      if ( ( curtok < 3120 + radix ) && ( curtok >= 3120 ) && ( curtok <= 3129
      ) )
      d = curtok - 3120 ;
      else if ( radix == 16 )
      if ( ( curtok <= 2886 ) && ( curtok >= 2881 ) )
      d = curtok - 2871 ;
      else if ( ( curtok <= 3142 ) && ( curtok >= 3137 ) )
      d = curtok - 3127 ;
      else goto lab30 ;
      else goto lab30 ;
      vacuous = false ;
      if ( ( curval >= m ) && ( ( curval > m ) || ( d > 7 ) || ( radix != 10 )
      ) )
      {
	if ( OKsofar )
	{
	  {
	    if ( interaction == 3 )
	    ;
	    printnl ( 262 ) ;
	    print ( 698 ) ;
	  }
	  {
	    helpptr = 2 ;
	    helpline [ 1 ] = 699 ;
	    helpline [ 0 ] = 700 ;
	  }
	  error () ;
	  curval = 2147483647L ;
	  OKsofar = false ;
	}
      }
      else curval = curval * radix + d ;
      getxtoken () ;
    }
    lab30: ;
    if ( vacuous )
    {
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 661 ) ;
      }
      {
	helpptr = 3 ;
	helpline [ 2 ] = 662 ;
	helpline [ 1 ] = 663 ;
	helpline [ 0 ] = 664 ;
      }
      backerror () ;
    }
    else if ( curcmd != 10 )
    backinput () ;
  }
  if ( negative )
  curval = - (integer) curval ;
}
void zscandimen ( mu , inf , shortcut )
boolean mu ;
boolean inf ;
boolean shortcut ;
{/* 30 31 32 40 45 88 89 */ scandimen_regmem
  boolean negative  ;
  integer f  ;
  integer num, denom  ;
  smallnumber k, kk  ;
  halfword p, q  ;
  scaled v  ;
  integer savecurval  ;
  f = 0 ;
  aritherror = false ;
  curorder = 0 ;
  negative = false ;
  if ( ! shortcut )
  {
    negative = false ;
    do {
	do { getxtoken () ;
      } while ( ! ( curcmd != 10 ) ) ;
      if ( curtok == 3117 )
      {
	negative = ! negative ;
	curtok = 3115 ;
      }
    } while ( ! ( curtok != 3115 ) ) ;
    if ( ( curcmd >= 68 ) && ( curcmd <= 89 ) )
    if ( mu )
    {
      scansomethinginternal ( 3 , false ) ;
      if ( curvallevel >= 2 )
      {
	v = mem [ curval + 1 ] .cint ;
	deleteglueref ( curval ) ;
	curval = v ;
      }
      if ( curvallevel == 3 )
      goto lab89 ;
      if ( curvallevel != 0 )
      muerror () ;
    }
    else {

      scansomethinginternal ( 1 , false ) ;
      if ( curvallevel == 1 )
      goto lab89 ;
    }
    else {

      backinput () ;
      if ( curtok == 3116 )
      curtok = 3118 ;
      if ( curtok != 3118 )
      scanint () ;
      else {

	radix = 10 ;
	curval = 0 ;
      }
      if ( curtok == 3116 )
      curtok = 3118 ;
      if ( ( radix == 10 ) && ( curtok == 3118 ) )
      {
	k = 0 ;
	p = 0 ;
	gettoken () ;
	while ( true ) {

	  getxtoken () ;
	  if ( ( curtok > 3129 ) || ( curtok < 3120 ) )
	  goto lab31 ;
	  if ( k < 17 )
	  {
	    q = getavail () ;
	    mem [ q ] .hh .v.RH = p ;
	    mem [ q ] .hh .v.LH = curtok - 3120 ;
	    p = q ;
	    incr ( k ) ;
	  }
	}
	lab31: {
	    register integer for_end; kk = k ; for_end = 1 ; if ( kk >=
	for_end) do
	  {
	    dig [ kk - 1 ] = mem [ p ] .hh .v.LH ;
	    q = p ;
	    p = mem [ p ] .hh .v.RH ;
	    {
	      mem [ q ] .hh .v.RH = avail ;
	      avail = q ;
	;
#ifdef STAT
	      decr ( dynused ) ;
#endif /* STAT */
	    }
	  }
	while ( kk-- > for_end ) ; }
	f = rounddecimals ( k ) ;
	if ( curcmd != 10 )
	backinput () ;
      }
    }
  }
  if ( curval < 0 )
  {
    negative = ! negative ;
    curval = - (integer) curval ;
  }
  if ( inf )
  if ( scankeyword ( 309 ) )
  {
    curorder = 1 ;
    while ( scankeyword ( 108 ) ) {

      if ( curorder == 3 )
      {
	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 702 ) ;
	}
	print ( 703 ) ;
	{
	  helpptr = 1 ;
	  helpline [ 0 ] = 704 ;
	}
	error () ;
      }
      else incr ( curorder ) ;
    }
    goto lab88 ;
  }
  savecurval = curval ;
  do {
      getxtoken () ;
  } while ( ! ( curcmd != 10 ) ) ;
  if ( ( curcmd < 68 ) || ( curcmd > 89 ) )
  backinput () ;
  else {

    if ( mu )
    {
      scansomethinginternal ( 3 , false ) ;
      if ( curvallevel >= 2 )
      {
	v = mem [ curval + 1 ] .cint ;
	deleteglueref ( curval ) ;
	curval = v ;
      }
      if ( curvallevel != 3 )
      muerror () ;
    }
    else scansomethinginternal ( 1 , false ) ;
    v = curval ;
    goto lab40 ;
  }
  if ( mu )
  goto lab45 ;
  if ( scankeyword ( 705 ) )
  v = ( fontinfo [ 6 + parambase [ eqtb [ 7834 ] .hh .v.RH ] ] .cint ) ;
  else if ( scankeyword ( 706 ) )
  v = ( fontinfo [ 5 + parambase [ eqtb [ 7834 ] .hh .v.RH ] ] .cint ) ;
  else goto lab45 ;
  {
    getxtoken () ;
    if ( curcmd != 10 )
    backinput () ;
  }
  lab40: curval = multandadd ( savecurval , v , xnoverd ( v , f , 65536L ) ,
  1073741823L ) ;
  goto lab89 ;
  lab45: ;
  if ( mu )
  if ( scankeyword ( 334 ) )
  goto lab88 ;
  else {

    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 702 ) ;
    }
    print ( 707 ) ;
    {
      helpptr = 4 ;
      helpline [ 3 ] = 708 ;
      helpline [ 2 ] = 709 ;
      helpline [ 1 ] = 710 ;
      helpline [ 0 ] = 711 ;
    }
    error () ;
    goto lab88 ;
  }
  if ( scankeyword ( 701 ) )
  {
    preparemag () ;
    if ( eqtb [ 9180 ] .cint != 1000 )
    {
      curval = xnoverd ( curval , 1000 , eqtb [ 9180 ] .cint ) ;
      f = ( 1000 * f + 65536L * texremainder ) / eqtb [ 9180 ] .cint ;
      curval = curval + ( f / 65536L ) ;
      f = f % 65536L ;
    }
  }
  if ( scankeyword ( 394 ) )
  goto lab88 ;
  if ( scankeyword ( 712 ) )
  {
    num = 7227 ;
    denom = 100 ;
  }
  else if ( scankeyword ( 713 ) )
  {
    num = 12 ;
    denom = 1 ;
  }
  else if ( scankeyword ( 714 ) )
  {
    num = 7227 ;
    denom = 254 ;
  }
  else if ( scankeyword ( 715 ) )
  {
    num = 7227 ;
    denom = 2540 ;
  }
  else if ( scankeyword ( 716 ) )
  {
    num = 7227 ;
    denom = 7200 ;
  }
  else if ( scankeyword ( 717 ) )
  {
    num = 1238 ;
    denom = 1157 ;
  }
  else if ( scankeyword ( 718 ) )
  {
    num = 14856 ;
    denom = 1157 ;
  }
  else if ( scankeyword ( 719 ) )
  goto lab30 ;
  else {

    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 702 ) ;
    }
    print ( 720 ) ;
    {
      helpptr = 6 ;
      helpline [ 5 ] = 721 ;
      helpline [ 4 ] = 722 ;
      helpline [ 3 ] = 723 ;
      helpline [ 2 ] = 709 ;
      helpline [ 1 ] = 710 ;
      helpline [ 0 ] = 711 ;
    }
    error () ;
    goto lab32 ;
  }
  curval = xnoverd ( curval , num , denom ) ;
  f = ( num * f + 65536L * texremainder ) / denom ;
  curval = curval + ( f / 65536L ) ;
  f = f % 65536L ;
  lab32: ;
  lab88: if ( curval >= 16384 )
  aritherror = true ;
  else curval = curval * 65536L + f ;
  lab30: ;
  {
    getxtoken () ;
    if ( curcmd != 10 )
    backinput () ;
  }
  lab89: if ( aritherror || ( abs ( curval ) >= 1073741824L ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 724 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 725 ;
      helpline [ 0 ] = 726 ;
    }
    error () ;
    curval = 1073741823L ;
    aritherror = false ;
  }
  if ( negative )
  curval = - (integer) curval ;
}
void zscanglue ( level )
smallnumber level ;
{/* 10 */ scanglue_regmem
  boolean negative  ;
  halfword q  ;
  boolean mu  ;
  mu = ( level == 3 ) ;
  negative = false ;
  do {
      do { getxtoken () ;
    } while ( ! ( curcmd != 10 ) ) ;
    if ( curtok == 3117 )
    {
      negative = ! negative ;
      curtok = 3115 ;
    }
  } while ( ! ( curtok != 3115 ) ) ;
  if ( ( curcmd >= 68 ) && ( curcmd <= 89 ) )
  {
    scansomethinginternal ( level , negative ) ;
    if ( curvallevel >= 2 )
    {
      if ( curvallevel != level )
      muerror () ;
      return ;
    }
    if ( curvallevel == 0 )
    scandimen ( mu , false , true ) ;
    else if ( level == 3 )
    muerror () ;
  }
  else {

    backinput () ;
    scandimen ( mu , false , false ) ;
    if ( negative )
    curval = - (integer) curval ;
  }
  q = newspec ( 0 ) ;
  mem [ q + 1 ] .cint = curval ;
  if ( scankeyword ( 727 ) )
  {
    scandimen ( mu , true , false ) ;
    mem [ q + 2 ] .cint = curval ;
    mem [ q ] .hh.b0 = curorder ;
  }
  if ( scankeyword ( 728 ) )
  {
    scandimen ( mu , true , false ) ;
    mem [ q + 3 ] .cint = curval ;
    mem [ q ] .hh.b1 = curorder ;
  }
  curval = q ;
}
halfword scanrulespec ( )
{/* 21 */ register halfword Result; scanrulespec_regmem
  halfword q  ;
  q = newrule () ;
  if ( curcmd == 35 )
  mem [ q + 1 ] .cint = 26214 ;
  else {

    mem [ q + 3 ] .cint = 26214 ;
    mem [ q + 2 ] .cint = 0 ;
  }
  lab21: if ( scankeyword ( 729 ) )
  {
    scandimen ( false , false , false ) ;
    mem [ q + 1 ] .cint = curval ;
    goto lab21 ;
  }
  if ( scankeyword ( 730 ) )
  {
    scandimen ( false , false , false ) ;
    mem [ q + 3 ] .cint = curval ;
    goto lab21 ;
  }
  if ( scankeyword ( 731 ) )
  {
    scandimen ( false , false , false ) ;
    mem [ q + 2 ] .cint = curval ;
    goto lab21 ;
  }
  Result = q ;
  return(Result) ;
}
halfword zstrtoks ( b )
poolpointer b ;
{register halfword Result; strtoks_regmem
  halfword p  ;
  halfword q  ;
  halfword t  ;
  poolpointer k  ;
  {
    if ( poolptr + 1 > poolsize )
    overflow ( 257 , poolsize - initpoolptr ) ;
  }
  p = memtop - 3 ;
  mem [ p ] .hh .v.RH = 0 ;
  k = b ;
  while ( k < poolptr ) {

    t = strpool [ k ] ;
    if ( t == 32 )
    t = 2592 ;
    else t = 3072 + t ;
    {
      {
	q = avail ;
	if ( q == 0 )
	q = getavail () ;
	else {

	  avail = mem [ q ] .hh .v.RH ;
	  mem [ q ] .hh .v.RH = 0 ;
	;
#ifdef STAT
	  incr ( dynused ) ;
#endif /* STAT */
	}
      }
      mem [ p ] .hh .v.RH = q ;
      mem [ q ] .hh .v.LH = t ;
      p = q ;
    }
    incr ( k ) ;
  }
  poolptr = b ;
  Result = p ;
  return(Result) ;
}
halfword thetoks ( )
{register halfword Result; thetoks_regmem
  char oldsetting  ;
  halfword p, q, r  ;
  poolpointer b  ;
  getxtoken () ;
  scansomethinginternal ( 5 , false ) ;
  if ( curvallevel >= 4 )
  {
    p = memtop - 3 ;
    mem [ p ] .hh .v.RH = 0 ;
    if ( curvallevel == 4 )
    {
      q = getavail () ;
      mem [ p ] .hh .v.RH = q ;
      mem [ q ] .hh .v.LH = 4095 + curval ;
      p = q ;
    }
    else if ( curval != 0 )
    {
      r = mem [ curval ] .hh .v.RH ;
      while ( r != 0 ) {

	{
	  {
	    q = avail ;
	    if ( q == 0 )
	    q = getavail () ;
	    else {

	      avail = mem [ q ] .hh .v.RH ;
	      mem [ q ] .hh .v.RH = 0 ;
	;
#ifdef STAT
	      incr ( dynused ) ;
#endif /* STAT */
	    }
	  }
	  mem [ p ] .hh .v.RH = q ;
	  mem [ q ] .hh .v.LH = mem [ r ] .hh .v.LH ;
	  p = q ;
	}
	r = mem [ r ] .hh .v.RH ;
      }
    }
    Result = p ;
  }
  else {

    oldsetting = selector ;
    selector = 21 ;
    b = poolptr ;
    switch ( curvallevel )
    {case 0 :
      printint ( curval ) ;
      break ;
    case 1 :
      {
	printscaled ( curval ) ;
	print ( 394 ) ;
      }
      break ;
    case 2 :
      {
	printspec ( curval , 394 ) ;
	deleteglueref ( curval ) ;
      }
      break ;
    case 3 :
      {
	printspec ( curval , 334 ) ;
	deleteglueref ( curval ) ;
      }
      break ;
    }
    selector = oldsetting ;
    Result = strtoks ( b ) ;
  }
  return(Result) ;
}
void insthetoks ( )
{insthetoks_regmem
  mem [ memtop - 12 ] .hh .v.RH = thetoks () ;
  begintokenlist ( mem [ memtop - 3 ] .hh .v.RH , 4 ) ;
}
void convtoks ( )
{convtoks_regmem
  char oldsetting  ;
  char c  ;
  smallnumber savescannerstatus  ;
  poolpointer b  ;
  c = curchr ;
  switch ( c )
  {case 0 :
  case 1 :
    scanint () ;
    break ;
  case 2 :
  case 3 :
    {
      savescannerstatus = scannerstatus ;
      scannerstatus = 0 ;
      gettoken () ;
      scannerstatus = savescannerstatus ;
    }
    break ;
  case 4 :
    scanfontident () ;
    break ;
  case 5 :
    if ( jobname == 0 )
    openlogfile () ;
    break ;
  }
  oldsetting = selector ;
  selector = 21 ;
  b = poolptr ;
  switch ( c )
  {case 0 :
    printint ( curval ) ;
    break ;
  case 1 :
    printromanint ( curval ) ;
    break ;
  case 2 :
    if ( curcs != 0 )
    sprintcs ( curcs ) ;
    else printchar ( curchr ) ;
    break ;
  case 3 :
    printmeaning () ;
    break ;
  case 4 :
    {
      print ( fontname [ curval ] ) ;
      if ( fontsize [ curval ] != fontdsize [ curval ] )
      {
	print ( 738 ) ;
	printscaled ( fontsize [ curval ] ) ;
	print ( 394 ) ;
      }
    }
    break ;
  case 5 :
    print ( jobname ) ;
    break ;
  }
  selector = oldsetting ;
  mem [ memtop - 12 ] .hh .v.RH = strtoks ( b ) ;
  begintokenlist ( mem [ memtop - 3 ] .hh .v.RH , 4 ) ;
}
halfword zscantoks ( macrodef , xpand )
boolean macrodef ;
boolean xpand ;
{/* 40 30 31 32 */ register halfword Result; scantoks_regmem
  halfword t  ;
  halfword s  ;
  halfword p  ;
  halfword q  ;
  halfword unbalance  ;
  halfword hashbrace  ;
  if ( macrodef )
  scannerstatus = 2 ;
  else scannerstatus = 5 ;
  warningindex = curcs ;
  defref = getavail () ;
  mem [ defref ] .hh .v.LH = 0 ;
  p = defref ;
  hashbrace = 0 ;
  t = 3120 ;
  if ( macrodef )
  {
    while ( true ) {

      gettoken () ;
      if ( curtok < 768 )
      goto lab31 ;
      if ( curcmd == 6 )
      {
	s = 3328 + curchr ;
	gettoken () ;
	if ( curcmd == 1 )
	{
	  hashbrace = curtok ;
	  {
	    q = getavail () ;
	    mem [ p ] .hh .v.RH = q ;
	    mem [ q ] .hh .v.LH = curtok ;
	    p = q ;
	  }
	  {
	    q = getavail () ;
	    mem [ p ] .hh .v.RH = q ;
	    mem [ q ] .hh .v.LH = 3584 ;
	    p = q ;
	  }
	  goto lab30 ;
	}
	if ( t == 3129 )
	{
	  {
	    if ( interaction == 3 )
	    ;
	    printnl ( 262 ) ;
	    print ( 741 ) ;
	  }
	  {
	    helpptr = 1 ;
	    helpline [ 0 ] = 742 ;
	  }
	  error () ;
	}
	else {

	  incr ( t ) ;
	  if ( curtok != t )
	  {
	    {
	      if ( interaction == 3 )
	      ;
	      printnl ( 262 ) ;
	      print ( 743 ) ;
	    }
	    {
	      helpptr = 2 ;
	      helpline [ 1 ] = 744 ;
	      helpline [ 0 ] = 745 ;
	    }
	    backerror () ;
	  }
	  curtok = s ;
	}
      }
      {
	q = getavail () ;
	mem [ p ] .hh .v.RH = q ;
	mem [ q ] .hh .v.LH = curtok ;
	p = q ;
      }
    }
    lab31: {

      q = getavail () ;
      mem [ p ] .hh .v.RH = q ;
      mem [ q ] .hh .v.LH = 3584 ;
      p = q ;
    }
    if ( curcmd == 2 )
    {
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 654 ) ;
      }
      incr ( alignstate ) ;
      {
	helpptr = 2 ;
	helpline [ 1 ] = 739 ;
	helpline [ 0 ] = 740 ;
      }
      error () ;
      goto lab40 ;
    }
    lab30: ;
  }
  else scanleftbrace () ;
  unbalance = 1 ;
  while ( true ) {

    if ( xpand )
    {
      while ( true ) {

	getnext () ;
	if ( curcmd <= 100 )
	goto lab32 ;
	if ( curcmd != 109 )
	expand () ;
	else {

	  q = thetoks () ;
	  if ( mem [ memtop - 3 ] .hh .v.RH != 0 )
	  {
	    mem [ p ] .hh .v.RH = mem [ memtop - 3 ] .hh .v.RH ;
	    p = q ;
	  }
	}
      }
      lab32: xtoken () ;
    }
    else gettoken () ;
    if ( curtok < 768 )
    if ( curcmd < 2 )
    incr ( unbalance ) ;
    else {

      decr ( unbalance ) ;
      if ( unbalance == 0 )
      goto lab40 ;
    }
    else if ( curcmd == 6 )
    if ( macrodef )
    {
      s = curtok ;
      if ( xpand )
      getxtoken () ;
      else gettoken () ;
      if ( curcmd != 6 )
      if ( ( curtok <= 3120 ) || ( curtok > t ) )
      {
	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 746 ) ;
	}
	sprintcs ( warningindex ) ;
	{
	  helpptr = 3 ;
	  helpline [ 2 ] = 747 ;
	  helpline [ 1 ] = 748 ;
	  helpline [ 0 ] = 749 ;
	}
	backerror () ;
	curtok = s ;
      }
      else curtok = 1232 + curchr ;
    }
    {
      q = getavail () ;
      mem [ p ] .hh .v.RH = q ;
      mem [ q ] .hh .v.LH = curtok ;
      p = q ;
    }
  }
  lab40: scannerstatus = 0 ;
  if ( hashbrace != 0 )
  {
    q = getavail () ;
    mem [ p ] .hh .v.RH = q ;
    mem [ q ] .hh .v.LH = hashbrace ;
    p = q ;
  }
  Result = p ;
  return(Result) ;
}
void zreadtoks ( n , r )
integer n ;
halfword r ;
{/* 30 */ readtoks_regmem
  halfword p  ;
  halfword q  ;
  integer s  ;
  smallnumber m  ;
  scannerstatus = 2 ;
  warningindex = r ;
  defref = getavail () ;
  mem [ defref ] .hh .v.LH = 0 ;
  p = defref ;
  {
    q = getavail () ;
    mem [ p ] .hh .v.RH = q ;
    mem [ q ] .hh .v.LH = 3584 ;
    p = q ;
  }
  if ( ( n < 0 ) || ( n > 15 ) )
  m = 16 ;
  else m = n ;
  s = alignstate ;
  alignstate = 1000000L ;
  do {
      beginfilereading () ;
    curinput .namefield = m + 1 ;
    if ( readopen [ m ] == 2 )
    if ( interaction > 1 )
    if ( n < 0 )
    {
      ;
      print ( 335 ) ;
      terminput () ;
    }
    else {

      ;
      println () ;
      sprintcs ( r ) ;
      {
	;
	print ( 61 ) ;
	terminput () ;
      }
      n = -1 ;
    }
    else fatalerror ( 750 ) ;
    else if ( readopen [ m ] == 1 )
    if ( inputln ( readfile [ m ] , false ) )
    readopen [ m ] = 0 ;
    else {

      aclose ( readfile [ m ] ) ;
      readopen [ m ] = 2 ;
    }
    else {

      if ( ! inputln ( readfile [ m ] , true ) )
      {
	aclose ( readfile [ m ] ) ;
	readopen [ m ] = 2 ;
	if ( alignstate != 1000000L )
	{
	  runaway () ;
	  {
	    if ( interaction == 3 )
	    ;
	    printnl ( 262 ) ;
	    print ( 751 ) ;
	  }
	  printesc ( 531 ) ;
	  {
	    helpptr = 1 ;
	    helpline [ 0 ] = 752 ;
	  }
	  alignstate = 1000000L ;
	  error () ;
	}
      }
    }
    curinput .limitfield = last ;
    if ( ( eqtb [ 9211 ] .cint < 0 ) || ( eqtb [ 9211 ] .cint > 255 ) )
    decr ( curinput .limitfield ) ;
    else buffer [ curinput .limitfield ] = eqtb [ 9211 ] .cint ;
    first = curinput .limitfield + 1 ;
    curinput .locfield = curinput .startfield ;
    curinput .statefield = 33 ;
    while ( true ) {

      gettoken () ;
      if ( curtok == 0 )
      goto lab30 ;
      if ( alignstate < 1000000L )
      {
	do {
	    gettoken () ;
	} while ( ! ( curtok == 0 ) ) ;
	alignstate = 1000000L ;
	goto lab30 ;
      }
      {
	q = getavail () ;
	mem [ p ] .hh .v.RH = q ;
	mem [ q ] .hh .v.LH = curtok ;
	p = q ;
      }
    }
    lab30: endfilereading () ;
  } while ( ! ( alignstate == 1000000L ) ) ;
  curval = defref ;
  scannerstatus = 0 ;
  alignstate = s ;
}
void passtext ( )
{/* 30 */ passtext_regmem
  integer l  ;
  smallnumber savescannerstatus  ;
  savescannerstatus = scannerstatus ;
  scannerstatus = 1 ;
  l = 0 ;
  skipline = line ;
  while ( true ) {

    getnext () ;
    if ( curcmd == 106 )
    {
      if ( l == 0 )
      goto lab30 ;
      if ( curchr == 2 )
      decr ( l ) ;
    }
    else if ( curcmd == 105 )
    incr ( l ) ;
  }
  lab30: scannerstatus = savescannerstatus ;
}
void zchangeiflimit ( l , p )
smallnumber l ;
halfword p ;
{/* 10 */ changeiflimit_regmem
  halfword q  ;
  if ( p == condptr )
  iflimit = l ;
  else {

    q = condptr ;
    while ( true ) {

      if ( q == 0 )
      confusion ( 753 ) ;
      if ( mem [ q ] .hh .v.RH == p )
      {
	mem [ q ] .hh.b0 = l ;
	return ;
      }
      q = mem [ q ] .hh .v.RH ;
    }
  }
}
void conditional ( )
{/* 10 50 */ conditional_regmem
  boolean b  ;
  char r  ;
  integer m, n  ;
  halfword p, q  ;
  smallnumber savescannerstatus  ;
  halfword savecondptr  ;
  smallnumber thisif  ;
  {
    p = getnode ( 2 ) ;
    mem [ p ] .hh .v.RH = condptr ;
    mem [ p ] .hh.b0 = iflimit ;
    mem [ p ] .hh.b1 = curif ;
    mem [ p + 1 ] .cint = ifline ;
    condptr = p ;
    curif = curchr ;
    iflimit = 1 ;
    ifline = line ;
  }
  savecondptr = condptr ;
  thisif = curchr ;
  switch ( thisif )
  {case 0 :
  case 1 :
    {
      {
	getxtoken () ;
	if ( curcmd == 0 )
	if ( curchr == 257 )
	{
	  curcmd = 13 ;
	  curchr = curtok - 4096 ;
	}
      }
      if ( ( curcmd > 13 ) || ( curchr > 255 ) )
      {
	m = 0 ;
	n = 256 ;
      }
      else {

	m = curcmd ;
	n = curchr ;
      }
      {
	getxtoken () ;
	if ( curcmd == 0 )
	if ( curchr == 257 )
	{
	  curcmd = 13 ;
	  curchr = curtok - 4096 ;
	}
      }
      if ( ( curcmd > 13 ) || ( curchr > 255 ) )
      {
	curcmd = 0 ;
	curchr = 256 ;
      }
      if ( thisif == 0 )
      b = ( n == curchr ) ;
      else b = ( m == curcmd ) ;
    }
    break ;
  case 2 :
  case 3 :
    {
      if ( thisif == 2 )
      scanint () ;
      else scandimen ( false , false , false ) ;
      n = curval ;
      do {
	  getxtoken () ;
      } while ( ! ( curcmd != 10 ) ) ;
      if ( ( curtok >= 3132 ) && ( curtok <= 3134 ) )
      r = curtok - 3072 ;
      else {

	{
	  if ( interaction == 3 )
	  ;
	  printnl ( 262 ) ;
	  print ( 777 ) ;
	}
	printcmdchr ( 105 , thisif ) ;
	{
	  helpptr = 1 ;
	  helpline [ 0 ] = 778 ;
	}
	backerror () ;
	r = 61 ;
      }
      if ( thisif == 2 )
      scanint () ;
      else scandimen ( false , false , false ) ;
      switch ( r )
      {case 60 :
	b = ( n < curval ) ;
	break ;
      case 61 :
	b = ( n == curval ) ;
	break ;
      case 62 :
	b = ( n > curval ) ;
	break ;
      }
    }
    break ;
  case 4 :
    {
      scanint () ;
      b = odd ( curval ) ;
    }
    break ;
  case 5 :
    b = ( abs ( curlist .modefield ) == 1 ) ;
    break ;
  case 6 :
    b = ( abs ( curlist .modefield ) == 102 ) ;
    break ;
  case 7 :
    b = ( abs ( curlist .modefield ) == 203 ) ;
    break ;
  case 8 :
    b = ( curlist .modefield < 0 ) ;
    break ;
  case 9 :
  case 10 :
  case 11 :
    {
      scaneightbitint () ;
      p = eqtb [ 7578 + curval ] .hh .v.RH ;
      if ( thisif == 9 )
      b = ( p == 0 ) ;
      else if ( p == 0 )
      b = false ;
      else if ( thisif == 10 )
      b = ( mem [ p ] .hh.b0 == 0 ) ;
      else b = ( mem [ p ] .hh.b0 == 1 ) ;
    }
    break ;
  case 12 :
    {
      savescannerstatus = scannerstatus ;
      scannerstatus = 0 ;
      getnext () ;
      n = curcs ;
      p = curcmd ;
      q = curchr ;
      getnext () ;
      if ( curcmd != p )
      b = false ;
      else if ( curcmd < 111 )
      b = ( curchr == q ) ;
      else {

	p = mem [ curchr ] .hh .v.RH ;
	q = mem [ eqtb [ n ] .hh .v.RH ] .hh .v.RH ;
	if ( p == q )
	b = true ;
	else {

	  while ( ( p != 0 ) && ( q != 0 ) ) if ( mem [ p ] .hh .v.LH != mem [
	  q ] .hh .v.LH )
	  p = 0 ;
	  else {

	    p = mem [ p ] .hh .v.RH ;
	    q = mem [ q ] .hh .v.RH ;
	  }
	  b = ( ( p == 0 ) && ( q == 0 ) ) ;
	}
      }
      scannerstatus = savescannerstatus ;
    }
    break ;
  case 13 :
    {
      scanfourbitint () ;
      b = ( readopen [ curval ] == 2 ) ;
    }
    break ;
  case 14 :
    b = true ;
    break ;
  case 15 :
    b = false ;
    break ;
  case 16 :
    {
      scanint () ;
      n = curval ;
      if ( eqtb [ 9199 ] .cint > 1 )
      {
	begindiagnostic () ;
	print ( 779 ) ;
	printint ( n ) ;
	printchar ( 125 ) ;
	enddiagnostic ( false ) ;
      }
      while ( n != 0 ) {

	passtext () ;
	if ( condptr == savecondptr )
	if ( curchr == 4 )
	decr ( n ) ;
	else goto lab50 ;
	else if ( curchr == 2 )
	{
	  p = condptr ;
	  ifline = mem [ p + 1 ] .cint ;
	  curif = mem [ p ] .hh.b1 ;
	  iflimit = mem [ p ] .hh.b0 ;
	  condptr = mem [ p ] .hh .v.RH ;
	  freenode ( p , 2 ) ;
	}
      }
      changeiflimit ( 4 , savecondptr ) ;
      return ;
    }
    break ;
  }
  if ( eqtb [ 9199 ] .cint > 1 )
  {
    begindiagnostic () ;
    if ( b )
    print ( 775 ) ;
    else print ( 776 ) ;
    enddiagnostic ( false ) ;
  }
  if ( b )
  {
    changeiflimit ( 3 , savecondptr ) ;
    return ;
  }
  while ( true ) {

    passtext () ;
    if ( condptr == savecondptr )
    {
      if ( curchr != 4 )
      goto lab50 ;
      {
	if ( interaction == 3 )
	;
	printnl ( 262 ) ;
	print ( 773 ) ;
      }
      printesc ( 771 ) ;
      {
	helpptr = 1 ;
	helpline [ 0 ] = 774 ;
      }
      error () ;
    }
    else if ( curchr == 2 )
    {
      p = condptr ;
      ifline = mem [ p + 1 ] .cint ;
      curif = mem [ p ] .hh.b1 ;
      iflimit = mem [ p ] .hh.b0 ;
      condptr = mem [ p ] .hh .v.RH ;
      freenode ( p , 2 ) ;
    }
  }
  lab50: if ( curchr == 2 )
  {
    p = condptr ;
    ifline = mem [ p + 1 ] .cint ;
    curif = mem [ p ] .hh.b1 ;
    iflimit = mem [ p ] .hh.b0 ;
    condptr = mem [ p ] .hh .v.RH ;
    freenode ( p , 2 ) ;
  }
  else iflimit = 2 ;
}
void beginname ( )
{beginname_regmem
  areadelimiter = 0 ;
  extdelimiter = 0 ;
}
boolean zmorename ( c )
ASCIIcode c ;
{register boolean Result; morename_regmem
  if ( c == 32 )
  Result = false ;
  else {

    {
      if ( poolptr + 1 > poolsize )
      overflow ( 257 , poolsize - initpoolptr ) ;
    }
    {
      strpool [ poolptr ] = c ;
      incr ( poolptr ) ;
    }
    if ( ( c == 46 ) || ( ( c == 47 ) && ( jobname == 0 ) ) )
    {
      extdelimiter = ( poolptr - strstart [ strptr ] ) ;
    }
    Result = true ;
  }
  return(Result) ;
}
void endname ( )
{endname_regmem
  if ( strptr + 3 > maxstrings )
  overflow ( 258 , maxstrings - initstrptr ) ;
  if ( areadelimiter == 0 )
  curarea = 335 ;
  else {

    curarea = strptr ;
    strstart [ strptr + 1 ] = strstart [ strptr ] + areadelimiter ;
    incr ( strptr ) ;
  }
  if ( extdelimiter == 0 )
  {
    curext = 335 ;
    curname = makestring () ;
  }
  else {

    curname = strptr ;
    strstart [ strptr + 1 ] = strstart [ strptr ] + extdelimiter -
    areadelimiter - 1 ;
    incr ( strptr ) ;
    curext = makestring () ;
  }
}
void zpackfilename ( n , a , e )
strnumber n ;
strnumber a ;
strnumber e ;
{packfilename_regmem
  integer k  ;
  ASCIIcode c  ;
  poolpointer j  ;
  k = 0 ;
  {register integer for_end; j = strstart [ a ] ; for_end = strstart [ a + 1
  ] - 1 ; if ( j <= for_end) do
    {
      c = strpool [ j ] ;
      incr ( k ) ;
      if ( k <= PATHMAX )
      nameoffile [ k ] = xchr [ c ] ;
    }
  while ( j++ < for_end ) ; }
  {register integer for_end; j = strstart [ n ] ; for_end = strstart [ n + 1
  ] - 1 ; if ( j <= for_end) do
    {
      c = strpool [ j ] ;
      incr ( k ) ;
      if ( k <= PATHMAX )
      nameoffile [ k ] = xchr [ c ] ;
    }
  while ( j++ < for_end ) ; }
  {register integer for_end; j = strstart [ e ] ; for_end = strstart [ e + 1
  ] - 1 ; if ( j <= for_end) do
    {
      c = strpool [ j ] ;
      incr ( k ) ;
      if ( k <= PATHMAX )
      nameoffile [ k ] = xchr [ c ] ;
    }
  while ( j++ < for_end ) ; }
  if ( k < PATHMAX )
  namelength = k ;
  else namelength = PATHMAX - 1 ;
  {register integer for_end; k = namelength + 1 ; for_end = PATHMAX ; if ( k
  <= for_end) do
    nameoffile [ k ] = ' ' ;
  while ( k++ < for_end ) ; }
}
void zpackbufferedname ( n , a , b )
smallnumber n ;
integer a ;
integer b ;
{packbufferedname_regmem
  integer k  ;
  ASCIIcode c  ;
  integer j  ;
  if ( n + b - a + 5 > PATHMAX )
  b = a + PATHMAX - n - 5 ;
  k = 0 ;
  {register integer for_end; j = 1 ; for_end = n ; if ( j <= for_end) do
    {
      c = xord [ TEXformatdefault [ j ] ] ;
      incr ( k ) ;
      if ( k <= PATHMAX )
      nameoffile [ k ] = xchr [ c ] ;
    }
  while ( j++ < for_end ) ; }
  {register integer for_end; j = a ; for_end = b ; if ( j <= for_end) do
    {
      c = buffer [ j ] ;
      incr ( k ) ;
      if ( k <= PATHMAX )
      nameoffile [ k ] = xchr [ c ] ;
    }
  while ( j++ < for_end ) ; }
  {register integer for_end; j = formatdefaultlength - 3 ; for_end =
  formatdefaultlength ; if ( j <= for_end) do
    {
      c = xord [ TEXformatdefault [ j ] ] ;
      incr ( k ) ;
      if ( k <= PATHMAX )
      nameoffile [ k ] = xchr [ c ] ;
    }
  while ( j++ < for_end ) ; }
  if ( k < PATHMAX )
  namelength = k ;
  else namelength = PATHMAX - 1 ;
  {register integer for_end; k = namelength + 1 ; for_end = PATHMAX ; if ( k
  <= for_end) do
    nameoffile [ k ] = ' ' ;
  while ( k++ < for_end ) ; }
}
strnumber makenamestring ( )
{register strnumber Result; makenamestring_regmem
  integer k  ;
  if ( ( poolptr + namelength > poolsize ) || ( strptr == maxstrings ) || ( (
  poolptr - strstart [ strptr ] ) > 0 ) )
  Result = 63 ;
  else {

    {register integer for_end; k = 1 ; for_end = namelength ; if ( k <=
    for_end) do
      {
	strpool [ poolptr ] = xord [ nameoffile [ k ] ] ;
	incr ( poolptr ) ;
      }
    while ( k++ < for_end ) ; }
    Result = makestring () ;
  }
  return(Result) ;
}
strnumber zamakenamestring ( f )
alphafile * f ;
{register strnumber Result; amakenamestring_regmem
  Result = makenamestring () ;
  return(Result) ;
}
strnumber zbmakenamestring ( f )
bytefile * f ;
{register strnumber Result; bmakenamestring_regmem
  Result = makenamestring () ;
  return(Result) ;
}
strnumber zwmakenamestring ( f )
wordfile * f ;
{register strnumber Result; wmakenamestring_regmem
  Result = makenamestring () ;
  return(Result) ;
}
void scanfilename ( )
{/* 30 */ scanfilename_regmem
  nameinprogress = true ;
  beginname () ;
  do {
      getxtoken () ;
  } while ( ! ( curcmd != 10 ) ) ;
  while ( true ) {

    if ( ( curcmd > 12 ) || ( curchr > 255 ) )
    {
      backinput () ;
      goto lab30 ;
    }
    if ( ! morename ( curchr ) )
    goto lab30 ;
    getxtoken () ;
  }
  lab30: endname () ;
  nameinprogress = false ;
}
void zpackjobname ( s )
strnumber s ;
{packjobname_regmem
  curarea = 335 ;
  curext = s ;
  curname = jobname ;
  packfilename ( curname , curarea , curext ) ;
}
void zpromptfilename ( s , e )
strnumber s ;
strnumber e ;
{/* 30 */ promptfilename_regmem
  integer k  ;
  if ( interaction == 2 )
  ;
  if ( s == 781 )
  {
    if ( interaction == 3 )
    ;
    printnl ( 262 ) ;
    print ( 782 ) ;
  }
  else {

    if ( interaction == 3 )
    ;
    printnl ( 262 ) ;
    print ( 783 ) ;
  }
  printfilename ( curname , curarea , curext ) ;
  print ( 784 ) ;
  if ( e == 785 )
  showcontext () ;
  printnl ( 786 ) ;
  print ( s ) ;
  if ( interaction < 2 )
  fatalerror ( 787 ) ;
  {
    ;
    print ( 565 ) ;
    terminput () ;
  }
  {
    beginname () ;
    k = first ;
    while ( ( buffer [ k ] == 32 ) && ( k < last ) ) incr ( k ) ;
    while ( true ) {

      if ( k == last )
      goto lab30 ;
      if ( ! morename ( buffer [ k ] ) )
      goto lab30 ;
      incr ( k ) ;
    }
    lab30: endname () ;
  }
  if ( curext == 335 )
  curext = e ;
  packfilename ( curname , curarea , curext ) ;
}
void openlogfile ( )
{openlogfile_regmem
  char oldsetting  ;
  integer k  ;
  integer l  ;
  ccharpointer months  ;
  oldsetting = selector ;
  if ( jobname == 0 )
  jobname = 790 ;
  packjobname ( 791 ) ;
  while ( ! aopenout ( logfile ) ) {

    selector = 17 ;
    promptfilename ( 793 , 791 ) ;
  }
  riscossetname ( nameoffile ) ;
  texmflogname = amakenamestring ( logfile ) ;
  selector = 18 ;
  logopened = true ;
  {
    Fputs( logfile ,  "This is small armTeX 3.14159" ) ;
    Fputs( logfile ,  versionstring ) ;
    slowprint ( formatident ) ;
    print ( 794 ) ;
    printint ( eqtb [ 9184 ] .cint ) ;
    printchar ( 32 ) ;
    months = " JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC" ;
    {register integer for_end; k = 3 * eqtb [ 9185 ] .cint - 2 ; for_end = 3
    * eqtb [ 9185 ] .cint ; if ( k <= for_end) do
      putc ( months [ k ] ,  logfile );
    while ( k++ < for_end ) ; }
    printchar ( 32 ) ;
    printint ( eqtb [ 9186 ] .cint ) ;
    printchar ( 32 ) ;
    printtwo ( eqtb [ 9183 ] .cint / 60 ) ;
    printchar ( 58 ) ;
    printtwo ( eqtb [ 9183 ] .cint % 60 ) ;
  }
  inputstack [ inputptr ] = curinput ;
  printnl ( 792 ) ;
  l = inputstack [ 0 ] .limitfield ;
  if ( buffer [ l ] == eqtb [ 9211 ] .cint )
  decr ( l ) ;
  {register integer for_end; k = 1 ; for_end = l ; if ( k <= for_end) do
    print ( buffer [ k ] ) ;
  while ( k++ < for_end ) ; }
  println () ;
  selector = oldsetting + 2 ;
}
void startinput ( )
{/* 30 */ startinput_regmem
  scanfilename () ;
  if ( riscosoutputmode < 0 )
  riscosoutputmode = -1 ;
  packfilename ( curname , curarea , curext ) ;
  while ( true ) {

    beginfilereading () ;
    if ( curext != 335 && aopenin ( inputfile [ curinput .indexfield ] ,
    TEXINPUTPATH ) )
    goto lab30 ;
    if ( ( curext != 785 ) && ( namelength + 5 < PATHMAX ) )
    {
      nameoffile [ namelength + 1 ] = 46 ;
      nameoffile [ namelength + 2 ] = 116 ;
      nameoffile [ namelength + 3 ] = 101 ;
      nameoffile [ namelength + 4 ] = 120 ;
      namelength = namelength + 4 ;
      if ( aopenin ( inputfile [ curinput .indexfield ] , TEXINPUTPATH ) )
      {
	if ( curext == curname + 1 )
	strstart [ curext ] = strstart [ curext + 1 ] ;
	curext = 785 ;
	goto lab30 ;
      }
      namelength = namelength - 4 ;
      nameoffile [ namelength + 1 ] = 32 ;
    }
    if ( curext == 335 )
    {
      curext = 785 ;
      packfilename ( curname , curarea , curext ) ;
    }
    if ( maketextex () )
    {
      if ( aopenin ( inputfile [ curinput .indexfield ] , TEXINPUTPATH ) )
      goto lab30 ;
    }
    endfilereading () ;
    promptfilename ( 781 , 785 ) ;
  }
  lab30: curinput .namefield = amakenamestring ( inputfile [ curinput
  .indexfield ] ) ;
  if ( jobname == 0 )
  {
    jobname = curname ;
    openlogfile () ;
  }
  if ( termoffset + ( strstart [ curinput .namefield + 1 ] - strstart [
  curinput .namefield ] ) > maxprintline - 2 )
  println () ;
  else if ( ( termoffset > 0 ) || ( fileoffset > 0 ) )
  printchar ( 32 ) ;
  printchar ( 40 ) ;
  incr ( openparens ) ;
  slowprint ( curinput .namefield ) ;
  flush ( stdout ) ;
  curinput .statefield = 33 ;
  {
    line = 1 ;
    if ( inputln ( inputfile [ curinput .indexfield ] , false ) )
    ;
    firmuptheline () ;
    if ( ( eqtb [ 9211 ] .cint < 0 ) || ( eqtb [ 9211 ] .cint > 255 ) )
    decr ( curinput .limitfield ) ;
    else buffer [ curinput .limitfield ] = eqtb [ 9211 ] .cint ;
    first = curinput .limitfield + 1 ;
    curinput .locfield = curinput .startfield ;
  }
}
internalfontnumber zreadfontinfo ( u , nom , aire , s )
halfword u ;
strnumber nom ;
strnumber aire ;
scaled s ;
{/* 30 11 45 */ register internalfontnumber Result; readfontinfo_regmem
  fontindex k  ;
  boolean fileopened  ;
  halfword lf, lh, bc, ec, nw, nh, nd, ni, nl, nk, ne, np  ;
  internalfontnumber f  ;
  internalfontnumber g  ;
  eightbits a, b, c, d  ;
  fourquarters qw  ;
  scaled sw  ;
  integer bchlabel  ;
  integer bchar  ;
  scaled z  ;
  integer alpha  ;
  char beta  ;
  g = 0 ;
  fileopened = false ;
  packfilename ( nom , aire , 805 ) ;
  if ( ! bopenin ( tfmfile ) )
  {
    if ( maketextfm () )
    {
      if ( ! bopenin ( tfmfile ) )
      goto lab11 ;
    }
    else goto lab11 ;
  }
  fileopened = true ;
  {
    {
      lf = tfmtemp ;
      if ( lf > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      lf = lf * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      lh = tfmtemp ;
      if ( lh > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      lh = lh * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      bc = tfmtemp ;
      if ( bc > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      bc = bc * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      ec = tfmtemp ;
      if ( ec > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      ec = ec * 256 + tfmtemp ;
    }
    if ( ( bc > ec + 1 ) || ( ec > 255 ) )
    goto lab11 ;
    if ( bc > 255 )
    {
      bc = 1 ;
      ec = 0 ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      nw = tfmtemp ;
      if ( nw > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      nw = nw * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      nh = tfmtemp ;
      if ( nh > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      nh = nh * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      nd = tfmtemp ;
      if ( nd > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      nd = nd * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      ni = tfmtemp ;
      if ( ni > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      ni = ni * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      nl = tfmtemp ;
      if ( nl > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      nl = nl * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      nk = tfmtemp ;
      if ( nk > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      nk = nk * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      ne = tfmtemp ;
      if ( ne > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      ne = ne * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      np = tfmtemp ;
      if ( np > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      np = np * 256 + tfmtemp ;
    }
    if ( lf != 6 + lh + ( ec - bc + 1 ) + nw + nh + nd + ni + nl + nk + ne +
    np )
    goto lab11 ;
  }
  lf = lf - 6 - lh ;
  if ( np < 7 )
  lf = lf + 7 - np ;
  if ( ( fontptr == fontmax ) || ( fmemptr + lf > fontmemsize ) )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 796 ) ;
    }
    sprintcs ( u ) ;
    printchar ( 61 ) ;
    printfilename ( nom , aire , 335 ) ;
    if ( s >= 0 )
    {
      print ( 738 ) ;
      printscaled ( s ) ;
      print ( 394 ) ;
    }
    else if ( s != -1000 )
    {
      print ( 797 ) ;
      printint ( - (integer) s ) ;
    }
    print ( 806 ) ;
    {
      helpptr = 4 ;
      helpline [ 3 ] = 807 ;
      helpline [ 2 ] = 808 ;
      helpline [ 1 ] = 809 ;
      helpline [ 0 ] = 810 ;
    }
    error () ;
    goto lab30 ;
  }
  f = fontptr + 1 ;
  charbase [ f ] = fmemptr - bc ;
  widthbase [ f ] = charbase [ f ] + ec + 1 ;
  heightbase [ f ] = widthbase [ f ] + nw ;
  depthbase [ f ] = heightbase [ f ] + nh ;
  italicbase [ f ] = depthbase [ f ] + nd ;
  ligkernbase [ f ] = italicbase [ f ] + ni ;
  kernbase [ f ] = ligkernbase [ f ] + nl - 256 * ( 128 ) ;
  extenbase [ f ] = kernbase [ f ] + 256 * ( 128 ) + nk ;
  parambase [ f ] = extenbase [ f ] + ne ;
  {
    if ( lh < 2 )
    goto lab11 ;
    {
      tfmtemp = getc ( tfmfile ) ;
      a = tfmtemp ;
      qw .b0 = a ;
      tfmtemp = getc ( tfmfile ) ;
      b = tfmtemp ;
      qw .b1 = b ;
      tfmtemp = getc ( tfmfile ) ;
      c = tfmtemp ;
      qw .b2 = c ;
      tfmtemp = getc ( tfmfile ) ;
      d = tfmtemp ;
      qw .b3 = d ;
      fontcheck [ f ] = qw ;
    }
    tfmtemp = getc ( tfmfile ) ;
    {
      z = tfmtemp ;
      if ( z > 127 )
      goto lab11 ;
      tfmtemp = getc ( tfmfile ) ;
      z = z * 256 + tfmtemp ;
    }
    tfmtemp = getc ( tfmfile ) ;
    z = z * 256 + tfmtemp ;
    tfmtemp = getc ( tfmfile ) ;
    z = ( z * 16 ) + ( tfmtemp / 16 ) ;
    if ( z < 65536L )
    goto lab11 ;
    while ( lh > 2 ) {

      tfmtemp = getc ( tfmfile ) ;
      tfmtemp = getc ( tfmfile ) ;
      tfmtemp = getc ( tfmfile ) ;
      tfmtemp = getc ( tfmfile ) ;
      decr ( lh ) ;
    }
    fontdsize [ f ] = z ;
    if ( s != -1000 )
    if ( s >= 0 )
    z = s ;
    else z = xnoverd ( z , - (integer) s , 1000 ) ;
    fontsize [ f ] = z ;
  }
  {register integer for_end; k = fmemptr ; for_end = widthbase [ f ] - 1
  ; if ( k <= for_end) do
    {
      {
	tfmtemp = getc ( tfmfile ) ;
	a = tfmtemp ;
	qw .b0 = a ;
	tfmtemp = getc ( tfmfile ) ;
	b = tfmtemp ;
	qw .b1 = b ;
	tfmtemp = getc ( tfmfile ) ;
	c = tfmtemp ;
	qw .b2 = c ;
	tfmtemp = getc ( tfmfile ) ;
	d = tfmtemp ;
	qw .b3 = d ;
	fontinfo [ k ] .qqqq = qw ;
      }
      if ( ( a >= nw ) || ( b / 16 >= nh ) || ( b % 16 >= nd ) || ( c / 4 >=
      ni ) )
      goto lab11 ;
      switch ( c % 4 )
      {case 1 :
	if ( d >= nl )
	goto lab11 ;
	break ;
      case 3 :
	if ( d >= ne )
	goto lab11 ;
	break ;
      case 2 :
	{
	  {
	    if ( ( d < bc ) || ( d > ec ) )
	    goto lab11 ;
	  }
	  while ( d < k + bc - fmemptr ) {

	    qw = fontinfo [ charbase [ f ] + d ] .qqqq ;
	    if ( ( ( qw .b2 ) % 4 ) != 2 )
	    goto lab45 ;
	    d = qw .b3 ;
	  }
	  if ( d == k + bc - fmemptr )
	  goto lab11 ;
	  lab45: ;
	}
	break ;
	default:
	;
	break ;
      }
    }
  while ( k++ < for_end ) ; }
  {
    {
      alpha = 16 ;
      while ( z >= 8388608L ) {

	z = z / 2 ;
	alpha = alpha + alpha ;
      }
      beta = 256 / alpha ;
      alpha = alpha * z ;
    }
    {register integer for_end; k = widthbase [ f ] ; for_end = ligkernbase [
    f ] - 1 ; if ( k <= for_end) do
      {
	tfmtemp = getc ( tfmfile ) ;
	a = tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	b = tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	c = tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	d = tfmtemp ;
	sw = ( ( ( ( ( d * z ) / 256 ) + ( c * z ) ) / 256 ) + ( b * z ) ) /
	beta ;
	if ( a == 0 )
	fontinfo [ k ] .cint = sw ;
	else if ( a == 255 )
	fontinfo [ k ] .cint = sw - alpha ;
	else goto lab11 ;
      }
    while ( k++ < for_end ) ; }
    if ( fontinfo [ widthbase [ f ] ] .cint != 0 )
    goto lab11 ;
    if ( fontinfo [ heightbase [ f ] ] .cint != 0 )
    goto lab11 ;
    if ( fontinfo [ depthbase [ f ] ] .cint != 0 )
    goto lab11 ;
    if ( fontinfo [ italicbase [ f ] ] .cint != 0 )
    goto lab11 ;
  }
  bchlabel = 32767 ;
  bchar = 256 ;
  if ( nl > 0 )
  {
    {register integer for_end; k = ligkernbase [ f ] ; for_end = kernbase [ f
    ] + 256 * ( 128 ) - 1 ; if ( k <= for_end) do
      {
	{
	  tfmtemp = getc ( tfmfile ) ;
	  a = tfmtemp ;
	  qw .b0 = a ;
	  tfmtemp = getc ( tfmfile ) ;
	  b = tfmtemp ;
	  qw .b1 = b ;
	  tfmtemp = getc ( tfmfile ) ;
	  c = tfmtemp ;
	  qw .b2 = c ;
	  tfmtemp = getc ( tfmfile ) ;
	  d = tfmtemp ;
	  qw .b3 = d ;
	  fontinfo [ k ] .qqqq = qw ;
	}
	if ( a > 128 )
	{
	  if ( 256 * c + d >= nl )
	  goto lab11 ;
	  if ( a == 255 )
	  if ( k == ligkernbase [ f ] )
	  bchar = b ;
	}
	else {

	  if ( b != bchar )
	  {
	    {
	      if ( ( b < bc ) || ( b > ec ) )
	      goto lab11 ;
	    }
	    qw = fontinfo [ charbase [ f ] + b ] .qqqq ;
	    if ( ! ( qw .b0 > 0 ) )
	    goto lab11 ;
	  }
	  if ( c < 128 )
	  {
	    {
	      if ( ( d < bc ) || ( d > ec ) )
	      goto lab11 ;
	    }
	    qw = fontinfo [ charbase [ f ] + d ] .qqqq ;
	    if ( ! ( qw .b0 > 0 ) )
	    goto lab11 ;
	  }
	  else if ( 256 * ( c - 128 ) + d >= nk )
	  goto lab11 ;
	  if ( a < 128 )
	  if ( k - ligkernbase [ f ] + a + 1 >= nl )
	  goto lab11 ;
	}
      }
    while ( k++ < for_end ) ; }
    if ( a == 255 )
    bchlabel = 256 * c + d ;
  }
  {register integer for_end; k = kernbase [ f ] + 256 * ( 128 ) ; for_end =
  extenbase [ f ] - 1 ; if ( k <= for_end) do
    {
      tfmtemp = getc ( tfmfile ) ;
      a = tfmtemp ;
      tfmtemp = getc ( tfmfile ) ;
      b = tfmtemp ;
      tfmtemp = getc ( tfmfile ) ;
      c = tfmtemp ;
      tfmtemp = getc ( tfmfile ) ;
      d = tfmtemp ;
      sw = ( ( ( ( ( d * z ) / 256 ) + ( c * z ) ) / 256 ) + ( b * z ) ) /
      beta ;
      if ( a == 0 )
      fontinfo [ k ] .cint = sw ;
      else if ( a == 255 )
      fontinfo [ k ] .cint = sw - alpha ;
      else goto lab11 ;
    }
  while ( k++ < for_end ) ; }
  {register integer for_end; k = extenbase [ f ] ; for_end = parambase [ f ]
  - 1 ; if ( k <= for_end) do
    {
      {
	tfmtemp = getc ( tfmfile ) ;
	a = tfmtemp ;
	qw .b0 = a ;
	tfmtemp = getc ( tfmfile ) ;
	b = tfmtemp ;
	qw .b1 = b ;
	tfmtemp = getc ( tfmfile ) ;
	c = tfmtemp ;
	qw .b2 = c ;
	tfmtemp = getc ( tfmfile ) ;
	d = tfmtemp ;
	qw .b3 = d ;
	fontinfo [ k ] .qqqq = qw ;
      }
      if ( a != 0 )
      {
	{
	  if ( ( a < bc ) || ( a > ec ) )
	  goto lab11 ;
	}
	qw = fontinfo [ charbase [ f ] + a ] .qqqq ;
	if ( ! ( qw .b0 > 0 ) )
	goto lab11 ;
      }
      if ( b != 0 )
      {
	{
	  if ( ( b < bc ) || ( b > ec ) )
	  goto lab11 ;
	}
	qw = fontinfo [ charbase [ f ] + b ] .qqqq ;
	if ( ! ( qw .b0 > 0 ) )
	goto lab11 ;
      }
      if ( c != 0 )
      {
	{
	  if ( ( c < bc ) || ( c > ec ) )
	  goto lab11 ;
	}
	qw = fontinfo [ charbase [ f ] + c ] .qqqq ;
	if ( ! ( qw .b0 > 0 ) )
	goto lab11 ;
      }
      {
	{
	  if ( ( d < bc ) || ( d > ec ) )
	  goto lab11 ;
	}
	qw = fontinfo [ charbase [ f ] + d ] .qqqq ;
	if ( ! ( qw .b0 > 0 ) )
	goto lab11 ;
      }
    }
  while ( k++ < for_end ) ; }
  {
    {register integer for_end; k = 1 ; for_end = np ; if ( k <= for_end) do
      if ( k == 1 )
      {
	tfmtemp = getc ( tfmfile ) ;
	sw = tfmtemp ;
	if ( sw > 127 )
	sw = sw - 256 ;
	tfmtemp = getc ( tfmfile ) ;
	sw = sw * 256 + tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	sw = sw * 256 + tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	fontinfo [ parambase [ f ] ] .cint = ( sw * 16 ) + ( tfmtemp / 16 ) ;
      }
      else {

	tfmtemp = getc ( tfmfile ) ;
	a = tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	b = tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	c = tfmtemp ;
	tfmtemp = getc ( tfmfile ) ;
	d = tfmtemp ;
	sw = ( ( ( ( ( d * z ) / 256 ) + ( c * z ) ) / 256 ) + ( b * z ) ) /
	beta ;
	if ( a == 0 )
	fontinfo [ parambase [ f ] + k - 1 ] .cint = sw ;
	else if ( a == 255 )
	fontinfo [ parambase [ f ] + k - 1 ] .cint = sw - alpha ;
	else goto lab11 ;
      }
    while ( k++ < for_end ) ; }
    if ( feof ( tfmfile ) )
    goto lab11 ;
    {register integer for_end; k = np + 1 ; for_end = 7 ; if ( k <= for_end)
    do
      fontinfo [ parambase [ f ] + k - 1 ] .cint = 0 ;
    while ( k++ < for_end ) ; }
  }
  if ( np >= 7 )
  fontparams [ f ] = np ;
  else fontparams [ f ] = 7 ;
  hyphenchar [ f ] = eqtb [ 9209 ] .cint ;
  skewchar [ f ] = eqtb [ 9210 ] .cint ;
  if ( bchlabel < nl )
  bcharlabel [ f ] = bchlabel + ligkernbase [ f ] ;
  else bcharlabel [ f ] = 0 ;
  fontbchar [ f ] = bchar ;
  fontfalsebchar [ f ] = bchar ;
  if ( bchar <= ec )
  if ( bchar >= bc )
  {
    qw = fontinfo [ charbase [ f ] + bchar ] .qqqq ;
    if ( ( qw .b0 > 0 ) )
    fontfalsebchar [ f ] = 256 ;
  }
  fontname [ f ] = nom ;
  fontarea [ f ] = aire ;
  fontbc [ f ] = bc ;
  fontec [ f ] = ec ;
  fontglue [ f ] = 0 ;
  charbase [ f ] = charbase [ f ] ;
  widthbase [ f ] = widthbase [ f ] ;
  ligkernbase [ f ] = ligkernbase [ f ] ;
  kernbase [ f ] = kernbase [ f ] ;
  extenbase [ f ] = extenbase [ f ] ;
  decr ( parambase [ f ] ) ;
  fmemptr = fmemptr + lf ;
  fontptr = f ;
  g = f ;
  goto lab30 ;
  lab11: {

    if ( interaction == 3 )
    ;
    printnl ( 262 ) ;
    print ( 796 ) ;
  }
  sprintcs ( u ) ;
  printchar ( 61 ) ;
  printfilename ( nom , aire , 335 ) ;
  if ( s >= 0 )
  {
    print ( 738 ) ;
    printscaled ( s ) ;
    print ( 394 ) ;
  }
  else if ( s != -1000 )
  {
    print ( 797 ) ;
    printint ( - (integer) s ) ;
  }
  if ( fileopened )
  print ( 798 ) ;
  else print ( 799 ) ;
  {
    helpptr = 5 ;
    helpline [ 4 ] = 800 ;
    helpline [ 3 ] = 801 ;
    helpline [ 2 ] = 802 ;
    helpline [ 1 ] = 803 ;
    helpline [ 0 ] = 804 ;
  }
  error () ;
  lab30: if ( fileopened )
  bclose ( tfmfile ) ;
  Result = g ;
  return(Result) ;
}
void zcharwarning ( f , c )
internalfontnumber f ;
eightbits c ;
{charwarning_regmem
  if ( eqtb [ 9198 ] .cint > 0 )
  {
    begindiagnostic () ;
    printnl ( 819 ) ;
    print ( c ) ;
    print ( 820 ) ;
    slowprint ( fontname [ f ] ) ;
    printchar ( 33 ) ;
    enddiagnostic ( false ) ;
  }
}
halfword znewcharacter ( f , c )
internalfontnumber f ;
eightbits c ;
{/* 10 */ register halfword Result; newcharacter_regmem
  halfword p  ;
  if ( fontbc [ f ] <= c )
  if ( fontec [ f ] >= c )
  if ( ( fontinfo [ charbase [ f ] + c ] .qqqq .b0 > 0 ) )
  {
    p = getavail () ;
    mem [ p ] .hh.b0 = f ;
    mem [ p ] .hh.b1 = c ;
    Result = p ;
    return(Result) ;
  }
  charwarning ( f , c ) ;
  Result = 0 ;
  return(Result) ;
}
void dviswap ( )
{dviswap_regmem
  if ( dvilimit == dvibufsize )
  {
    writedvi ( 0 , halfbuf - 1 ) ;
    dvilimit = halfbuf ;
    dvioffset = dvioffset + dvibufsize ;
    dviptr = 0 ;
  }
  else {

    writedvi ( halfbuf , dvibufsize - 1 ) ;
    dvilimit = dvibufsize ;
  }
  dvigone = dvigone + halfbuf ;
}
void zdvifour ( x )
integer x ;
{dvifour_regmem
  if ( x >= 0 )
  {
    dvibuf [ dviptr ] = x / 16777216L ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  else {

    x = x + 1073741824L ;
    x = x + 1073741824L ;
    {
      dvibuf [ dviptr ] = ( x / 16777216L ) + 128 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
  }
  x = x % 16777216L ;
  {
    dvibuf [ dviptr ] = x / 65536L ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  x = x % 65536L ;
  {
    dvibuf [ dviptr ] = x / 256 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = x % 256 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
}
void zdvipop ( l )
integer l ;
{dvipop_regmem
  if ( ( l == dvioffset + dviptr ) && ( dviptr > 0 ) )
  decr ( dviptr ) ;
  else {

    dvibuf [ dviptr ] = 142 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
}
void zdvifontdef ( f )
internalfontnumber f ;
{dvifontdef_regmem
  poolpointer k  ;
  {
    dvibuf [ dviptr ] = 243 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = f - 1 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = fontcheck [ f ] .b0 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = fontcheck [ f ] .b1 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = fontcheck [ f ] .b2 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = fontcheck [ f ] .b3 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  dvifour ( fontsize [ f ] ) ;
  dvifour ( fontdsize [ f ] ) ;
  {
    dvibuf [ dviptr ] = ( strstart [ fontarea [ f ] + 1 ] - strstart [
    fontarea [ f ] ] ) ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {
    dvibuf [ dviptr ] = ( strstart [ fontname [ f ] + 1 ] - strstart [
    fontname [ f ] ] ) ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  {register integer for_end; k = strstart [ fontarea [ f ] ] ; for_end =
  strstart [ fontarea [ f ] + 1 ] - 1 ; if ( k <= for_end) do
    {
      dvibuf [ dviptr ] = strpool [ k ] ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
  while ( k++ < for_end ) ; }
  {register integer for_end; k = strstart [ fontname [ f ] ] ; for_end =
  strstart [ fontname [ f ] + 1 ] - 1 ; if ( k <= for_end) do
    {
      dvibuf [ dviptr ] = strpool [ k ] ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
  while ( k++ < for_end ) ; }
}
void zmovement ( w , o )
scaled w ;
eightbits o ;
{/* 10 40 45 2 1 */ movement_regmem
  smallnumber mstate  ;
  halfword p, q  ;
  integer k  ;
  q = getnode ( 3 ) ;
  mem [ q + 1 ] .cint = w ;
  mem [ q + 2 ] .cint = dvioffset + dviptr ;
  if ( o == 157 )
  {
    mem [ q ] .hh .v.RH = downptr ;
    downptr = q ;
  }
  else {

    mem [ q ] .hh .v.RH = rightptr ;
    rightptr = q ;
  }
  p = mem [ q ] .hh .v.RH ;
  mstate = 0 ;
  while ( p != 0 ) {

    if ( mem [ p + 1 ] .cint == w )
    switch ( mstate + mem [ p ] .hh .v.LH )
    {case 3 :
    case 4 :
    case 15 :
    case 16 :
      if ( mem [ p + 2 ] .cint < dvigone )
      goto lab45 ;
      else {

	k = mem [ p + 2 ] .cint - dvioffset ;
	if ( k < 0 )
	k = k + dvibufsize ;
	dvibuf [ k ] = dvibuf [ k ] + 5 ;
	mem [ p ] .hh .v.LH = 1 ;
	goto lab40 ;
      }
      break ;
    case 5 :
    case 9 :
    case 11 :
      if ( mem [ p + 2 ] .cint < dvigone )
      goto lab45 ;
      else {

	k = mem [ p + 2 ] .cint - dvioffset ;
	if ( k < 0 )
	k = k + dvibufsize ;
	dvibuf [ k ] = dvibuf [ k ] + 10 ;
	mem [ p ] .hh .v.LH = 2 ;
	goto lab40 ;
      }
      break ;
    case 1 :
    case 2 :
    case 8 :
    case 13 :
      goto lab40 ;
      break ;
      default:
      ;
      break ;
    }
    else switch ( mstate + mem [ p ] .hh .v.LH )
    {case 1 :
      mstate = 6 ;
      break ;
    case 2 :
      mstate = 12 ;
      break ;
    case 8 :
    case 13 :
      goto lab45 ;
      break ;
      default:
      ;
      break ;
    }
    p = mem [ p ] .hh .v.RH ;
  }
  lab45: ;
  mem [ q ] .hh .v.LH = 3 ;
  if ( abs ( w ) >= 8388608L )
  {
    {
      dvibuf [ dviptr ] = o + 3 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    dvifour ( w ) ;
    return ;
  }
  if ( abs ( w ) >= 32768L )
  {
    {
      dvibuf [ dviptr ] = o + 2 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    if ( w < 0 )
    w = w + 16777216L ;
    {
      dvibuf [ dviptr ] = w / 65536L ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    w = w % 65536L ;
    goto lab2 ;
  }
  if ( abs ( w ) >= 128 )
  {
    {
      dvibuf [ dviptr ] = o + 1 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    if ( w < 0 )
    w = w + 65536L ;
    goto lab2 ;
  }
  {
    dvibuf [ dviptr ] = o ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  if ( w < 0 )
  w = w + 256 ;
  goto lab1 ;
  lab2: {

    dvibuf [ dviptr ] = w / 256 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  lab1: {

    dvibuf [ dviptr ] = w % 256 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  return ;
  lab40: mem [ q ] .hh .v.LH = mem [ p ] .hh .v.LH ;
  if ( mem [ q ] .hh .v.LH == 1 )
  {
    {
      dvibuf [ dviptr ] = o + 4 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    while ( mem [ q ] .hh .v.RH != p ) {

      q = mem [ q ] .hh .v.RH ;
      switch ( mem [ q ] .hh .v.LH )
      {case 3 :
	mem [ q ] .hh .v.LH = 5 ;
	break ;
      case 4 :
	mem [ q ] .hh .v.LH = 6 ;
	break ;
	default:
	;
	break ;
      }
    }
  }
  else {

    {
      dvibuf [ dviptr ] = o + 9 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    while ( mem [ q ] .hh .v.RH != p ) {

      q = mem [ q ] .hh .v.RH ;
      switch ( mem [ q ] .hh .v.LH )
      {case 3 :
	mem [ q ] .hh .v.LH = 4 ;
	break ;
      case 5 :
	mem [ q ] .hh .v.LH = 6 ;
	break ;
	default:
	;
	break ;
      }
    }
  }
}
void zprunemovements ( l )
integer l ;
{/* 30 10 */ prunemovements_regmem
  halfword p  ;
  while ( downptr != 0 ) {

    if ( mem [ downptr + 2 ] .cint < l )
    goto lab30 ;
    p = downptr ;
    downptr = mem [ p ] .hh .v.RH ;
    freenode ( p , 3 ) ;
  }
  lab30: while ( rightptr != 0 ) {

    if ( mem [ rightptr + 2 ] .cint < l )
    return ;
    p = rightptr ;
    rightptr = mem [ p ] .hh .v.RH ;
    freenode ( p , 3 ) ;
  }
}
void zspecialout ( p )
halfword p ;
{specialout_regmem
  char oldsetting  ;
  poolpointer k  ;
  if ( curh != dvih )
  {
    movement ( curh - dvih , 143 ) ;
    dvih = curh ;
  }
  if ( curv != dviv )
  {
    movement ( curv - dviv , 157 ) ;
    dviv = curv ;
  }
  oldsetting = selector ;
  selector = 21 ;
  showtokenlist ( mem [ mem [ p + 1 ] .hh .v.RH ] .hh .v.RH , 0 , poolsize -
  poolptr ) ;
  selector = oldsetting ;
  {
    if ( poolptr + 1 > poolsize )
    overflow ( 257 , poolsize - initpoolptr ) ;
  }
  if ( ( poolptr - strstart [ strptr ] ) < 256 )
  {
    {
      dvibuf [ dviptr ] = 239 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    {
      dvibuf [ dviptr ] = ( poolptr - strstart [ strptr ] ) ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
  }
  else {

    {
      dvibuf [ dviptr ] = 242 ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
    dvifour ( ( poolptr - strstart [ strptr ] ) ) ;
  }
  {register integer for_end; k = strstart [ strptr ] ; for_end = poolptr - 1
  ; if ( k <= for_end) do
    {
      dvibuf [ dviptr ] = strpool [ k ] ;
      incr ( dviptr ) ;
      if ( dviptr == dvilimit )
      dviswap () ;
    }
  while ( k++ < for_end ) ; }
  poolptr = strstart [ strptr ] ;
}
void zwriteout ( p )
halfword p ;
{writeout_regmem
  char oldsetting  ;
  integer oldmode  ;
  smallnumber j  ;
  halfword q, r  ;
  q = getavail () ;
  mem [ q ] .hh .v.LH = 637 ;
  r = getavail () ;
  mem [ q ] .hh .v.RH = r ;
  mem [ r ] .hh .v.LH = 10617 ;
  begintokenlist ( q , 4 ) ;
  begintokenlist ( mem [ p + 1 ] .hh .v.RH , 15 ) ;
  q = getavail () ;
  mem [ q ] .hh .v.LH = 379 ;
  begintokenlist ( q , 4 ) ;
  oldmode = curlist .modefield ;
  curlist .modefield = 0 ;
  curcs = writeloc ;
  q = scantoks ( false , true ) ;
  gettoken () ;
  if ( curtok != 10617 )
  {
    {
      if ( interaction == 3 )
      ;
      printnl ( 262 ) ;
      print ( 1291 ) ;
    }
    {
      helpptr = 2 ;
      helpline [ 1 ] = 1292 ;
      helpline [ 0 ] = 1006 ;
    }
    error () ;
    do {
	gettoken () ;
    } while ( ! ( curtok == 10617 ) ) ;
  }
  curlist .modefield = oldmode ;
  endtokenlist () ;
  oldsetting = selector ;
  j = mem [ p + 1 ] .hh .v.LH ;
  if ( writeopen [ j ] )
  selector = j ;
  else {

    if ( ( j == 17 ) && ( selector == 19 ) )
    selector = 18 ;
    printnl ( 335 ) ;
  }
  tokenshow ( defref ) ;
  println () ;
  flushlist ( defref ) ;
  selector = oldsetting ;
}
void zoutwhat ( p )
halfword p ;
{outwhat_regmem
  smallnumber j  ;
  switch ( mem [ p ] .hh.b1 )
  {case 0 :
  case 1 :
  case 2 :
    if ( ! doingleaders )
    {
      j = mem [ p + 1 ] .hh .v.LH ;
      if ( mem [ p ] .hh.b1 == 1 )
      writeout ( p ) ;
      else {

	if ( writeopen [ j ] )
	aclose ( writefile [ j ] ) ;
	if ( mem [ p ] .hh.b1 == 2 )
	writeopen [ j ] = false ;
	else if ( j < 16 )
	{
	  curname = mem [ p + 1 ] .hh .v.RH ;
	  curarea = mem [ p + 2 ] .hh .v.LH ;
	  curext = mem [ p + 2 ] .hh .v.RH ;
	  if ( curext == 335 )
	  curext = 785 ;
	  packfilename ( curname , curarea , curext ) ;
	  riscostype = riscostextype ;
	  while ( ! aopenout ( writefile [ j ] ) ) promptfilename ( 1294 , 785
	  ) ;
	  writeopen [ j ] = true ;
	}
      }
    }
    break ;
  case 3 :
    specialout ( p ) ;
    break ;
  case 4 :
    ;
    break ;
    default:
    confusion ( 1293 ) ;
    break ;
  }
}
void hlistout ( )
{/* 21 13 14 15 */ hlistout_regmem
  scaled baseline  ;
  scaled leftedge  ;
  scaled saveh, savev  ;
  halfword thisbox  ;
  glueord gorder  ;
  char gsign  ;
  halfword p  ;
  integer saveloc  ;
  halfword leaderbox  ;
  scaled leaderwd  ;
  scaled lx  ;
  boolean outerdoingleaders  ;
  scaled edge  ;
  real gluetemp  ;
  thisbox = tempptr ;
  gorder = mem [ thisbox + 5 ] .hh.b1 ;
  gsign = mem [ thisbox + 5 ] .hh.b0 ;
  p = mem [ thisbox + 5 ] .hh .v.RH ;
  incr ( curs ) ;
  if ( curs > 0 )
  {
    dvibuf [ dviptr ] = 141 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  if ( curs > maxpush )
  maxpush = curs ;
  saveloc = dvioffset + dviptr ;
  baseline = curv ;
  leftedge = curh ;
  while ( p != 0 ) lab21: if ( ( p >= himemmin ) )
  {
    if ( curh != dvih )
    {
      movement ( curh - dvih , 143 ) ;
      dvih = curh ;
    }
    if ( curv != dviv )
    {
      movement ( curv - dviv , 157 ) ;
      dviv = curv ;
    }
    do {
	f = mem [ p ] .hh.b0 ;
      c = mem [ p ] .hh.b1 ;
      if ( f != dvif )
      {
	if ( ! fontused [ f ] )
	{
	  dvifontdef ( f ) ;
	  fontused [ f ] = true ;
	}
	if ( f <= 64 )
	{
	  dvibuf [ dviptr ] = f + 170 ;
	  incr ( dviptr ) ;
	  if ( dviptr == dvilimit )
	  dviswap () ;
	}
	else {

	  {
	    dvibuf [ dviptr ] = 235 ;
	    incr ( dviptr ) ;
	    if ( dviptr == dvilimit )
	    dviswap () ;
	  }
	  {
	    dvibuf [ dviptr ] = f - 1 ;
	    incr ( dviptr ) ;
	    if ( dviptr == dvilimit )
	    dviswap () ;
	  }
	}
	dvif = f ;
      }
      if ( c >= 128 )
      {
	dvibuf [ dviptr ] = 128 ;
	incr ( dviptr ) ;
	if ( dviptr == dvilimit )
	dviswap () ;
      }
      {
	dvibuf [ dviptr ] = c ;
	incr ( dviptr ) ;
	if ( dviptr == dvilimit )
	dviswap () ;
      }
      curh = curh + fontinfo [ widthbase [ f ] + fontinfo [ charbase [ f ] + c
      ] .qqqq .b0 ] .cint ;
      p = mem [ p ] .hh .v.RH ;
    } while ( ! ( ! ( p >= himemmin ) ) ) ;
    dvih = curh ;
  }
  else {

    switch ( mem [ p ] .hh.b0 )
    {case 0 :
    case 1 :
      if ( mem [ p + 5 ] .hh .v.RH == 0 )
      curh = curh + mem [ p + 1 ] .cint ;
      else {

	saveh = dvih ;
	savev = dviv ;
	curv = baseline + mem [ p + 4 ] .cint ;
	tempptr = p ;
	edge = curh ;
	if ( mem [ p ] .hh.b0 == 1 )
	vlistout () ;
	else hlistout () ;
	dvih = saveh ;
	dviv = savev ;
	curh = edge + mem [ p + 1 ] .cint ;
	curv = baseline ;
      }
      break ;
    case 2 :
      {
	ruleht = mem [ p + 3 ] .cint ;
	ruledp = mem [ p + 2 ] .cint ;
	rulewd = mem [ p + 1 ] .cint ;
	goto lab14 ;
      }
      break ;
    case 8 :
      outwhat ( p ) ;
      break ;
    case 10 :
      {
	g = mem [ p + 1 ] .hh .v.LH ;
	rulewd = mem [ g + 1 ] .cint ;
	if ( gsign != 0 )
	{
	  if ( gsign == 1 )
	  {
	    if ( mem [ g ] .hh.b0 == gorder )
	    {
	      gluetemp = mem [ thisbox + 6 ] .gr * mem [ g + 2 ] .cint ;
	      if ( gluetemp > 1000000000.0 )
	      gluetemp = 1000000000.0 ;
	      else if ( gluetemp < -1000000000.0 )
	      gluetemp = -1000000000.0 ;
	      rulewd = rulewd + round ( gluetemp ) ;
	    }
	  }
	  else if ( mem [ g ] .hh.b1 == gorder )
	  {
	    gluetemp = mem [ thisbox + 6 ] .gr * mem [ g + 3 ] .cint ;
	    if ( gluetemp > 1000000000.0 )
	    gluetemp = 1000000000.0 ;
	    else if ( gluetemp < -1000000000.0 )
	    gluetemp = -1000000000.0 ;
	    rulewd = rulewd - round ( gluetemp ) ;
	  }
	}
	if ( mem [ p ] .hh.b1 >= 100 )
	{
	  leaderbox = mem [ p + 1 ] .hh .v.RH ;
	  if ( mem [ leaderbox ] .hh.b0 == 2 )
	  {
	    ruleht = mem [ leaderbox + 3 ] .cint ;
	    ruledp = mem [ leaderbox + 2 ] .cint ;
	    goto lab14 ;
	  }
	  leaderwd = mem [ leaderbox + 1 ] .cint ;
	  if ( ( leaderwd > 0 ) && ( rulewd > 0 ) )
	  {
	    rulewd = rulewd + 10 ;
	    edge = curh + rulewd ;
	    lx = 0 ;
	    if ( mem [ p ] .hh.b1 == 100 )
	    {
	      saveh = curh ;
	      curh = leftedge + leaderwd * ( ( curh - leftedge ) / leaderwd )
	      ;
	      if ( curh < saveh )
	      curh = curh + leaderwd ;
	    }
	    else {

	      lq = rulewd / leaderwd ;
	      lr = rulewd % leaderwd ;
	      if ( mem [ p ] .hh.b1 == 101 )
	      curh = curh + ( lr / 2 ) ;
	      else {

		lx = ( 2 * lr + lq + 1 ) / ( 2 * lq + 2 ) ;
		curh = curh + ( ( lr - ( lq - 1 ) * lx ) / 2 ) ;
	      }
	    }
	    while ( curh + leaderwd <= edge ) {

	      curv = baseline + mem [ leaderbox + 4 ] .cint ;
	      if ( curv != dviv )
	      {
		movement ( curv - dviv , 157 ) ;
		dviv = curv ;
	      }
	      savev = dviv ;
	      if ( curh != dvih )
	      {
		movement ( curh - dvih , 143 ) ;
		dvih = curh ;
	      }
	      saveh = dvih ;
	      tempptr = leaderbox ;
	      outerdoingleaders = doingleaders ;
	      doingleaders = true ;
	      if ( mem [ leaderbox ] .hh.b0 == 1 )
	      vlistout () ;
	      else hlistout () ;
	      doingleaders = outerdoingleaders ;
	      dviv = savev ;
	      dvih = saveh ;
	      curv = baseline ;
	      curh = saveh + leaderwd + lx ;
	    }
	    curh = edge - 10 ;
	    goto lab15 ;
	  }
	}
	goto lab13 ;
      }
      break ;
    case 11 :
    case 9 :
      curh = curh + mem [ p + 1 ] .cint ;
      break ;
    case 6 :
      {
	mem [ memtop - 12 ] = mem [ p + 1 ] ;
	mem [ memtop - 12 ] .hh .v.RH = mem [ p ] .hh .v.RH ;
	p = memtop - 12 ;
	goto lab21 ;
      }
      break ;
      default:
      ;
      break ;
    }
    goto lab15 ;
    lab14: if ( ( ruleht == -1073741824L ) )
    ruleht = mem [ thisbox + 3 ] .cint ;
    if ( ( ruledp == -1073741824L ) )
    ruledp = mem [ thisbox + 2 ] .cint ;
    ruleht = ruleht + ruledp ;
    if ( ( ruleht > 0 ) && ( rulewd > 0 ) )
    {
      if ( curh != dvih )
      {
	movement ( curh - dvih , 143 ) ;
	dvih = curh ;
      }
      curv = baseline + ruledp ;
      if ( curv != dviv )
      {
	movement ( curv - dviv , 157 ) ;
	dviv = curv ;
      }
      {
	dvibuf [ dviptr ] = 132 ;
	incr ( dviptr ) ;
	if ( dviptr == dvilimit )
	dviswap () ;
      }
      dvifour ( ruleht ) ;
      dvifour ( rulewd ) ;
      curv = baseline ;
      dvih = dvih + rulewd ;
    }
    lab13: curh = curh + rulewd ;
    lab15: p = mem [ p ] .hh .v.RH ;
  }
  prunemovements ( saveloc ) ;
  if ( curs > 0 )
  dvipop ( saveloc ) ;
  decr ( curs ) ;
}
void vlistout ( )
{/* 13 14 15 */ vlistout_regmem
  scaled leftedge  ;
  scaled topedge  ;
  scaled saveh, savev  ;
  halfword thisbox  ;
  glueord gorder  ;
  char gsign  ;
  halfword p  ;
  integer saveloc  ;
  halfword leaderbox  ;
  scaled leaderht  ;
  scaled lx  ;
  boolean outerdoingleaders  ;
  scaled edge  ;
  real gluetemp  ;
  thisbox = tempptr ;
  gorder = mem [ thisbox + 5 ] .hh.b1 ;
  gsign = mem [ thisbox + 5 ] .hh.b0 ;
  p = mem [ thisbox + 5 ] .hh .v.RH ;
  incr ( curs ) ;
  if ( curs > 0 )
  {
    dvibuf [ dviptr ] = 141 ;
    incr ( dviptr ) ;
    if ( dviptr == dvilimit )
    dviswap () ;
  }
  if ( curs > maxpush )
  maxpush = curs ;
  saveloc = dvioffset + dviptr ;
  leftedge = curh ;
  curv = curv - mem [ thisbox + 3 ] .cint ;
  topedge = curv ;
  while ( p != 0 ) {

    if ( ( p >= himemmin ) )
    confusion ( 822 ) ;
    else {

      switch ( mem [ p ] .hh.b0 )
      {case 0 :
      case 1 :
	if ( mem [ p + 5 ] .hh .v.RH == 0 )
	curv = curv + mem [ p + 3 ] .cint + mem [ p + 2 ] .cint ;
	else {

	  curv = curv + mem [ p + 3 ] .cint ;
	  if ( curv != dviv )
	  {
	    movement ( curv - dviv , 157 ) ;
	    dviv = curv ;
	  }
	  saveh = dvih ;
	  savev = dviv ;
	  curh = leftedge + mem [ p + 4 ] .cint ;
	  tempptr = p ;
	  if ( mem [ p ] .hh.b0 == 1 )
	  vlistout () ;
	  else hlistout () ;
	  dvih = saveh ;
	  dviv = savev ;
	  curv = savev + mem [ p + 2 ] .cint ;
	  curh = leftedge ;
	}
	break ;
      case 2 :
	{
	  ruleht = mem [ p + 3 ] .cint ;
	  ruledp = mem [ p + 2 ] .cint ;
	  rulewd = mem [ p + 1 ] .cint ;
	  goto lab14 ;
	}
	break ;
      case 8 :
	outwhat ( p ) ;
	break ;
      case 10 :
	{
	  g = mem [ p + 1 ] .hh .v.LH ;
	  ruleht = mem [ g + 1 ] .cint ;
	  if ( gsign != 0 )
	  {
	    if ( gsign == 1 )
	    {
	      if ( mem [ g ] .hh.b0 == gorder )
	      {
		gluetemp = mem [ thisbox + 6 ] .gr * mem [ g + 2 ] .cint ;
		if ( gluetemp > 1000000000.0 )
		gluetemp = 1000000000.0 ;
		else if ( gluetemp < -1000000000.0 )
		gluetemp = -1000000000.0 ;
		ruleht = ruleht + round ( gluetemp ) ;
	      }
	    }
	    else if ( mem [ g ] .hh.b1 == gorder )
	    {
	      gluetemp = mem [ thisbox + 6 ] .gr * mem [ g + 3 ] .cint ;
	      if ( gluetemp > 1000000000.0 )
	      gluetemp = 1000000000.0 ;
	      else if ( gluetemp < -1000000000.0 )
	      gluetemp = -1000000000.0 ;
	      ruleht = ruleht - round ( gluetemp ) ;
	    }
	  }
	  if ( mem [ p ] .hh.b1 >= 100 )
	  {
	    leaderbox = mem [ p + 1 ] .hh .v.RH ;
	    if ( mem [ leaderbox ] .hh.b0 == 2 )
	    {
	      rulewd = mem [ leaderbox + 1 ] .cint ;
	      ruledp = 0 ;
	      goto lab14 ;
	    }
	    leaderht = mem [ leaderbox + 3 ] .cint + mem [ leaderbox + 2 ]
	    .cint ;
	    if ( ( leaderht > 0 ) && ( ruleht > 0 ) )
	    {
	      ruleht = ruleht + 10 ;
	      edge = curv + ruleht ;
	      lx = 0 ;
	      if ( mem [ p ] .hh.b1 == 100 )
	      {
		savev = curv ;
		curv = topedge + leaderht * ( ( curv - topedge ) / leaderht )
		;
		if ( curv < savev )
		curv = curv + leaderht ;
	      }
	      else {

		lq = ruleht / leaderht ;
		lr = ruleht % leaderht ;
		if ( mem [ p ] .hh.b1 == 101 )
		curv = curv + ( lr / 2 ) ;
		else {

		  lx = ( 2 * lr + lq + 1 ) / ( 2 * lq + 2 ) ;
		  curv = curv + ( ( lr - ( lq - 1 ) * lx ) / 2 ) ;
		}
	      }
	      while ( curv + leaderht <= edge ) {

		curh = leftedge + mem [ leaderbox + 4 ] .cint ;
		if ( curh != dvih )
		{
		  movement ( curh - dvih , 143 ) ;
		  dvih = curh ;
		}
		saveh = dvih ;
		curv = curv + mem [ leaderbox + 3 ] .cint ;
		if ( curv != dviv )
		{
		  movement ( curv - dviv , 157 ) ;
		  dviv = curv ;
		}
		savev = dviv ;
		tempptr = leaderbox ;
		outerdoingleaders = doingleaders ;
		doingleaders = true ;
		if ( mem [ leaderbox ] .hh.b0 == 1 )
		vlistout () ;
		else hlistout () ;
		doingleaders = outerdoingleaders ;
		dviv = savev ;
		dvih = saveh ;
		curh = leftedge ;
		curv = savev - mem [ leaderbox + 3 ] .cint + leaderht + lx ;
	      }
	      curv = edge - 10 ;
	      goto lab15 ;
	    }
	  }
	  goto lab13 ;
	}
	break ;
      case 11 :
	curv = curv + mem [ p + 1 ] .cint ;
	break ;
	default:
	;
	break ;
      }
      goto lab15 ;
      lab14: if ( ( rulewd == -1073741824L ) )
      rulewd = mem [ thisbox + 1 ] .cint ;
      ruleht = ruleht + ruledp ;
      curv = curv + ruleht ;
      if ( ( ruleht > 0 ) && ( rulewd > 0 ) )
      {
	if ( curh != dvih )
	{
	  movement ( curh - dvih , 143 ) ;
	  dvih = curh ;
	}
	if ( curv != dviv )
	{
	  movement ( curv - dviv , 157 ) ;
	  dviv = curv ;
	}
	{
	  dvibuf [ dviptr ] = 137 ;
	  incr ( dviptr ) ;
	  if ( dviptr == dvilimit )
	  dviswap () ;
	}
	dvifour ( ruleht ) ;
	dvifour ( rulewd ) ;
      }
      goto lab15 ;
      lab13: curv = curv + ruleht ;
    }
    lab15: p = mem [ p ] .hh .v.RH ;
  }
  prunemovements ( saveloc ) ;
  if ( curs > 0 )
  dvipop ( saveloc ) ;
  decr ( curs ) ;
}
